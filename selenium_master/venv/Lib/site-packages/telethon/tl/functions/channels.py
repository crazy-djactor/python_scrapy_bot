"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from ...tl import types
from ...utils import get_input_peer, get_input_channel, get_input_user, get_input_media, get_input_photo
import os
import struct


class CheckUsernameRequest(TLObject):
    CONSTRUCTOR_ID = 0x10e6bd2c
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, channel, username):
        """
        :param TLObject channel:
        :param str username:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.username = username

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'username': self.username,
        }

    def __bytes__(self):
        return b''.join((
            b',\xbd\xe6\x10',
            bytes(self.channel),
            TLObject.serialize_bytes(self.username),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _username = reader.tgread_string()
        return CheckUsernameRequest(channel=_channel, username=_username)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class CreateChannelRequest(TLObject):
    CONSTRUCTOR_ID = 0xf4893d7f
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, title, about, broadcast=None, megagroup=None):
        """
        :param bool | None broadcast:
        :param bool | None megagroup:
        :param str title:
        :param str about:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.broadcast = broadcast
        self.megagroup = megagroup
        self.title = title
        self.about = about

    def to_dict(self, recursive=True):
        return {
            'broadcast': self.broadcast,
            'megagroup': self.megagroup,
            'title': self.title,
            'about': self.about,
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f=\x89\xf4',
            struct.pack('<I', (1 if self.broadcast else 0) | (2 if self.megagroup else 0)),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.about),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _broadcast = bool(flags & 1)
        _megagroup = bool(flags & 2)
        _title = reader.tgread_string()
        _about = reader.tgread_string()
        return CreateChannelRequest(title=_title, about=_about, broadcast=_broadcast, megagroup=_megagroup)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DeleteChannelRequest(TLObject):
    CONSTRUCTOR_ID = 0xc0111fe3
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel):
        """
        :param TLObject channel:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe3\x1f\x11\xc0',
            bytes(self.channel),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        return DeleteChannelRequest(channel=_channel)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DeleteMessagesRequest(TLObject):
    CONSTRUCTOR_ID = 0x84c1fd4e
    SUBCLASS_OF_ID = 0xced3c06e

    def __init__(self, channel, id):
        """
        :param TLObject channel:
        :param list[int] id:

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'id': [] if self.id is None else self.id[:],
        }

    def __bytes__(self):
        return b''.join((
            b'N\xfd\xc1\x84',
            bytes(self.channel),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return DeleteMessagesRequest(channel=_channel, id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DeleteUserHistoryRequest(TLObject):
    CONSTRUCTOR_ID = 0xd10dd71b
    SUBCLASS_OF_ID = 0x2c49c116

    def __init__(self, channel, user_id):
        """
        :param TLObject channel:
        :param TLObject user_id:

        :returns messages.AffectedHistory: Instance of AffectedHistory.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.user_id = get_input_user(user_id)

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1b\xd7\r\xd1',
            bytes(self.channel),
            bytes(self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _user_id = reader.tgread_object()
        return DeleteUserHistoryRequest(channel=_channel, user_id=_user_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditAboutRequest(TLObject):
    CONSTRUCTOR_ID = 0x13e27f1e
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, channel, about):
        """
        :param TLObject channel:
        :param str about:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.about = about

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'about': self.about,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1e\x7f\xe2\x13',
            bytes(self.channel),
            TLObject.serialize_bytes(self.about),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _about = reader.tgread_string()
        return EditAboutRequest(channel=_channel, about=_about)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditAdminRequest(TLObject):
    CONSTRUCTOR_ID = 0x20b88214
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel, user_id, admin_rights):
        """
        :param TLObject channel:
        :param TLObject user_id:
        :param TLObject admin_rights:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.user_id = get_input_user(user_id)
        self.admin_rights = admin_rights

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'admin_rights': (None if self.admin_rights is None else self.admin_rights.to_dict()) if recursive else self.admin_rights,
        }

    def __bytes__(self):
        return b''.join((
            b'\x14\x82\xb8 ',
            bytes(self.channel),
            bytes(self.user_id),
            bytes(self.admin_rights),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _user_id = reader.tgread_object()
        _admin_rights = reader.tgread_object()
        return EditAdminRequest(channel=_channel, user_id=_user_id, admin_rights=_admin_rights)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditBannedRequest(TLObject):
    CONSTRUCTOR_ID = 0xbfd915cd
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel, user_id, banned_rights):
        """
        :param TLObject channel:
        :param TLObject user_id:
        :param TLObject banned_rights:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.user_id = get_input_user(user_id)
        self.banned_rights = banned_rights

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'banned_rights': (None if self.banned_rights is None else self.banned_rights.to_dict()) if recursive else self.banned_rights,
        }

    def __bytes__(self):
        return b''.join((
            b'\xcd\x15\xd9\xbf',
            bytes(self.channel),
            bytes(self.user_id),
            bytes(self.banned_rights),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _user_id = reader.tgread_object()
        _banned_rights = reader.tgread_object()
        return EditBannedRequest(channel=_channel, user_id=_user_id, banned_rights=_banned_rights)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditPhotoRequest(TLObject):
    CONSTRUCTOR_ID = 0xf12e57c9
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel, photo):
        """
        :param TLObject channel:
        :param TLObject photo:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.photo = photo

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9W.\xf1',
            bytes(self.channel),
            bytes(self.photo),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _photo = reader.tgread_object()
        return EditPhotoRequest(channel=_channel, photo=_photo)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditTitleRequest(TLObject):
    CONSTRUCTOR_ID = 0x566decd0
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel, title):
        """
        :param TLObject channel:
        :param str title:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.title = title

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'title': self.title,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd0\xecmV',
            bytes(self.channel),
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _title = reader.tgread_string()
        return EditTitleRequest(channel=_channel, title=_title)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ExportInviteRequest(TLObject):
    CONSTRUCTOR_ID = 0xc7560885
    SUBCLASS_OF_ID = 0xb4748a58

    def __init__(self, channel):
        """
        :param TLObject channel:

        :returns ExportedChatInvite: Instance of either ChatInviteEmpty, ChatInviteExported.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
        }

    def __bytes__(self):
        return b''.join((
            b'\x85\x08V\xc7',
            bytes(self.channel),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        return ExportInviteRequest(channel=_channel)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ExportMessageLinkRequest(TLObject):
    CONSTRUCTOR_ID = 0xc846d22d
    SUBCLASS_OF_ID = 0xdee644cc

    def __init__(self, channel, id):
        """
        :param TLObject channel:
        :param int id:

        :returns ExportedMessageLink: Instance of ExportedMessageLink.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'-\xd2F\xc8',
            bytes(self.channel),
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _id = reader.read_int()
        return ExportMessageLinkRequest(channel=_channel, id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetAdminLogRequest(TLObject):
    CONSTRUCTOR_ID = 0x33ddf480
    SUBCLASS_OF_ID = 0x51f076bc

    def __init__(self, channel, q, max_id, min_id, limit, events_filter=None, admins=None):
        """
        :param TLObject channel:
        :param str q:
        :param TLObject | None events_filter:
        :param list[TLObject] | None admins:
        :param int max_id:
        :param int min_id:
        :param int limit:

        :returns channels.AdminLogResults: Instance of AdminLogResults.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.q = q
        self.events_filter = events_filter
        self.admins = [get_input_user(_x) for _x in admins] if admins else None
        self.max_id = max_id
        self.min_id = min_id
        self.limit = limit

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'q': self.q,
            'events_filter': (None if self.events_filter is None else self.events_filter.to_dict()) if recursive else self.events_filter,
            'admins': ([] if self.admins is None else [None if x is None else x.to_dict() for x in self.admins]) if recursive else self.admins,
            'max_id': self.max_id,
            'min_id': self.min_id,
            'limit': self.limit,
        }

    def __bytes__(self):
        return b''.join((
            b'\x80\xf4\xdd3',
            struct.pack('<I', (1 if self.events_filter else 0) | (2 if self.admins else 0)),
            bytes(self.channel),
            TLObject.serialize_bytes(self.q),
            b'' if not self.events_filter else (bytes(self.events_filter)),
            b'' if not self.admins else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.admins)),b''.join(bytes(x) for x in self.admins))),
            struct.pack('<q', self.max_id),
            struct.pack('<q', self.min_id),
            struct.pack('<i', self.limit),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _channel = reader.tgread_object()
        _q = reader.tgread_string()
        if flags & 1:
            _events_filter = reader.tgread_object()
        else:
            _events_filter = None
        if flags & 2:
            reader.read_int()
            _admins = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _admins.append(_x)

        else:
            _admins = None
        _max_id = reader.read_long()
        _min_id = reader.read_long()
        _limit = reader.read_int()
        return GetAdminLogRequest(channel=_channel, q=_q, max_id=_max_id, min_id=_min_id, limit=_limit, events_filter=_events_filter, admins=_admins)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetAdminedPublicChannelsRequest(TLObject):
    CONSTRUCTOR_ID = 0x8d8d82d7
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self):
        super().__init__()
        self.result = None
        self.content_related = True

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xd7\x82\x8d\x8d',
        ))

    @staticmethod
    def from_reader(reader):
        return GetAdminedPublicChannelsRequest()

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetChannelsRequest(TLObject):
    CONSTRUCTOR_ID = 0xa7f6bbb
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, id):
        """
        :param list[TLObject] id:

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = [get_input_channel(_x) for _x in id]

    def to_dict(self, recursive=True):
        return {
            'id': ([] if self.id is None else [None if x is None else x.to_dict() for x in self.id]) if recursive else self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xbbk\x7f\n',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(bytes(x) for x in self.id),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _id.append(_x)

        return GetChannelsRequest(id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetFullChannelRequest(TLObject):
    CONSTRUCTOR_ID = 0x8736a09
    SUBCLASS_OF_ID = 0x225a5109

    def __init__(self, channel):
        """
        :param TLObject channel:

        :returns messages.ChatFull: Instance of ChatFull.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
        }

    def __bytes__(self):
        return b''.join((
            b'\tjs\x08',
            bytes(self.channel),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        return GetFullChannelRequest(channel=_channel)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetMessagesRequest(TLObject):
    CONSTRUCTOR_ID = 0x93d7b347
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, channel, id):
        """
        :param TLObject channel:
        :param list[int] id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'id': [] if self.id is None else self.id[:],
        }

    def __bytes__(self):
        return b''.join((
            b'G\xb3\xd7\x93',
            bytes(self.channel),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return GetMessagesRequest(channel=_channel, id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetParticipantRequest(TLObject):
    CONSTRUCTOR_ID = 0x546dd7a6
    SUBCLASS_OF_ID = 0x6658151a

    def __init__(self, channel, user_id):
        """
        :param TLObject channel:
        :param TLObject user_id:

        :returns channels.ChannelParticipant: Instance of ChannelParticipant.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.user_id = get_input_user(user_id)

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa6\xd7mT',
            bytes(self.channel),
            bytes(self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _user_id = reader.tgread_object()
        return GetParticipantRequest(channel=_channel, user_id=_user_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetParticipantsRequest(TLObject):
    CONSTRUCTOR_ID = 0x24d98f92
    SUBCLASS_OF_ID = 0xe60a6e64

    def __init__(self, channel, filter, offset, limit):
        """
        :param TLObject channel:
        :param TLObject filter:
        :param int offset:
        :param int limit:

        :returns channels.ChannelParticipants: Instance of ChannelParticipants.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.filter = filter
        self.offset = offset
        self.limit = limit

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'filter': (None if self.filter is None else self.filter.to_dict()) if recursive else self.filter,
            'offset': self.offset,
            'limit': self.limit,
        }

    def __bytes__(self):
        return b''.join((
            b'\x92\x8f\xd9$',
            bytes(self.channel),
            bytes(self.filter),
            struct.pack('<i', self.offset),
            struct.pack('<i', self.limit),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _filter = reader.tgread_object()
        _offset = reader.read_int()
        _limit = reader.read_int()
        return GetParticipantsRequest(channel=_channel, filter=_filter, offset=_offset, limit=_limit)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InviteToChannelRequest(TLObject):
    CONSTRUCTOR_ID = 0x199f3a6c
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel, users):
        """
        :param TLObject channel:
        :param list[TLObject] users:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.users = [get_input_user(_x) for _x in users]

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def __bytes__(self):
        return b''.join((
            b'l:\x9f\x19',
            bytes(self.channel),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return InviteToChannelRequest(channel=_channel, users=_users)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class JoinChannelRequest(TLObject):
    CONSTRUCTOR_ID = 0x24b524c5
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel):
        """
        :param TLObject channel:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5$\xb5$',
            bytes(self.channel),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        return JoinChannelRequest(channel=_channel)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class LeaveChannelRequest(TLObject):
    CONSTRUCTOR_ID = 0xf836aa95
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel):
        """
        :param TLObject channel:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\xaa6\xf8',
            bytes(self.channel),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        return LeaveChannelRequest(channel=_channel)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReadHistoryRequest(TLObject):
    CONSTRUCTOR_ID = 0xcc104937
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, channel, max_id):
        """
        :param TLObject channel:
        :param int max_id:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.max_id = max_id

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'max_id': self.max_id,
        }

    def __bytes__(self):
        return b''.join((
            b'7I\x10\xcc',
            bytes(self.channel),
            struct.pack('<i', self.max_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _max_id = reader.read_int()
        return ReadHistoryRequest(channel=_channel, max_id=_max_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReadMessageContentsRequest(TLObject):
    CONSTRUCTOR_ID = 0xeab5dc38
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, channel, id):
        """
        :param TLObject channel:
        :param list[int] id:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'id': [] if self.id is None else self.id[:],
        }

    def __bytes__(self):
        return b''.join((
            b'8\xdc\xb5\xea',
            bytes(self.channel),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return ReadMessageContentsRequest(channel=_channel, id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReportSpamRequest(TLObject):
    CONSTRUCTOR_ID = 0xfe087810
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, channel, user_id, id):
        """
        :param TLObject channel:
        :param TLObject user_id:
        :param list[int] id:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.user_id = get_input_user(user_id)
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'id': [] if self.id is None else self.id[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\x10x\x08\xfe',
            bytes(self.channel),
            bytes(self.user_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _user_id = reader.tgread_object()
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return ReportSpamRequest(channel=_channel, user_id=_user_id, id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetStickersRequest(TLObject):
    CONSTRUCTOR_ID = 0xea8ca4f9
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, channel, stickerset):
        """
        :param TLObject channel:
        :param TLObject stickerset:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.stickerset = stickerset

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'stickerset': (None if self.stickerset is None else self.stickerset.to_dict()) if recursive else self.stickerset,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf9\xa4\x8c\xea',
            bytes(self.channel),
            bytes(self.stickerset),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _stickerset = reader.tgread_object()
        return SetStickersRequest(channel=_channel, stickerset=_stickerset)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ToggleInvitesRequest(TLObject):
    CONSTRUCTOR_ID = 0x49609307
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel, enabled):
        """
        :param TLObject channel:
        :param TLObject enabled:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.enabled = enabled

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'enabled': self.enabled,
        }

    def __bytes__(self):
        return b''.join((
            b'\x07\x93`I',
            bytes(self.channel),
            b'\xb5ur\x99' if self.enabled else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _enabled = reader.tgread_bool()
        return ToggleInvitesRequest(channel=_channel, enabled=_enabled)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ToggleSignaturesRequest(TLObject):
    CONSTRUCTOR_ID = 0x1f69b606
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel, enabled):
        """
        :param TLObject channel:
        :param TLObject enabled:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.enabled = enabled

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'enabled': self.enabled,
        }

    def __bytes__(self):
        return b''.join((
            b'\x06\xb6i\x1f',
            bytes(self.channel),
            b'\xb5ur\x99' if self.enabled else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _enabled = reader.tgread_bool()
        return ToggleSignaturesRequest(channel=_channel, enabled=_enabled)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdatePinnedMessageRequest(TLObject):
    CONSTRUCTOR_ID = 0xa72ded52
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, channel, id, silent=None):
        """
        :param bool | None silent:
        :param TLObject channel:
        :param int id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.silent = silent
        self.channel = get_input_channel(channel)
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'silent': self.silent,
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'R\xed-\xa7',
            struct.pack('<I', (1 if self.silent else 0)),
            bytes(self.channel),
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _silent = bool(flags & 1)
        _channel = reader.tgread_object()
        _id = reader.read_int()
        return UpdatePinnedMessageRequest(channel=_channel, id=_id, silent=_silent)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateUsernameRequest(TLObject):
    CONSTRUCTOR_ID = 0x3514b3de
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, channel, username):
        """
        :param TLObject channel:
        :param str username:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.channel = get_input_channel(channel)
        self.username = username

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
            'username': self.username,
        }

    def __bytes__(self):
        return b''.join((
            b'\xde\xb3\x145',
            bytes(self.channel),
            TLObject.serialize_bytes(self.username),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        _username = reader.tgread_string()
        return UpdateUsernameRequest(channel=_channel, username=_username)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
