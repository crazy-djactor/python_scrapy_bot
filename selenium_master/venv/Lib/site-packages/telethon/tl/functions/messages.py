"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from ...tl import types
from ...utils import get_input_peer, get_input_channel, get_input_user, get_input_media, get_input_photo
import os
import struct


class AcceptEncryptionRequest(TLObject):
    CONSTRUCTOR_ID = 0x3dbc0415
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, peer, g_b, key_fingerprint):
        """
        :param TLObject peer:
        :param bytes g_b:
        :param int key_fingerprint:

        :returns EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.g_b = g_b
        self.key_fingerprint = key_fingerprint

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'g_b': self.g_b,
            'key_fingerprint': self.key_fingerprint,
        }

    def __bytes__(self):
        return b''.join((
            b'\x15\x04\xbc=',
            bytes(self.peer),
            TLObject.serialize_bytes(self.g_b),
            struct.pack('<q', self.key_fingerprint),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _g_b = reader.tgread_bytes()
        _key_fingerprint = reader.read_long()
        return AcceptEncryptionRequest(peer=_peer, g_b=_g_b, key_fingerprint=_key_fingerprint)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class AddChatUserRequest(TLObject):
    CONSTRUCTOR_ID = 0xf9a0aa09
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id, user_id, fwd_limit):
        """
        :param int chat_id:
        :param TLObject user_id:
        :param int fwd_limit:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.user_id = get_input_user(user_id)
        self.fwd_limit = fwd_limit

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'fwd_limit': self.fwd_limit,
        }

    def __bytes__(self):
        return b''.join((
            b'\t\xaa\xa0\xf9',
            struct.pack('<i', self.chat_id),
            bytes(self.user_id),
            struct.pack('<i', self.fwd_limit),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.tgread_object()
        _fwd_limit = reader.read_int()
        return AddChatUserRequest(chat_id=_chat_id, user_id=_user_id, fwd_limit=_fwd_limit)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class CheckChatInviteRequest(TLObject):
    CONSTRUCTOR_ID = 0x3eadb1bb
    SUBCLASS_OF_ID = 0x4561736

    def __init__(self, hash):
        """
        :param str hash:

        :returns ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb\xb1\xad>',
            TLObject.serialize_bytes(self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.tgread_string()
        return CheckChatInviteRequest(hash=_hash)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ClearRecentStickersRequest(TLObject):
    CONSTRUCTOR_ID = 0x8999602d
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, attached=None):
        """
        :param bool | None attached:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.attached = attached

    def to_dict(self, recursive=True):
        return {
            'attached': self.attached,
        }

    def __bytes__(self):
        return b''.join((
            b'-`\x99\x89',
            struct.pack('<I', (1 if self.attached else 0)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _attached = bool(flags & 1)
        return ClearRecentStickersRequest(attached=_attached)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class CreateChatRequest(TLObject):
    CONSTRUCTOR_ID = 0x9cb126e
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, users, title):
        """
        :param list[TLObject] users:
        :param str title:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.users = [get_input_user(_x) for _x in users]
        self.title = title

    def to_dict(self, recursive=True):
        return {
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
            'title': self.title,
        }

    def __bytes__(self):
        return b''.join((
            b'n\x12\xcb\t',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        _title = reader.tgread_string()
        return CreateChatRequest(users=_users, title=_title)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DeleteChatUserRequest(TLObject):
    CONSTRUCTOR_ID = 0xe0611f16
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id, user_id):
        """
        :param int chat_id:
        :param TLObject user_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.user_id = get_input_user(user_id)

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x16\x1fa\xe0',
            struct.pack('<i', self.chat_id),
            bytes(self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.tgread_object()
        return DeleteChatUserRequest(chat_id=_chat_id, user_id=_user_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DeleteHistoryRequest(TLObject):
    CONSTRUCTOR_ID = 0x1c015b09
    SUBCLASS_OF_ID = 0x2c49c116

    def __init__(self, peer, max_id, just_clear=None):
        """
        :param bool | None just_clear:
        :param TLObject peer:
        :param int max_id:

        :returns messages.AffectedHistory: Instance of AffectedHistory.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.just_clear = just_clear
        self.peer = get_input_peer(peer)
        self.max_id = max_id

    def to_dict(self, recursive=True):
        return {
            'just_clear': self.just_clear,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'max_id': self.max_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\t[\x01\x1c',
            struct.pack('<I', (1 if self.just_clear else 0)),
            bytes(self.peer),
            struct.pack('<i', self.max_id),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _just_clear = bool(flags & 1)
        _peer = reader.tgread_object()
        _max_id = reader.read_int()
        return DeleteHistoryRequest(peer=_peer, max_id=_max_id, just_clear=_just_clear)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DeleteMessagesRequest(TLObject):
    CONSTRUCTOR_ID = 0xe58e95d2
    SUBCLASS_OF_ID = 0xced3c06e

    def __init__(self, id, revoke=None):
        """
        :param bool | None revoke:
        :param list[int] id:

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.revoke = revoke
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'revoke': self.revoke,
            'id': [] if self.id is None else self.id[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\xd2\x95\x8e\xe5',
            struct.pack('<I', (1 if self.revoke else 0)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _revoke = bool(flags & 1)
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return DeleteMessagesRequest(id=_id, revoke=_revoke)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DiscardEncryptionRequest(TLObject):
    CONSTRUCTOR_ID = 0xedd923c5
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5#\xd9\xed',
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        return DiscardEncryptionRequest(chat_id=_chat_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditChatAdminRequest(TLObject):
    CONSTRUCTOR_ID = 0xa9e69f2e
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, chat_id, user_id, is_admin):
        """
        :param int chat_id:
        :param TLObject user_id:
        :param TLObject is_admin:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.user_id = get_input_user(user_id)
        self.is_admin = is_admin

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'is_admin': self.is_admin,
        }

    def __bytes__(self):
        return b''.join((
            b'.\x9f\xe6\xa9',
            struct.pack('<i', self.chat_id),
            bytes(self.user_id),
            b'\xb5ur\x99' if self.is_admin else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.tgread_object()
        _is_admin = reader.tgread_bool()
        return EditChatAdminRequest(chat_id=_chat_id, user_id=_user_id, is_admin=_is_admin)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditChatPhotoRequest(TLObject):
    CONSTRUCTOR_ID = 0xca4c79d8
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id, photo):
        """
        :param int chat_id:
        :param TLObject photo:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.photo = photo

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd8yL\xca',
            struct.pack('<i', self.chat_id),
            bytes(self.photo),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _photo = reader.tgread_object()
        return EditChatPhotoRequest(chat_id=_chat_id, photo=_photo)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditChatTitleRequest(TLObject):
    CONSTRUCTOR_ID = 0xdc452855
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id, title):
        """
        :param int chat_id:
        :param str title:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.title = title

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'title': self.title,
        }

    def __bytes__(self):
        return b''.join((
            b'U(E\xdc',
            struct.pack('<i', self.chat_id),
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _title = reader.tgread_string()
        return EditChatTitleRequest(chat_id=_chat_id, title=_title)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditInlineBotMessageRequest(TLObject):
    CONSTRUCTOR_ID = 0x130c2c85
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id, no_webpage=None, message=None, reply_markup=None, entities=None):
        """
        :param bool | None no_webpage:
        :param TLObject id:
        :param str | None message:
        :param TLObject | None reply_markup:
        :param list[TLObject] | None entities:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.id = id
        self.message = message
        self.reply_markup = reply_markup
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'message': self.message,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def __bytes__(self):
        return b''.join((
            b'\x85,\x0c\x13',
            struct.pack('<I', (2 if self.no_webpage else 0) | (2048 if self.message else 0) | (4 if self.reply_markup else 0) | (8 if self.entities else 0)),
            bytes(self.id),
            b'' if not self.message else (TLObject.serialize_bytes(self.message)),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        _id = reader.tgread_object()
        if flags & 2048:
            _message = reader.tgread_string()
        else:
            _message = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return EditInlineBotMessageRequest(id=_id, no_webpage=_no_webpage, message=_message, reply_markup=_reply_markup, entities=_entities)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EditMessageRequest(TLObject):
    CONSTRUCTOR_ID = 0xce91e4ca
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, id, no_webpage=None, message=None, reply_markup=None, entities=None):
        """
        :param bool | None no_webpage:
        :param TLObject peer:
        :param int id:
        :param str | None message:
        :param TLObject | None reply_markup:
        :param list[TLObject] | None entities:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.peer = get_input_peer(peer)
        self.id = id
        self.message = message
        self.reply_markup = reply_markup
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': self.id,
            'message': self.message,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def __bytes__(self):
        return b''.join((
            b'\xca\xe4\x91\xce',
            struct.pack('<I', (2 if self.no_webpage else 0) | (2048 if self.message else 0) | (4 if self.reply_markup else 0) | (8 if self.entities else 0)),
            bytes(self.peer),
            struct.pack('<i', self.id),
            b'' if not self.message else (TLObject.serialize_bytes(self.message)),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        _peer = reader.tgread_object()
        _id = reader.read_int()
        if flags & 2048:
            _message = reader.tgread_string()
        else:
            _message = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return EditMessageRequest(peer=_peer, id=_id, no_webpage=_no_webpage, message=_message, reply_markup=_reply_markup, entities=_entities)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ExportChatInviteRequest(TLObject):
    CONSTRUCTOR_ID = 0x7d885289
    SUBCLASS_OF_ID = 0xb4748a58

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns ExportedChatInvite: Instance of either ChatInviteEmpty, ChatInviteExported.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x89R\x88}',
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        return ExportChatInviteRequest(chat_id=_chat_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FaveStickerRequest(TLObject):
    CONSTRUCTOR_ID = 0xb9ffc55b
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id, unfave):
        """
        :param TLObject id:
        :param TLObject unfave:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id
        self.unfave = unfave

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'unfave': self.unfave,
        }

    def __bytes__(self):
        return b''.join((
            b'[\xc5\xff\xb9',
            bytes(self.id),
            b'\xb5ur\x99' if self.unfave else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        _unfave = reader.tgread_bool()
        return FaveStickerRequest(id=_id, unfave=_unfave)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ForwardMessageRequest(TLObject):
    CONSTRUCTOR_ID = 0x33963bf9
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, id, random_id=None):
        """
        :param TLObject peer:
        :param int id:
        :param int random_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': self.id,
            'random_id': self.random_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf9;\x963',
            bytes(self.peer),
            struct.pack('<i', self.id),
            struct.pack('<q', self.random_id),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _id = reader.read_int()
        _random_id = reader.read_long()
        return ForwardMessageRequest(peer=_peer, id=_id, random_id=_random_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ForwardMessagesRequest(TLObject):
    CONSTRUCTOR_ID = 0x708e0195
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, from_peer, id, to_peer, silent=None, background=None, with_my_score=None, random_id=None):
        """
        :param bool | None silent:
        :param bool | None background:
        :param bool | None with_my_score:
        :param TLObject from_peer:
        :param list[int] id:
        :param list[int] random_id:
        :param TLObject to_peer:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.silent = silent
        self.background = background
        self.with_my_score = with_my_score
        self.from_peer = get_input_peer(from_peer)
        self.id = id
        self.random_id = random_id if random_id is not None else [int.from_bytes(os.urandom(8), 'big', signed=True) for _ in range(len(id))]
        self.to_peer = get_input_peer(to_peer)

    def to_dict(self, recursive=True):
        return {
            'silent': self.silent,
            'background': self.background,
            'with_my_score': self.with_my_score,
            'from_peer': (None if self.from_peer is None else self.from_peer.to_dict()) if recursive else self.from_peer,
            'id': [] if self.id is None else self.id[:],
            'random_id': [] if self.random_id is None else self.random_id[:],
            'to_peer': (None if self.to_peer is None else self.to_peer.to_dict()) if recursive else self.to_peer,
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\x01\x8ep',
            struct.pack('<I', (32 if self.silent else 0) | (64 if self.background else 0) | (256 if self.with_my_score else 0)),
            bytes(self.from_peer),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.random_id)),b''.join(struct.pack('<q', x) for x in self.random_id),
            bytes(self.to_peer),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _silent = bool(flags & 32)
        _background = bool(flags & 64)
        _with_my_score = bool(flags & 256)
        _from_peer = reader.tgread_object()
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        reader.read_int()
        _random_id = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _random_id.append(_x)

        _to_peer = reader.tgread_object()
        return ForwardMessagesRequest(from_peer=_from_peer, id=_id, to_peer=_to_peer, silent=_silent, background=_background, with_my_score=_with_my_score, random_id=_random_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetAllChatsRequest(TLObject):
    CONSTRUCTOR_ID = 0xeba80ff0
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, except_ids):
        """
        :param list[int] except_ids:

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.except_ids = except_ids

    def to_dict(self, recursive=True):
        return {
            'except_ids': [] if self.except_ids is None else self.except_ids[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\xf0\x0f\xa8\xeb',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.except_ids)),b''.join(struct.pack('<i', x) for x in self.except_ids),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _except_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _except_ids.append(_x)

        return GetAllChatsRequest(except_ids=_except_ids)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetAllDraftsRequest(TLObject):
    CONSTRUCTOR_ID = 0x6a3f8d65
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self):
        super().__init__()
        self.result = None
        self.content_related = True

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'e\x8d?j',
        ))

    @staticmethod
    def from_reader(reader):
        return GetAllDraftsRequest()

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetAllStickersRequest(TLObject):
    CONSTRUCTOR_ID = 0x1c9618b1
    SUBCLASS_OF_ID = 0x45834829

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb1\x18\x96\x1c',
            struct.pack('<i', self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        return GetAllStickersRequest(hash=_hash)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetArchivedStickersRequest(TLObject):
    CONSTRUCTOR_ID = 0x57f17692
    SUBCLASS_OF_ID = 0x7296d771

    def __init__(self, offset_id, limit, masks=None):
        """
        :param bool | None masks:
        :param int offset_id:
        :param int limit:

        :returns messages.ArchivedStickers: Instance of ArchivedStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.masks = masks
        self.offset_id = offset_id
        self.limit = limit

    def to_dict(self, recursive=True):
        return {
            'masks': self.masks,
            'offset_id': self.offset_id,
            'limit': self.limit,
        }

    def __bytes__(self):
        return b''.join((
            b'\x92v\xf1W',
            struct.pack('<I', (1 if self.masks else 0)),
            struct.pack('<q', self.offset_id),
            struct.pack('<i', self.limit),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _masks = bool(flags & 1)
        _offset_id = reader.read_long()
        _limit = reader.read_int()
        return GetArchivedStickersRequest(offset_id=_offset_id, limit=_limit, masks=_masks)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetAttachedStickersRequest(TLObject):
    CONSTRUCTOR_ID = 0xcc5b67cc
    SUBCLASS_OF_ID = 0xcc125f6b

    def __init__(self, media):
        """
        :param TLObject media:

        :returns Vector<StickerSetCovered>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.media = media

    def to_dict(self, recursive=True):
        return {
            'media': (None if self.media is None else self.media.to_dict()) if recursive else self.media,
        }

    def __bytes__(self):
        return b''.join((
            b'\xccg[\xcc',
            bytes(self.media),
        ))

    @staticmethod
    def from_reader(reader):
        _media = reader.tgread_object()
        return GetAttachedStickersRequest(media=_media)

    def on_response(self, reader):
        self.result = reader.tgread_vector()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetBotCallbackAnswerRequest(TLObject):
    CONSTRUCTOR_ID = 0x810a9fec
    SUBCLASS_OF_ID = 0x6c4dd18c

    def __init__(self, peer, msg_id, game=None, data=None):
        """
        :param bool | None game:
        :param TLObject peer:
        :param int msg_id:
        :param bytes | None data:

        :returns messages.BotCallbackAnswer: Instance of BotCallbackAnswer.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.game = game
        self.peer = get_input_peer(peer)
        self.msg_id = msg_id
        self.data = data

    def to_dict(self, recursive=True):
        return {
            'game': self.game,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'msg_id': self.msg_id,
            'data': self.data,
        }

    def __bytes__(self):
        return b''.join((
            b'\xec\x9f\n\x81',
            struct.pack('<I', (2 if self.game else 0) | (1 if self.data else 0)),
            bytes(self.peer),
            struct.pack('<i', self.msg_id),
            b'' if not self.data else (TLObject.serialize_bytes(self.data)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _game = bool(flags & 2)
        _peer = reader.tgread_object()
        _msg_id = reader.read_int()
        if flags & 1:
            _data = reader.tgread_bytes()
        else:
            _data = None
        return GetBotCallbackAnswerRequest(peer=_peer, msg_id=_msg_id, game=_game, data=_data)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetChatsRequest(TLObject):
    CONSTRUCTOR_ID = 0x3c6aa187
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, id):
        """
        :param list[int] id:

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\x87\xa1j<',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return GetChatsRequest(id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetCommonChatsRequest(TLObject):
    CONSTRUCTOR_ID = 0xd0a48c4
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, user_id, max_id, limit):
        """
        :param TLObject user_id:
        :param int max_id:
        :param int limit:

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.user_id = get_input_user(user_id)
        self.max_id = max_id
        self.limit = limit

    def to_dict(self, recursive=True):
        return {
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'max_id': self.max_id,
            'limit': self.limit,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4H\n\r',
            bytes(self.user_id),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.limit),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.tgread_object()
        _max_id = reader.read_int()
        _limit = reader.read_int()
        return GetCommonChatsRequest(user_id=_user_id, max_id=_max_id, limit=_limit)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetDhConfigRequest(TLObject):
    CONSTRUCTOR_ID = 0x26cf8950
    SUBCLASS_OF_ID = 0xe488ed8b

    def __init__(self, version, random_length):
        """
        :param int version:
        :param int random_length:

        :returns messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.version = version
        self.random_length = random_length

    def to_dict(self, recursive=True):
        return {
            'version': self.version,
            'random_length': self.random_length,
        }

    def __bytes__(self):
        return b''.join((
            b'P\x89\xcf&',
            struct.pack('<i', self.version),
            struct.pack('<i', self.random_length),
        ))

    @staticmethod
    def from_reader(reader):
        _version = reader.read_int()
        _random_length = reader.read_int()
        return GetDhConfigRequest(version=_version, random_length=_random_length)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetDialogsRequest(TLObject):
    CONSTRUCTOR_ID = 0x191ba9c5
    SUBCLASS_OF_ID = 0xe1b52ee

    def __init__(self, offset_date, offset_id, offset_peer, limit, exclude_pinned=None):
        """
        :param bool | None exclude_pinned:
        :param datetime.datetime | None offset_date:
        :param int offset_id:
        :param TLObject offset_peer:
        :param int limit:

        :returns messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.exclude_pinned = exclude_pinned
        self.offset_date = offset_date
        self.offset_id = offset_id
        self.offset_peer = get_input_peer(offset_peer)
        self.limit = limit

    def to_dict(self, recursive=True):
        return {
            'exclude_pinned': self.exclude_pinned,
            'offset_date': self.offset_date,
            'offset_id': self.offset_id,
            'offset_peer': (None if self.offset_peer is None else self.offset_peer.to_dict()) if recursive else self.offset_peer,
            'limit': self.limit,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5\xa9\x1b\x19',
            struct.pack('<I', (1 if self.exclude_pinned else 0)),
            b'\0\0\0\0' if self.offset_date is None else struct.pack('<I', int(self.offset_date.timestamp())),
            struct.pack('<i', self.offset_id),
            bytes(self.offset_peer),
            struct.pack('<i', self.limit),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _exclude_pinned = bool(flags & 1)
        _offset_date = reader.tgread_date()
        _offset_id = reader.read_int()
        _offset_peer = reader.tgread_object()
        _limit = reader.read_int()
        return GetDialogsRequest(offset_date=_offset_date, offset_id=_offset_id, offset_peer=_offset_peer, limit=_limit, exclude_pinned=_exclude_pinned)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetDocumentByHashRequest(TLObject):
    CONSTRUCTOR_ID = 0x338e2464
    SUBCLASS_OF_ID = 0x211fe820

    def __init__(self, sha256, size, mime_type):
        """
        :param bytes sha256:
        :param int size:
        :param str mime_type:

        :returns Document: Instance of either DocumentEmpty, Document.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.sha256 = sha256
        self.size = size
        self.mime_type = mime_type

    def to_dict(self, recursive=True):
        return {
            'sha256': self.sha256,
            'size': self.size,
            'mime_type': self.mime_type,
        }

    def __bytes__(self):
        return b''.join((
            b'd$\x8e3',
            TLObject.serialize_bytes(self.sha256),
            struct.pack('<i', self.size),
            TLObject.serialize_bytes(self.mime_type),
        ))

    @staticmethod
    def from_reader(reader):
        _sha256 = reader.tgread_bytes()
        _size = reader.read_int()
        _mime_type = reader.tgread_string()
        return GetDocumentByHashRequest(sha256=_sha256, size=_size, mime_type=_mime_type)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetFavedStickersRequest(TLObject):
    CONSTRUCTOR_ID = 0x21ce0b0e
    SUBCLASS_OF_ID = 0x8e736fb9

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.FavedStickers: Instance of either FavedStickersNotModified, FavedStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\x0e\x0b\xce!',
            struct.pack('<i', self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        return GetFavedStickersRequest(hash=_hash)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetFeaturedStickersRequest(TLObject):
    CONSTRUCTOR_ID = 0x2dacca4f
    SUBCLASS_OF_ID = 0x2614b722

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.FeaturedStickers: Instance of either FeaturedStickersNotModified, FeaturedStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'O\xca\xac-',
            struct.pack('<i', self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        return GetFeaturedStickersRequest(hash=_hash)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetFullChatRequest(TLObject):
    CONSTRUCTOR_ID = 0x3b831c66
    SUBCLASS_OF_ID = 0x225a5109

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns messages.ChatFull: Instance of ChatFull.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def __bytes__(self):
        return b''.join((
            b'f\x1c\x83;',
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        return GetFullChatRequest(chat_id=_chat_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetGameHighScoresRequest(TLObject):
    CONSTRUCTOR_ID = 0xe822649d
    SUBCLASS_OF_ID = 0x6ccd95fd

    def __init__(self, peer, id, user_id):
        """
        :param TLObject peer:
        :param int id:
        :param TLObject user_id:

        :returns messages.HighScores: Instance of HighScores.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id
        self.user_id = get_input_user(user_id)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': self.id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9dd"\xe8',
            bytes(self.peer),
            struct.pack('<i', self.id),
            bytes(self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _id = reader.read_int()
        _user_id = reader.tgread_object()
        return GetGameHighScoresRequest(peer=_peer, id=_id, user_id=_user_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetHistoryRequest(TLObject):
    CONSTRUCTOR_ID = 0xafa92846
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, peer, offset_id, offset_date, add_offset, limit, max_id, min_id):
        """
        :param TLObject peer:
        :param int offset_id:
        :param datetime.datetime | None offset_date:
        :param int add_offset:
        :param int limit:
        :param int max_id:
        :param int min_id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.offset_id = offset_id
        self.offset_date = offset_date
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'offset_id': self.offset_id,
            'offset_date': self.offset_date,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
        }

    def __bytes__(self):
        return b''.join((
            b'F(\xa9\xaf',
            bytes(self.peer),
            struct.pack('<i', self.offset_id),
            b'\0\0\0\0' if self.offset_date is None else struct.pack('<I', int(self.offset_date.timestamp())),
            struct.pack('<i', self.add_offset),
            struct.pack('<i', self.limit),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.min_id),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _offset_id = reader.read_int()
        _offset_date = reader.tgread_date()
        _add_offset = reader.read_int()
        _limit = reader.read_int()
        _max_id = reader.read_int()
        _min_id = reader.read_int()
        return GetHistoryRequest(peer=_peer, offset_id=_offset_id, offset_date=_offset_date, add_offset=_add_offset, limit=_limit, max_id=_max_id, min_id=_min_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetInlineBotResultsRequest(TLObject):
    CONSTRUCTOR_ID = 0x514e999d
    SUBCLASS_OF_ID = 0x3ed4d9c9

    def __init__(self, bot, peer, query, offset, geo_point=None):
        """
        :param TLObject bot:
        :param TLObject peer:
        :param TLObject | None geo_point:
        :param str query:
        :param str offset:

        :returns messages.BotResults: Instance of BotResults.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.bot = get_input_user(bot)
        self.peer = get_input_peer(peer)
        self.geo_point = geo_point
        self.query = query
        self.offset = offset

    def to_dict(self, recursive=True):
        return {
            'bot': (None if self.bot is None else self.bot.to_dict()) if recursive else self.bot,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'geo_point': (None if self.geo_point is None else self.geo_point.to_dict()) if recursive else self.geo_point,
            'query': self.query,
            'offset': self.offset,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9d\x99NQ',
            struct.pack('<I', (1 if self.geo_point else 0)),
            bytes(self.bot),
            bytes(self.peer),
            b'' if not self.geo_point else (bytes(self.geo_point)),
            TLObject.serialize_bytes(self.query),
            TLObject.serialize_bytes(self.offset),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _bot = reader.tgread_object()
        _peer = reader.tgread_object()
        if flags & 1:
            _geo_point = reader.tgread_object()
        else:
            _geo_point = None
        _query = reader.tgread_string()
        _offset = reader.tgread_string()
        return GetInlineBotResultsRequest(bot=_bot, peer=_peer, query=_query, offset=_offset, geo_point=_geo_point)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetInlineGameHighScoresRequest(TLObject):
    CONSTRUCTOR_ID = 0xf635e1b
    SUBCLASS_OF_ID = 0x6ccd95fd

    def __init__(self, id, user_id):
        """
        :param TLObject id:
        :param TLObject user_id:

        :returns messages.HighScores: Instance of HighScores.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id
        self.user_id = get_input_user(user_id)

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1b^c\x0f',
            bytes(self.id),
            bytes(self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        _user_id = reader.tgread_object()
        return GetInlineGameHighScoresRequest(id=_id, user_id=_user_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetMaskStickersRequest(TLObject):
    CONSTRUCTOR_ID = 0x65b8c79f
    SUBCLASS_OF_ID = 0x45834829

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9f\xc7\xb8e',
            struct.pack('<i', self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        return GetMaskStickersRequest(hash=_hash)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetMessageEditDataRequest(TLObject):
    CONSTRUCTOR_ID = 0xfda68d36
    SUBCLASS_OF_ID = 0xfb47949d

    def __init__(self, peer, id):
        """
        :param TLObject peer:
        :param int id:

        :returns messages.MessageEditData: Instance of MessageEditData.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'6\x8d\xa6\xfd',
            bytes(self.peer),
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _id = reader.read_int()
        return GetMessageEditDataRequest(peer=_peer, id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetMessagesRequest(TLObject):
    CONSTRUCTOR_ID = 0x4222fa74
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, id):
        """
        :param list[int] id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def __bytes__(self):
        return b''.join((
            b't\xfa"B',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return GetMessagesRequest(id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetMessagesViewsRequest(TLObject):
    CONSTRUCTOR_ID = 0xc4c8a55d
    SUBCLASS_OF_ID = 0x5026710f

    def __init__(self, peer, id, increment):
        """
        :param TLObject peer:
        :param list[int] id:
        :param TLObject increment:

        :returns Vector<int>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.id = id
        self.increment = increment

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': [] if self.id is None else self.id[:],
            'increment': self.increment,
        }

    def __bytes__(self):
        return b''.join((
            b']\xa5\xc8\xc4',
            bytes(self.peer),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
            b'\xb5ur\x99' if self.increment else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        _increment = reader.tgread_bool()
        return GetMessagesViewsRequest(peer=_peer, id=_id, increment=_increment)

    def on_response(self, reader):
        reader.read_int()  # Vector id
        count = reader.read_int()
        self.result = [reader.read_int() for _ in range(count)]

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetPeerDialogsRequest(TLObject):
    CONSTRUCTOR_ID = 0x2d9776b9
    SUBCLASS_OF_ID = 0x3ac70132

    def __init__(self, peers):
        """
        :param list[TLObject] peers:

        :returns messages.PeerDialogs: Instance of PeerDialogs.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peers = [get_input_peer(_x) for _x in peers]

    def to_dict(self, recursive=True):
        return {
            'peers': ([] if self.peers is None else [None if x is None else x.to_dict() for x in self.peers]) if recursive else self.peers,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb9v\x97-',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.peers)),b''.join(bytes(x) for x in self.peers),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _peers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _peers.append(_x)

        return GetPeerDialogsRequest(peers=_peers)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetPeerSettingsRequest(TLObject):
    CONSTRUCTOR_ID = 0x3672e09c
    SUBCLASS_OF_ID = 0xf6a79f84

    def __init__(self, peer):
        """
        :param TLObject peer:

        :returns PeerSettings: Instance of PeerSettings.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9c\xe0r6',
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        return GetPeerSettingsRequest(peer=_peer)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetPinnedDialogsRequest(TLObject):
    CONSTRUCTOR_ID = 0xe254d64e
    SUBCLASS_OF_ID = 0x3ac70132

    def __init__(self):
        super().__init__()
        self.result = None
        self.content_related = True

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'N\xd6T\xe2',
        ))

    @staticmethod
    def from_reader(reader):
        return GetPinnedDialogsRequest()

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetRecentStickersRequest(TLObject):
    CONSTRUCTOR_ID = 0x5ea192c9
    SUBCLASS_OF_ID = 0xf76f8683

    def __init__(self, hash, attached=None):
        """
        :param bool | None attached:
        :param int hash:

        :returns messages.RecentStickers: Instance of either RecentStickersNotModified, RecentStickers.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.attached = attached
        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'attached': self.attached,
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9\x92\xa1^',
            struct.pack('<I', (1 if self.attached else 0)),
            struct.pack('<i', self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _attached = bool(flags & 1)
        _hash = reader.read_int()
        return GetRecentStickersRequest(hash=_hash, attached=_attached)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetSavedGifsRequest(TLObject):
    CONSTRUCTOR_ID = 0x83bf3d52
    SUBCLASS_OF_ID = 0xa68b61f5

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.SavedGifs: Instance of either SavedGifsNotModified, SavedGifs.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'R=\xbf\x83',
            struct.pack('<i', self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        return GetSavedGifsRequest(hash=_hash)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetStickerSetRequest(TLObject):
    CONSTRUCTOR_ID = 0x2619a90e
    SUBCLASS_OF_ID = 0x9b704a5a

    def __init__(self, stickerset):
        """
        :param TLObject stickerset:

        :returns messages.StickerSet: Instance of StickerSet.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.stickerset = stickerset

    def to_dict(self, recursive=True):
        return {
            'stickerset': (None if self.stickerset is None else self.stickerset.to_dict()) if recursive else self.stickerset,
        }

    def __bytes__(self):
        return b''.join((
            b'\x0e\xa9\x19&',
            bytes(self.stickerset),
        ))

    @staticmethod
    def from_reader(reader):
        _stickerset = reader.tgread_object()
        return GetStickerSetRequest(stickerset=_stickerset)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetUnreadMentionsRequest(TLObject):
    CONSTRUCTOR_ID = 0x46578472
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, peer, offset_id, add_offset, limit, max_id, min_id):
        """
        :param TLObject peer:
        :param int offset_id:
        :param int add_offset:
        :param int limit:
        :param int max_id:
        :param int min_id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.offset_id = offset_id
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'offset_id': self.offset_id,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
        }

    def __bytes__(self):
        return b''.join((
            b'r\x84WF',
            bytes(self.peer),
            struct.pack('<i', self.offset_id),
            struct.pack('<i', self.add_offset),
            struct.pack('<i', self.limit),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.min_id),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _offset_id = reader.read_int()
        _add_offset = reader.read_int()
        _limit = reader.read_int()
        _max_id = reader.read_int()
        _min_id = reader.read_int()
        return GetUnreadMentionsRequest(peer=_peer, offset_id=_offset_id, add_offset=_add_offset, limit=_limit, max_id=_max_id, min_id=_min_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetWebPageRequest(TLObject):
    CONSTRUCTOR_ID = 0x32ca8f91
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, url, hash):
        """
        :param str url:
        :param int hash:

        :returns WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.url = url
        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\x91\x8f\xca2',
            TLObject.serialize_bytes(self.url),
            struct.pack('<i', self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _hash = reader.read_int()
        return GetWebPageRequest(url=_url, hash=_hash)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GetWebPagePreviewRequest(TLObject):
    CONSTRUCTOR_ID = 0x25223e24
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, message):
        """
        :param str message:

        :returns MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.message = message

    def to_dict(self, recursive=True):
        return {
            'message': self.message,
        }

    def __bytes__(self):
        return b''.join((
            b'$>"%',
            TLObject.serialize_bytes(self.message),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_string()
        return GetWebPagePreviewRequest(message=_message)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class HideReportSpamRequest(TLObject):
    CONSTRUCTOR_ID = 0xa8f1709b
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer):
        """
        :param TLObject peer:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9bp\xf1\xa8',
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        return HideReportSpamRequest(peer=_peer)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ImportChatInviteRequest(TLObject):
    CONSTRUCTOR_ID = 0x6c50051c
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, hash):
        """
        :param str hash:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c\x05Pl',
            TLObject.serialize_bytes(self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.tgread_string()
        return ImportChatInviteRequest(hash=_hash)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InstallStickerSetRequest(TLObject):
    CONSTRUCTOR_ID = 0xc78fe460
    SUBCLASS_OF_ID = 0x67cb3fe8

    def __init__(self, stickerset, archived):
        """
        :param TLObject stickerset:
        :param TLObject archived:

        :returns messages.StickerSetInstallResult: Instance of either StickerSetInstallResultSuccess, StickerSetInstallResultArchive.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.stickerset = stickerset
        self.archived = archived

    def to_dict(self, recursive=True):
        return {
            'stickerset': (None if self.stickerset is None else self.stickerset.to_dict()) if recursive else self.stickerset,
            'archived': self.archived,
        }

    def __bytes__(self):
        return b''.join((
            b'`\xe4\x8f\xc7',
            bytes(self.stickerset),
            b'\xb5ur\x99' if self.archived else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _stickerset = reader.tgread_object()
        _archived = reader.tgread_bool()
        return InstallStickerSetRequest(stickerset=_stickerset, archived=_archived)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MigrateChatRequest(TLObject):
    CONSTRUCTOR_ID = 0x15a3b8e3
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe3\xb8\xa3\x15',
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        return MigrateChatRequest(chat_id=_chat_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReadEncryptedHistoryRequest(TLObject):
    CONSTRUCTOR_ID = 0x7f4b690a
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, max_date):
        """
        :param TLObject peer:
        :param datetime.datetime | None max_date:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.max_date = max_date

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'max_date': self.max_date,
        }

    def __bytes__(self):
        return b''.join((
            b'\niK\x7f',
            bytes(self.peer),
            b'\0\0\0\0' if self.max_date is None else struct.pack('<I', int(self.max_date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _max_date = reader.tgread_date()
        return ReadEncryptedHistoryRequest(peer=_peer, max_date=_max_date)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReadFeaturedStickersRequest(TLObject):
    CONSTRUCTOR_ID = 0x5b118126
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id):
        """
        :param list[int] id:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def __bytes__(self):
        return b''.join((
            b'&\x81\x11[',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<q', x) for x in self.id),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _id.append(_x)

        return ReadFeaturedStickersRequest(id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReadHistoryRequest(TLObject):
    CONSTRUCTOR_ID = 0xe306d3a
    SUBCLASS_OF_ID = 0xced3c06e

    def __init__(self, peer, max_id):
        """
        :param TLObject peer:
        :param int max_id:

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.max_id = max_id

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'max_id': self.max_id,
        }

    def __bytes__(self):
        return b''.join((
            b':m0\x0e',
            bytes(self.peer),
            struct.pack('<i', self.max_id),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _max_id = reader.read_int()
        return ReadHistoryRequest(peer=_peer, max_id=_max_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReadMessageContentsRequest(TLObject):
    CONSTRUCTOR_ID = 0x36a73f77
    SUBCLASS_OF_ID = 0xced3c06e

    def __init__(self, id):
        """
        :param list[int] id:

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': [] if self.id is None else self.id[:],
        }

    def __bytes__(self):
        return b''.join((
            b'w?\xa76',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return ReadMessageContentsRequest(id=_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReceivedMessagesRequest(TLObject):
    CONSTRUCTOR_ID = 0x5a954c0
    SUBCLASS_OF_ID = 0x8565f897

    def __init__(self, max_id):
        """
        :param int max_id:

        :returns Vector<ReceivedNotifyMessage>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.max_id = max_id

    def to_dict(self, recursive=True):
        return {
            'max_id': self.max_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc0T\xa9\x05',
            struct.pack('<i', self.max_id),
        ))

    @staticmethod
    def from_reader(reader):
        _max_id = reader.read_int()
        return ReceivedMessagesRequest(max_id=_max_id)

    def on_response(self, reader):
        self.result = reader.tgread_vector()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReceivedQueueRequest(TLObject):
    CONSTRUCTOR_ID = 0x55a5bb66
    SUBCLASS_OF_ID = 0x8918e168

    def __init__(self, max_qts):
        """
        :param int max_qts:

        :returns Vector<long>: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.max_qts = max_qts

    def to_dict(self, recursive=True):
        return {
            'max_qts': self.max_qts,
        }

    def __bytes__(self):
        return b''.join((
            b'f\xbb\xa5U',
            struct.pack('<i', self.max_qts),
        ))

    @staticmethod
    def from_reader(reader):
        _max_qts = reader.read_int()
        return ReceivedQueueRequest(max_qts=_max_qts)

    def on_response(self, reader):
        reader.read_int()  # Vector id
        count = reader.read_long()
        self.result = [reader.read_long() for _ in range(count)]

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReorderPinnedDialogsRequest(TLObject):
    CONSTRUCTOR_ID = 0x959ff644
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, order, force=None):
        """
        :param bool | None force:
        :param list[TLObject] order:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.force = force
        self.order = [get_input_peer(_x) for _x in order]

    def to_dict(self, recursive=True):
        return {
            'force': self.force,
            'order': ([] if self.order is None else [None if x is None else x.to_dict() for x in self.order]) if recursive else self.order,
        }

    def __bytes__(self):
        return b''.join((
            b'D\xf6\x9f\x95',
            struct.pack('<I', (1 if self.force else 0)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.order)),b''.join(bytes(x) for x in self.order),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _force = bool(flags & 1)
        reader.read_int()
        _order = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _order.append(_x)

        return ReorderPinnedDialogsRequest(order=_order, force=_force)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReorderStickerSetsRequest(TLObject):
    CONSTRUCTOR_ID = 0x78337739
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, order, masks=None):
        """
        :param bool | None masks:
        :param list[int] order:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.masks = masks
        self.order = order

    def to_dict(self, recursive=True):
        return {
            'masks': self.masks,
            'order': [] if self.order is None else self.order[:],
        }

    def __bytes__(self):
        return b''.join((
            b'9w3x',
            struct.pack('<I', (1 if self.masks else 0)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.order)),b''.join(struct.pack('<q', x) for x in self.order),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _masks = bool(flags & 1)
        reader.read_int()
        _order = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _order.append(_x)

        return ReorderStickerSetsRequest(order=_order, masks=_masks)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReportEncryptedSpamRequest(TLObject):
    CONSTRUCTOR_ID = 0x4b0c8c0f
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer):
        """
        :param TLObject peer:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def __bytes__(self):
        return b''.join((
            b'\x0f\x8c\x0cK',
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        return ReportEncryptedSpamRequest(peer=_peer)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReportSpamRequest(TLObject):
    CONSTRUCTOR_ID = 0xcf1592db
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer):
        """
        :param TLObject peer:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb\x92\x15\xcf',
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        return ReportSpamRequest(peer=_peer)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class RequestEncryptionRequest(TLObject):
    CONSTRUCTOR_ID = 0xf64daf43
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, user_id, g_a, random_id=None):
        """
        :param TLObject user_id:
        :param int random_id:
        :param bytes g_a:

        :returns EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.user_id = get_input_user(user_id)
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(4), 'big', signed=True)
        self.g_a = g_a

    def to_dict(self, recursive=True):
        return {
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'random_id': self.random_id,
            'g_a': self.g_a,
        }

    def __bytes__(self):
        return b''.join((
            b'C\xafM\xf6',
            bytes(self.user_id),
            struct.pack('<i', self.random_id),
            TLObject.serialize_bytes(self.g_a),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.tgread_object()
        _random_id = reader.read_int()
        _g_a = reader.tgread_bytes()
        return RequestEncryptionRequest(user_id=_user_id, g_a=_g_a, random_id=_random_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SaveDraftRequest(TLObject):
    CONSTRUCTOR_ID = 0xbc39e14b
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, message, no_webpage=None, reply_to_msg_id=None, entities=None):
        """
        :param bool | None no_webpage:
        :param int | None reply_to_msg_id:
        :param TLObject peer:
        :param str message:
        :param list[TLObject] | None entities:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.reply_to_msg_id = reply_to_msg_id
        self.peer = get_input_peer(peer)
        self.message = message
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'reply_to_msg_id': self.reply_to_msg_id,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'message': self.message,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def __bytes__(self):
        return b''.join((
            b'K\xe19\xbc',
            struct.pack('<I', (2 if self.no_webpage else 0) | (1 if self.reply_to_msg_id else 0) | (8 if self.entities else 0)),
            b'' if not self.reply_to_msg_id else (struct.pack('<i', self.reply_to_msg_id)),
            bytes(self.peer),
            TLObject.serialize_bytes(self.message),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _peer = reader.tgread_object()
        _message = reader.tgread_string()
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return SaveDraftRequest(peer=_peer, message=_message, no_webpage=_no_webpage, reply_to_msg_id=_reply_to_msg_id, entities=_entities)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SaveGifRequest(TLObject):
    CONSTRUCTOR_ID = 0x327a30cb
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id, unsave):
        """
        :param TLObject id:
        :param TLObject unsave:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.id = id
        self.unsave = unsave

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'unsave': self.unsave,
        }

    def __bytes__(self):
        return b''.join((
            b'\xcb0z2',
            bytes(self.id),
            b'\xb5ur\x99' if self.unsave else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        _unsave = reader.tgread_bool()
        return SaveGifRequest(id=_id, unsave=_unsave)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SaveRecentStickerRequest(TLObject):
    CONSTRUCTOR_ID = 0x392718f8
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id, unsave, attached=None):
        """
        :param bool | None attached:
        :param TLObject id:
        :param TLObject unsave:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.attached = attached
        self.id = id
        self.unsave = unsave

    def to_dict(self, recursive=True):
        return {
            'attached': self.attached,
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'unsave': self.unsave,
        }

    def __bytes__(self):
        return b''.join((
            b"\xf8\x18'9",
            struct.pack('<I', (1 if self.attached else 0)),
            bytes(self.id),
            b'\xb5ur\x99' if self.unsave else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _attached = bool(flags & 1)
        _id = reader.tgread_object()
        _unsave = reader.tgread_bool()
        return SaveRecentStickerRequest(id=_id, unsave=_unsave, attached=_attached)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SearchRequest(TLObject):
    CONSTRUCTOR_ID = 0x39e9ea0
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, peer, q, filter, min_date, max_date, offset_id, add_offset, limit, max_id, min_id, from_id=None):
        """
        :param TLObject peer:
        :param str q:
        :param TLObject | None from_id:
        :param TLObject filter:
        :param datetime.datetime | None min_date:
        :param datetime.datetime | None max_date:
        :param int offset_id:
        :param int add_offset:
        :param int limit:
        :param int max_id:
        :param int min_id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.q = q
        self.from_id = get_input_user(from_id) if from_id else None
        self.filter = filter
        self.min_date = min_date
        self.max_date = max_date
        self.offset_id = offset_id
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'q': self.q,
            'from_id': (None if self.from_id is None else self.from_id.to_dict()) if recursive else self.from_id,
            'filter': (None if self.filter is None else self.filter.to_dict()) if recursive else self.filter,
            'min_date': self.min_date,
            'max_date': self.max_date,
            'offset_id': self.offset_id,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\x9e\x9e\x03',
            struct.pack('<I', (1 if self.from_id else 0)),
            bytes(self.peer),
            TLObject.serialize_bytes(self.q),
            b'' if not self.from_id else (bytes(self.from_id)),
            bytes(self.filter),
            b'\0\0\0\0' if self.min_date is None else struct.pack('<I', int(self.min_date.timestamp())),
            b'\0\0\0\0' if self.max_date is None else struct.pack('<I', int(self.max_date.timestamp())),
            struct.pack('<i', self.offset_id),
            struct.pack('<i', self.add_offset),
            struct.pack('<i', self.limit),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.min_id),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _peer = reader.tgread_object()
        _q = reader.tgread_string()
        if flags & 1:
            _from_id = reader.tgread_object()
        else:
            _from_id = None
        _filter = reader.tgread_object()
        _min_date = reader.tgread_date()
        _max_date = reader.tgread_date()
        _offset_id = reader.read_int()
        _add_offset = reader.read_int()
        _limit = reader.read_int()
        _max_id = reader.read_int()
        _min_id = reader.read_int()
        return SearchRequest(peer=_peer, q=_q, filter=_filter, min_date=_min_date, max_date=_max_date, offset_id=_offset_id, add_offset=_add_offset, limit=_limit, max_id=_max_id, min_id=_min_id, from_id=_from_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SearchGifsRequest(TLObject):
    CONSTRUCTOR_ID = 0xbf9a776b
    SUBCLASS_OF_ID = 0xe799ea7

    def __init__(self, q, offset):
        """
        :param str q:
        :param int offset:

        :returns messages.FoundGifs: Instance of FoundGifs.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.q = q
        self.offset = offset

    def to_dict(self, recursive=True):
        return {
            'q': self.q,
            'offset': self.offset,
        }

    def __bytes__(self):
        return b''.join((
            b'kw\x9a\xbf',
            TLObject.serialize_bytes(self.q),
            struct.pack('<i', self.offset),
        ))

    @staticmethod
    def from_reader(reader):
        _q = reader.tgread_string()
        _offset = reader.read_int()
        return SearchGifsRequest(q=_q, offset=_offset)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SearchGlobalRequest(TLObject):
    CONSTRUCTOR_ID = 0x9e3cacb0
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, q, offset_date, offset_peer, offset_id, limit):
        """
        :param str q:
        :param datetime.datetime | None offset_date:
        :param TLObject offset_peer:
        :param int offset_id:
        :param int limit:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.q = q
        self.offset_date = offset_date
        self.offset_peer = get_input_peer(offset_peer)
        self.offset_id = offset_id
        self.limit = limit

    def to_dict(self, recursive=True):
        return {
            'q': self.q,
            'offset_date': self.offset_date,
            'offset_peer': (None if self.offset_peer is None else self.offset_peer.to_dict()) if recursive else self.offset_peer,
            'offset_id': self.offset_id,
            'limit': self.limit,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb0\xac<\x9e',
            TLObject.serialize_bytes(self.q),
            b'\0\0\0\0' if self.offset_date is None else struct.pack('<I', int(self.offset_date.timestamp())),
            bytes(self.offset_peer),
            struct.pack('<i', self.offset_id),
            struct.pack('<i', self.limit),
        ))

    @staticmethod
    def from_reader(reader):
        _q = reader.tgread_string()
        _offset_date = reader.tgread_date()
        _offset_peer = reader.tgread_object()
        _offset_id = reader.read_int()
        _limit = reader.read_int()
        return SearchGlobalRequest(q=_q, offset_date=_offset_date, offset_peer=_offset_peer, offset_id=_offset_id, limit=_limit)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendEncryptedRequest(TLObject):
    CONSTRUCTOR_ID = 0xa9776773
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, peer, data, random_id=None):
        """
        :param TLObject peer:
        :param int random_id:
        :param bytes data:

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.data = data

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'random_id': self.random_id,
            'data': self.data,
        }

    def __bytes__(self):
        return b''.join((
            b'sgw\xa9',
            bytes(self.peer),
            struct.pack('<q', self.random_id),
            TLObject.serialize_bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _random_id = reader.read_long()
        _data = reader.tgread_bytes()
        return SendEncryptedRequest(peer=_peer, data=_data, random_id=_random_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendEncryptedFileRequest(TLObject):
    CONSTRUCTOR_ID = 0x9a901b66
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, peer, data, file, random_id=None):
        """
        :param TLObject peer:
        :param int random_id:
        :param bytes data:
        :param TLObject file:

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.data = data
        self.file = file

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'random_id': self.random_id,
            'data': self.data,
            'file': (None if self.file is None else self.file.to_dict()) if recursive else self.file,
        }

    def __bytes__(self):
        return b''.join((
            b'f\x1b\x90\x9a',
            bytes(self.peer),
            struct.pack('<q', self.random_id),
            TLObject.serialize_bytes(self.data),
            bytes(self.file),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _random_id = reader.read_long()
        _data = reader.tgread_bytes()
        _file = reader.tgread_object()
        return SendEncryptedFileRequest(peer=_peer, data=_data, file=_file, random_id=_random_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendEncryptedServiceRequest(TLObject):
    CONSTRUCTOR_ID = 0x32d439a4
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, peer, data, random_id=None):
        """
        :param TLObject peer:
        :param int random_id:
        :param bytes data:

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.data = data

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'random_id': self.random_id,
            'data': self.data,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa49\xd42',
            bytes(self.peer),
            struct.pack('<q', self.random_id),
            TLObject.serialize_bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _random_id = reader.read_long()
        _data = reader.tgread_bytes()
        return SendEncryptedServiceRequest(peer=_peer, data=_data, random_id=_random_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendInlineBotResultRequest(TLObject):
    CONSTRUCTOR_ID = 0xb16e06fe
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, query_id, id, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None):
        """
        :param bool | None silent:
        :param bool | None background:
        :param bool | None clear_draft:
        :param TLObject peer:
        :param int | None reply_to_msg_id:
        :param int random_id:
        :param int query_id:
        :param str id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.query_id = query_id
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'reply_to_msg_id': self.reply_to_msg_id,
            'random_id': self.random_id,
            'query_id': self.query_id,
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xfe\x06n\xb1',
            struct.pack('<I', (32 if self.silent else 0) | (64 if self.background else 0) | (128 if self.clear_draft else 0) | (1 if self.reply_to_msg_id else 0)),
            bytes(self.peer),
            b'' if not self.reply_to_msg_id else (struct.pack('<i', self.reply_to_msg_id)),
            struct.pack('<q', self.random_id),
            struct.pack('<q', self.query_id),
            TLObject.serialize_bytes(self.id),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _silent = bool(flags & 32)
        _background = bool(flags & 64)
        _clear_draft = bool(flags & 128)
        _peer = reader.tgread_object()
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _random_id = reader.read_long()
        _query_id = reader.read_long()
        _id = reader.tgread_string()
        return SendInlineBotResultRequest(peer=_peer, query_id=_query_id, id=_id, silent=_silent, background=_background, clear_draft=_clear_draft, reply_to_msg_id=_reply_to_msg_id, random_id=_random_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMediaRequest(TLObject):
    CONSTRUCTOR_ID = 0xc8f16791
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, media, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None, reply_markup=None):
        """
        :param bool | None silent:
        :param bool | None background:
        :param bool | None clear_draft:
        :param TLObject peer:
        :param int | None reply_to_msg_id:
        :param TLObject media:
        :param int random_id:
        :param TLObject | None reply_markup:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.media = get_input_media(media)
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'reply_to_msg_id': self.reply_to_msg_id,
            'media': (None if self.media is None else self.media.to_dict()) if recursive else self.media,
            'random_id': self.random_id,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'\x91g\xf1\xc8',
            struct.pack('<I', (32 if self.silent else 0) | (64 if self.background else 0) | (128 if self.clear_draft else 0) | (1 if self.reply_to_msg_id else 0) | (4 if self.reply_markup else 0)),
            bytes(self.peer),
            b'' if not self.reply_to_msg_id else (struct.pack('<i', self.reply_to_msg_id)),
            bytes(self.media),
            struct.pack('<q', self.random_id),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _silent = bool(flags & 32)
        _background = bool(flags & 64)
        _clear_draft = bool(flags & 128)
        _peer = reader.tgread_object()
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _media = reader.tgread_object()
        _random_id = reader.read_long()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return SendMediaRequest(peer=_peer, media=_media, silent=_silent, background=_background, clear_draft=_clear_draft, reply_to_msg_id=_reply_to_msg_id, random_id=_random_id, reply_markup=_reply_markup)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageRequest(TLObject):
    CONSTRUCTOR_ID = 0xfa88427a
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, message, no_webpage=None, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None, reply_markup=None, entities=None):
        """
        :param bool | None no_webpage:
        :param bool | None silent:
        :param bool | None background:
        :param bool | None clear_draft:
        :param TLObject peer:
        :param int | None reply_to_msg_id:
        :param str message:
        :param int random_id:
        :param TLObject | None reply_markup:
        :param list[TLObject] | None entities:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.no_webpage = no_webpage
        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.message = message
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.reply_markup = reply_markup
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'reply_to_msg_id': self.reply_to_msg_id,
            'message': self.message,
            'random_id': self.random_id,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def __bytes__(self):
        return b''.join((
            b'zB\x88\xfa',
            struct.pack('<I', (2 if self.no_webpage else 0) | (32 if self.silent else 0) | (64 if self.background else 0) | (128 if self.clear_draft else 0) | (1 if self.reply_to_msg_id else 0) | (4 if self.reply_markup else 0) | (8 if self.entities else 0)),
            bytes(self.peer),
            b'' if not self.reply_to_msg_id else (struct.pack('<i', self.reply_to_msg_id)),
            TLObject.serialize_bytes(self.message),
            struct.pack('<q', self.random_id),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        _silent = bool(flags & 32)
        _background = bool(flags & 64)
        _clear_draft = bool(flags & 128)
        _peer = reader.tgread_object()
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _message = reader.tgread_string()
        _random_id = reader.read_long()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return SendMessageRequest(peer=_peer, message=_message, no_webpage=_no_webpage, silent=_silent, background=_background, clear_draft=_clear_draft, reply_to_msg_id=_reply_to_msg_id, random_id=_random_id, reply_markup=_reply_markup, entities=_entities)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendScreenshotNotificationRequest(TLObject):
    CONSTRUCTOR_ID = 0xc97df020
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, reply_to_msg_id, random_id=None):
        """
        :param TLObject peer:
        :param int reply_to_msg_id:
        :param int random_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.reply_to_msg_id = reply_to_msg_id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'reply_to_msg_id': self.reply_to_msg_id,
            'random_id': self.random_id,
        }

    def __bytes__(self):
        return b''.join((
            b' \xf0}\xc9',
            bytes(self.peer),
            struct.pack('<i', self.reply_to_msg_id),
            struct.pack('<q', self.random_id),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _reply_to_msg_id = reader.read_int()
        _random_id = reader.read_long()
        return SendScreenshotNotificationRequest(peer=_peer, reply_to_msg_id=_reply_to_msg_id, random_id=_random_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetBotCallbackAnswerRequest(TLObject):
    CONSTRUCTOR_ID = 0xd58f130a
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, query_id, cache_time, alert=None, message=None, url=None):
        """
        :param bool | None alert:
        :param int query_id:
        :param str | None message:
        :param str | None url:
        :param int cache_time:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.alert = alert
        self.query_id = query_id
        self.message = message
        self.url = url
        self.cache_time = cache_time

    def to_dict(self, recursive=True):
        return {
            'alert': self.alert,
            'query_id': self.query_id,
            'message': self.message,
            'url': self.url,
            'cache_time': self.cache_time,
        }

    def __bytes__(self):
        return b''.join((
            b'\n\x13\x8f\xd5',
            struct.pack('<I', (2 if self.alert else 0) | (1 if self.message else 0) | (4 if self.url else 0)),
            struct.pack('<q', self.query_id),
            b'' if not self.message else (TLObject.serialize_bytes(self.message)),
            b'' if not self.url else (TLObject.serialize_bytes(self.url)),
            struct.pack('<i', self.cache_time),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _alert = bool(flags & 2)
        _query_id = reader.read_long()
        if flags & 1:
            _message = reader.tgread_string()
        else:
            _message = None
        if flags & 4:
            _url = reader.tgread_string()
        else:
            _url = None
        _cache_time = reader.read_int()
        return SetBotCallbackAnswerRequest(query_id=_query_id, cache_time=_cache_time, alert=_alert, message=_message, url=_url)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetBotPrecheckoutResultsRequest(TLObject):
    CONSTRUCTOR_ID = 0x9c2dd95
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, query_id, success=None, error=None):
        """
        :param bool | None success:
        :param int query_id:
        :param str | None error:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.success = success
        self.query_id = query_id
        self.error = error

    def to_dict(self, recursive=True):
        return {
            'success': self.success,
            'query_id': self.query_id,
            'error': self.error,
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\xdd\xc2\t',
            struct.pack('<I', (2 if self.success else 0) | (1 if self.error else 0)),
            struct.pack('<q', self.query_id),
            b'' if not self.error else (TLObject.serialize_bytes(self.error)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _success = bool(flags & 2)
        _query_id = reader.read_long()
        if flags & 1:
            _error = reader.tgread_string()
        else:
            _error = None
        return SetBotPrecheckoutResultsRequest(query_id=_query_id, success=_success, error=_error)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetBotShippingResultsRequest(TLObject):
    CONSTRUCTOR_ID = 0xe5f672fa
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, query_id, error=None, shipping_options=None):
        """
        :param int query_id:
        :param str | None error:
        :param list[TLObject] | None shipping_options:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.query_id = query_id
        self.error = error
        self.shipping_options = shipping_options

    def to_dict(self, recursive=True):
        return {
            'query_id': self.query_id,
            'error': self.error,
            'shipping_options': ([] if self.shipping_options is None else [None if x is None else x.to_dict() for x in self.shipping_options]) if recursive else self.shipping_options,
        }

    def __bytes__(self):
        return b''.join((
            b'\xfar\xf6\xe5',
            struct.pack('<I', (1 if self.error else 0) | (2 if self.shipping_options else 0)),
            struct.pack('<q', self.query_id),
            b'' if not self.error else (TLObject.serialize_bytes(self.error)),
            b'' if not self.shipping_options else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.shipping_options)),b''.join(bytes(x) for x in self.shipping_options))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        if flags & 1:
            _error = reader.tgread_string()
        else:
            _error = None
        if flags & 2:
            reader.read_int()
            _shipping_options = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _shipping_options.append(_x)

        else:
            _shipping_options = None
        return SetBotShippingResultsRequest(query_id=_query_id, error=_error, shipping_options=_shipping_options)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetEncryptedTypingRequest(TLObject):
    CONSTRUCTOR_ID = 0x791451ed
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, typing):
        """
        :param TLObject peer:
        :param TLObject typing:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = peer
        self.typing = typing

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'typing': self.typing,
        }

    def __bytes__(self):
        return b''.join((
            b'\xedQ\x14y',
            bytes(self.peer),
            b'\xb5ur\x99' if self.typing else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _typing = reader.tgread_bool()
        return SetEncryptedTypingRequest(peer=_peer, typing=_typing)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetGameScoreRequest(TLObject):
    CONSTRUCTOR_ID = 0x8ef8ecc0
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, id, user_id, score, edit_message=None, force=None):
        """
        :param bool | None edit_message:
        :param bool | None force:
        :param TLObject peer:
        :param int id:
        :param TLObject user_id:
        :param int score:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.edit_message = edit_message
        self.force = force
        self.peer = get_input_peer(peer)
        self.id = id
        self.user_id = get_input_user(user_id)
        self.score = score

    def to_dict(self, recursive=True):
        return {
            'edit_message': self.edit_message,
            'force': self.force,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'id': self.id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'score': self.score,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc0\xec\xf8\x8e',
            struct.pack('<I', (1 if self.edit_message else 0) | (2 if self.force else 0)),
            bytes(self.peer),
            struct.pack('<i', self.id),
            bytes(self.user_id),
            struct.pack('<i', self.score),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _edit_message = bool(flags & 1)
        _force = bool(flags & 2)
        _peer = reader.tgread_object()
        _id = reader.read_int()
        _user_id = reader.tgread_object()
        _score = reader.read_int()
        return SetGameScoreRequest(peer=_peer, id=_id, user_id=_user_id, score=_score, edit_message=_edit_message, force=_force)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetInlineBotResultsRequest(TLObject):
    CONSTRUCTOR_ID = 0xeb5ea206
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, query_id, results, cache_time, gallery=None, private=None, next_offset=None, switch_pm=None):
        """
        :param bool | None gallery:
        :param bool | None private:
        :param int query_id:
        :param list[TLObject] results:
        :param int cache_time:
        :param str | None next_offset:
        :param TLObject | None switch_pm:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.gallery = gallery
        self.private = private
        self.query_id = query_id
        self.results = results
        self.cache_time = cache_time
        self.next_offset = next_offset
        self.switch_pm = switch_pm

    def to_dict(self, recursive=True):
        return {
            'gallery': self.gallery,
            'private': self.private,
            'query_id': self.query_id,
            'results': ([] if self.results is None else [None if x is None else x.to_dict() for x in self.results]) if recursive else self.results,
            'cache_time': self.cache_time,
            'next_offset': self.next_offset,
            'switch_pm': (None if self.switch_pm is None else self.switch_pm.to_dict()) if recursive else self.switch_pm,
        }

    def __bytes__(self):
        return b''.join((
            b'\x06\xa2^\xeb',
            struct.pack('<I', (1 if self.gallery else 0) | (2 if self.private else 0) | (4 if self.next_offset else 0) | (8 if self.switch_pm else 0)),
            struct.pack('<q', self.query_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.results)),b''.join(bytes(x) for x in self.results),
            struct.pack('<i', self.cache_time),
            b'' if not self.next_offset else (TLObject.serialize_bytes(self.next_offset)),
            b'' if not self.switch_pm else (bytes(self.switch_pm)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _gallery = bool(flags & 1)
        _private = bool(flags & 2)
        _query_id = reader.read_long()
        reader.read_int()
        _results = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _results.append(_x)

        _cache_time = reader.read_int()
        if flags & 4:
            _next_offset = reader.tgread_string()
        else:
            _next_offset = None
        if flags & 8:
            _switch_pm = reader.tgread_object()
        else:
            _switch_pm = None
        return SetInlineBotResultsRequest(query_id=_query_id, results=_results, cache_time=_cache_time, gallery=_gallery, private=_private, next_offset=_next_offset, switch_pm=_switch_pm)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetInlineGameScoreRequest(TLObject):
    CONSTRUCTOR_ID = 0x15ad9f64
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id, user_id, score, edit_message=None, force=None):
        """
        :param bool | None edit_message:
        :param bool | None force:
        :param TLObject id:
        :param TLObject user_id:
        :param int score:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.edit_message = edit_message
        self.force = force
        self.id = id
        self.user_id = get_input_user(user_id)
        self.score = score

    def to_dict(self, recursive=True):
        return {
            'edit_message': self.edit_message,
            'force': self.force,
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
            'score': self.score,
        }

    def __bytes__(self):
        return b''.join((
            b'd\x9f\xad\x15',
            struct.pack('<I', (1 if self.edit_message else 0) | (2 if self.force else 0)),
            bytes(self.id),
            bytes(self.user_id),
            struct.pack('<i', self.score),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _edit_message = bool(flags & 1)
        _force = bool(flags & 2)
        _id = reader.tgread_object()
        _user_id = reader.tgread_object()
        _score = reader.read_int()
        return SetInlineGameScoreRequest(id=_id, user_id=_user_id, score=_score, edit_message=_edit_message, force=_force)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SetTypingRequest(TLObject):
    CONSTRUCTOR_ID = 0xa3825e50
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, action):
        """
        :param TLObject peer:
        :param TLObject action:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.action = action

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'action': (None if self.action is None else self.action.to_dict()) if recursive else self.action,
        }

    def __bytes__(self):
        return b''.join((
            b'P^\x82\xa3',
            bytes(self.peer),
            bytes(self.action),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _action = reader.tgread_object()
        return SetTypingRequest(peer=_peer, action=_action)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StartBotRequest(TLObject):
    CONSTRUCTOR_ID = 0xe6df7378
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, bot, peer, start_param, random_id=None):
        """
        :param TLObject bot:
        :param TLObject peer:
        :param int random_id:
        :param str start_param:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.bot = get_input_user(bot)
        self.peer = get_input_peer(peer)
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.start_param = start_param

    def to_dict(self, recursive=True):
        return {
            'bot': (None if self.bot is None else self.bot.to_dict()) if recursive else self.bot,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'random_id': self.random_id,
            'start_param': self.start_param,
        }

    def __bytes__(self):
        return b''.join((
            b'xs\xdf\xe6',
            bytes(self.bot),
            bytes(self.peer),
            struct.pack('<q', self.random_id),
            TLObject.serialize_bytes(self.start_param),
        ))

    @staticmethod
    def from_reader(reader):
        _bot = reader.tgread_object()
        _peer = reader.tgread_object()
        _random_id = reader.read_long()
        _start_param = reader.tgread_string()
        return StartBotRequest(bot=_bot, peer=_peer, start_param=_start_param, random_id=_random_id)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ToggleChatAdminsRequest(TLObject):
    CONSTRUCTOR_ID = 0xec8bd9e1
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id, enabled):
        """
        :param int chat_id:
        :param TLObject enabled:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.chat_id = chat_id
        self.enabled = enabled

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'enabled': self.enabled,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xd9\x8b\xec',
            struct.pack('<i', self.chat_id),
            b'\xb5ur\x99' if self.enabled else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _enabled = reader.tgread_bool()
        return ToggleChatAdminsRequest(chat_id=_chat_id, enabled=_enabled)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ToggleDialogPinRequest(TLObject):
    CONSTRUCTOR_ID = 0x3289be6a
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, pinned=None):
        """
        :param bool | None pinned:
        :param TLObject peer:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.pinned = pinned
        self.peer = get_input_peer(peer)

    def to_dict(self, recursive=True):
        return {
            'pinned': self.pinned,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def __bytes__(self):
        return b''.join((
            b'j\xbe\x892',
            struct.pack('<I', (1 if self.pinned else 0)),
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _pinned = bool(flags & 1)
        _peer = reader.tgread_object()
        return ToggleDialogPinRequest(peer=_peer, pinned=_pinned)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UninstallStickerSetRequest(TLObject):
    CONSTRUCTOR_ID = 0xf96e55de
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, stickerset):
        """
        :param TLObject stickerset:

        :returns Bool: This type has no constructors.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.stickerset = stickerset

    def to_dict(self, recursive=True):
        return {
            'stickerset': (None if self.stickerset is None else self.stickerset.to_dict()) if recursive else self.stickerset,
        }

    def __bytes__(self):
        return b''.join((
            b'\xdeUn\xf9',
            bytes(self.stickerset),
        ))

    @staticmethod
    def from_reader(reader):
        _stickerset = reader.tgread_object()
        return UninstallStickerSetRequest(stickerset=_stickerset)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UploadMediaRequest(TLObject):
    CONSTRUCTOR_ID = 0x519bc2b1
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, peer, media):
        """
        :param TLObject peer:
        :param TLObject media:

        :returns MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()
        self.result = None
        self.content_related = True

        self.peer = get_input_peer(peer)
        self.media = get_input_media(media)

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'media': (None if self.media is None else self.media.to_dict()) if recursive else self.media,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb1\xc2\x9bQ',
            bytes(self.peer),
            bytes(self.media),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _media = reader.tgread_object()
        return UploadMediaRequest(peer=_peer, media=_media)

    def on_response(self, reader):
        self.result = reader.tgread_object()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
