"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from ...tl import types
from . import help, storage, auth, contacts, messages, updates, photos, upload, account, channels, payments, phone
import os
import struct


class AccountDaysTTL(TLObject):
    CONSTRUCTOR_ID = 0xb8d0afdf
    SUBCLASS_OF_ID = 0xbaa39d88

    def __init__(self, days):
        """
        :param int days:

        Constructor for AccountDaysTTL: Instance of AccountDaysTTL.
        """
        super().__init__()

        self.days = days

    def to_dict(self, recursive=True):
        return {
            'days': self.days,
        }

    def __bytes__(self):
        return b''.join((
            b'\xdf\xaf\xd0\xb8',
            struct.pack('<i', self.days),
        ))

    @staticmethod
    def from_reader(reader):
        _days = reader.read_int()
        return AccountDaysTTL(days=_days)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Authorization(TLObject):
    CONSTRUCTOR_ID = 0x7bf2e6f6
    SUBCLASS_OF_ID = 0xc913c01a

    def __init__(self, hash, flags, device_model, platform, system_version, api_id, app_name, app_version, date_created, date_active, ip, country, region):
        """
        :param int hash:
        :param int flags:
        :param str device_model:
        :param str platform:
        :param str system_version:
        :param int api_id:
        :param str app_name:
        :param str app_version:
        :param int date_created:
        :param int date_active:
        :param str ip:
        :param str country:
        :param str region:

        Constructor for Authorization: Instance of Authorization.
        """
        super().__init__()

        self.hash = hash
        self.flags = flags
        self.device_model = device_model
        self.platform = platform
        self.system_version = system_version
        self.api_id = api_id
        self.app_name = app_name
        self.app_version = app_version
        self.date_created = date_created
        self.date_active = date_active
        self.ip = ip
        self.country = country
        self.region = region

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'flags': self.flags,
            'device_model': self.device_model,
            'platform': self.platform,
            'system_version': self.system_version,
            'api_id': self.api_id,
            'app_name': self.app_name,
            'app_version': self.app_version,
            'date_created': self.date_created,
            'date_active': self.date_active,
            'ip': self.ip,
            'country': self.country,
            'region': self.region,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xe6\xf2{',
            struct.pack('<q', self.hash),
            struct.pack('<i', self.flags),
            TLObject.serialize_bytes(self.device_model),
            TLObject.serialize_bytes(self.platform),
            TLObject.serialize_bytes(self.system_version),
            struct.pack('<i', self.api_id),
            TLObject.serialize_bytes(self.app_name),
            TLObject.serialize_bytes(self.app_version),
            struct.pack('<i', self.date_created),
            struct.pack('<i', self.date_active),
            TLObject.serialize_bytes(self.ip),
            TLObject.serialize_bytes(self.country),
            TLObject.serialize_bytes(self.region),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_long()
        _flags = reader.read_int()
        _device_model = reader.tgread_string()
        _platform = reader.tgread_string()
        _system_version = reader.tgread_string()
        _api_id = reader.read_int()
        _app_name = reader.tgread_string()
        _app_version = reader.tgread_string()
        _date_created = reader.read_int()
        _date_active = reader.read_int()
        _ip = reader.tgread_string()
        _country = reader.tgread_string()
        _region = reader.tgread_string()
        return Authorization(hash=_hash, flags=_flags, device_model=_device_model, platform=_platform, system_version=_system_version, api_id=_api_id, app_name=_app_name, app_version=_app_version, date_created=_date_created, date_active=_date_active, ip=_ip, country=_country, region=_region)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BadMsgNotification(TLObject):
    CONSTRUCTOR_ID = 0xa7eff811
    SUBCLASS_OF_ID = 0xcebaa157

    def __init__(self, bad_msg_id, bad_msg_seqno, error_code):
        """
        :param int bad_msg_id:
        :param int bad_msg_seqno:
        :param int error_code:

        Constructor for BadMsgNotification: Instance of either BadMsgNotification, BadServerSalt.
        """
        super().__init__()

        self.bad_msg_id = bad_msg_id
        self.bad_msg_seqno = bad_msg_seqno
        self.error_code = error_code

    def to_dict(self, recursive=True):
        return {
            'bad_msg_id': self.bad_msg_id,
            'bad_msg_seqno': self.bad_msg_seqno,
            'error_code': self.error_code,
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\xf8\xef\xa7',
            struct.pack('<q', self.bad_msg_id),
            struct.pack('<i', self.bad_msg_seqno),
            struct.pack('<i', self.error_code),
        ))

    @staticmethod
    def from_reader(reader):
        _bad_msg_id = reader.read_long()
        _bad_msg_seqno = reader.read_int()
        _error_code = reader.read_int()
        return BadMsgNotification(bad_msg_id=_bad_msg_id, bad_msg_seqno=_bad_msg_seqno, error_code=_error_code)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BadServerSalt(TLObject):
    CONSTRUCTOR_ID = 0xedab447b
    SUBCLASS_OF_ID = 0xcebaa157

    def __init__(self, bad_msg_id, bad_msg_seqno, error_code, new_server_salt):
        """
        :param int bad_msg_id:
        :param int bad_msg_seqno:
        :param int error_code:
        :param int new_server_salt:

        Constructor for BadMsgNotification: Instance of either BadMsgNotification, BadServerSalt.
        """
        super().__init__()

        self.bad_msg_id = bad_msg_id
        self.bad_msg_seqno = bad_msg_seqno
        self.error_code = error_code
        self.new_server_salt = new_server_salt

    def to_dict(self, recursive=True):
        return {
            'bad_msg_id': self.bad_msg_id,
            'bad_msg_seqno': self.bad_msg_seqno,
            'error_code': self.error_code,
            'new_server_salt': self.new_server_salt,
        }

    def __bytes__(self):
        return b''.join((
            b'{D\xab\xed',
            struct.pack('<q', self.bad_msg_id),
            struct.pack('<i', self.bad_msg_seqno),
            struct.pack('<i', self.error_code),
            struct.pack('<q', self.new_server_salt),
        ))

    @staticmethod
    def from_reader(reader):
        _bad_msg_id = reader.read_long()
        _bad_msg_seqno = reader.read_int()
        _error_code = reader.read_int()
        _new_server_salt = reader.read_long()
        return BadServerSalt(bad_msg_id=_bad_msg_id, bad_msg_seqno=_bad_msg_seqno, error_code=_error_code, new_server_salt=_new_server_salt)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotCommand(TLObject):
    CONSTRUCTOR_ID = 0xc27ac8c7
    SUBCLASS_OF_ID = 0xe1e62c2

    def __init__(self, command, description):
        """
        :param str command:
        :param str description:

        Constructor for BotCommand: Instance of BotCommand.
        """
        super().__init__()

        self.command = command
        self.description = description

    def to_dict(self, recursive=True):
        return {
            'command': self.command,
            'description': self.description,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7\xc8z\xc2',
            TLObject.serialize_bytes(self.command),
            TLObject.serialize_bytes(self.description),
        ))

    @staticmethod
    def from_reader(reader):
        _command = reader.tgread_string()
        _description = reader.tgread_string()
        return BotCommand(command=_command, description=_description)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotInfo(TLObject):
    CONSTRUCTOR_ID = 0x98e81d3a
    SUBCLASS_OF_ID = 0xf1f701db

    def __init__(self, user_id, description, commands):
        """
        :param int user_id:
        :param str description:
        :param list[TLObject] commands:

        Constructor for BotInfo: Instance of BotInfo.
        """
        super().__init__()

        self.user_id = user_id
        self.description = description
        self.commands = commands

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'description': self.description,
            'commands': ([] if self.commands is None else [None if x is None else x.to_dict() for x in self.commands]) if recursive else self.commands,
        }

    def __bytes__(self):
        return b''.join((
            b':\x1d\xe8\x98',
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.description),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.commands)),b''.join(bytes(x) for x in self.commands),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _description = reader.tgread_string()
        reader.read_int()
        _commands = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _commands.append(_x)

        return BotInfo(user_id=_user_id, description=_description, commands=_commands)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotInlineMediaResult(TLObject):
    CONSTRUCTOR_ID = 0x17db940b
    SUBCLASS_OF_ID = 0x3832b3d5

    def __init__(self, id, type, send_message, photo=None, document=None, title=None, description=None):
        """
        :param str id:
        :param str type:
        :param TLObject | None photo:
        :param TLObject | None document:
        :param str | None title:
        :param str | None description:
        :param TLObject send_message:

        Constructor for BotInlineResult: Instance of either BotInlineResult, BotInlineMediaResult.
        """
        super().__init__()

        self.id = id
        self.type = type
        self.photo = photo
        self.document = document
        self.title = title
        self.description = description
        self.send_message = send_message

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'type': self.type,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'document': (None if self.document is None else self.document.to_dict()) if recursive else self.document,
            'title': self.title,
            'description': self.description,
            'send_message': (None if self.send_message is None else self.send_message.to_dict()) if recursive else self.send_message,
        }

    def __bytes__(self):
        return b''.join((
            b'\x0b\x94\xdb\x17',
            struct.pack('<I', (1 if self.photo else 0) | (2 if self.document else 0) | (4 if self.title else 0) | (8 if self.description else 0)),
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.type),
            b'' if not self.photo else (bytes(self.photo)),
            b'' if not self.document else (bytes(self.document)),
            b'' if not self.title else (TLObject.serialize_bytes(self.title)),
            b'' if not self.description else (TLObject.serialize_bytes(self.description)),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 2:
            _document = reader.tgread_object()
        else:
            _document = None
        if flags & 4:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 8:
            _description = reader.tgread_string()
        else:
            _description = None
        _send_message = reader.tgread_object()
        return BotInlineMediaResult(id=_id, type=_type, send_message=_send_message, photo=_photo, document=_document, title=_title, description=_description)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotInlineMessageMediaAuto(TLObject):
    CONSTRUCTOR_ID = 0xa74b15b
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, caption, reply_markup=None):
        """
        :param str caption:
        :param TLObject | None reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.caption = caption
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'caption': self.caption,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'[\xb1t\n',
            struct.pack('<I', (4 if self.reply_markup else 0)),
            TLObject.serialize_bytes(self.caption),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _caption = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return BotInlineMessageMediaAuto(caption=_caption, reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotInlineMessageMediaContact(TLObject):
    CONSTRUCTOR_ID = 0x35edb4d4
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, phone_number, first_name, last_name, reply_markup=None):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:
        :param TLObject | None reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd4\xb4\xed5',
            struct.pack('<I', (4 if self.reply_markup else 0)),
            TLObject.serialize_bytes(self.phone_number),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return BotInlineMessageMediaContact(phone_number=_phone_number, first_name=_first_name, last_name=_last_name, reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotInlineMessageMediaGeo(TLObject):
    CONSTRUCTOR_ID = 0x3a8fd8b8
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, geo, reply_markup=None):
        """
        :param TLObject geo:
        :param TLObject | None reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.geo = geo
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'geo': (None if self.geo is None else self.geo.to_dict()) if recursive else self.geo,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb8\xd8\x8f:',
            struct.pack('<I', (4 if self.reply_markup else 0)),
            bytes(self.geo),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _geo = reader.tgread_object()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return BotInlineMessageMediaGeo(geo=_geo, reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotInlineMessageMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0x4366232e
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, geo, title, address, provider, venue_id, reply_markup=None):
        """
        :param TLObject geo:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:
        :param TLObject | None reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.geo = geo
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'geo': (None if self.geo is None else self.geo.to_dict()) if recursive else self.geo,
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'.#fC',
            struct.pack('<I', (4 if self.reply_markup else 0)),
            bytes(self.geo),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.address),
            TLObject.serialize_bytes(self.provider),
            TLObject.serialize_bytes(self.venue_id),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _geo = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return BotInlineMessageMediaVenue(geo=_geo, title=_title, address=_address, provider=_provider, venue_id=_venue_id, reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotInlineMessageText(TLObject):
    CONSTRUCTOR_ID = 0x8c7f65e2
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, message, no_webpage=None, entities=None, reply_markup=None):
        """
        :param bool | None no_webpage:
        :param str message:
        :param list[TLObject] | None entities:
        :param TLObject | None reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.no_webpage = no_webpage
        self.message = message
        self.entities = entities
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'message': self.message,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe2e\x7f\x8c',
            struct.pack('<I', (1 if self.no_webpage else 0) | (2 if self.entities else 0) | (4 if self.reply_markup else 0)),
            TLObject.serialize_bytes(self.message),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 1)
        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return BotInlineMessageText(message=_message, no_webpage=_no_webpage, entities=_entities, reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotInlineResult(TLObject):
    CONSTRUCTOR_ID = 0x9bebaeb9
    SUBCLASS_OF_ID = 0x3832b3d5

    def __init__(self, id, type, send_message, title=None, description=None, url=None, thumb_url=None, content_url=None, content_type=None, w=None, h=None, duration=None):
        """
        :param str id:
        :param str type:
        :param str | None title:
        :param str | None description:
        :param str | None url:
        :param str | None thumb_url:
        :param str | None content_url:
        :param str | None content_type:
        :param int | None w:
        :param int | None h:
        :param int | None duration:
        :param TLObject send_message:

        Constructor for BotInlineResult: Instance of either BotInlineResult, BotInlineMediaResult.
        """
        super().__init__()

        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.url = url
        self.thumb_url = thumb_url
        self.content_url = content_url
        self.content_type = content_type
        self.w = w
        self.h = h
        self.duration = duration
        self.send_message = send_message

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'type': self.type,
            'title': self.title,
            'description': self.description,
            'url': self.url,
            'thumb_url': self.thumb_url,
            'content_url': self.content_url,
            'content_type': self.content_type,
            'w': self.w,
            'h': self.h,
            'duration': self.duration,
            'send_message': (None if self.send_message is None else self.send_message.to_dict()) if recursive else self.send_message,
        }

    def __bytes__(self):
        assert (self.content_url is None and self.content_type is None) or (self.content_url is not None and self.content_type is not None), 'content_url, content_type parameters must all be None or neither be None'
        assert (self.w is None and self.h is None) or (self.w is not None and self.h is not None), 'w, h parameters must all be None or neither be None'
        return b''.join((
            b'\xb9\xae\xeb\x9b',
            struct.pack('<I', (2 if self.title else 0) | (4 if self.description else 0) | (8 if self.url else 0) | (16 if self.thumb_url else 0) | (32 if self.content_url else 0) | (32 if self.content_type else 0) | (64 if self.w else 0) | (64 if self.h else 0) | (128 if self.duration else 0)),
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.type),
            b'' if not self.title else (TLObject.serialize_bytes(self.title)),
            b'' if not self.description else (TLObject.serialize_bytes(self.description)),
            b'' if not self.url else (TLObject.serialize_bytes(self.url)),
            b'' if not self.thumb_url else (TLObject.serialize_bytes(self.thumb_url)),
            b'' if not self.content_url else (TLObject.serialize_bytes(self.content_url)),
            b'' if not self.content_type else (TLObject.serialize_bytes(self.content_type)),
            b'' if not self.w else (struct.pack('<i', self.w)),
            b'' if not self.h else (struct.pack('<i', self.h)),
            b'' if not self.duration else (struct.pack('<i', self.duration)),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 2:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 4:
            _description = reader.tgread_string()
        else:
            _description = None
        if flags & 8:
            _url = reader.tgread_string()
        else:
            _url = None
        if flags & 16:
            _thumb_url = reader.tgread_string()
        else:
            _thumb_url = None
        if flags & 32:
            _content_url = reader.tgread_string()
        else:
            _content_url = None
        if flags & 32:
            _content_type = reader.tgread_string()
        else:
            _content_type = None
        if flags & 64:
            _w = reader.read_int()
        else:
            _w = None
        if flags & 64:
            _h = reader.read_int()
        else:
            _h = None
        if flags & 128:
            _duration = reader.read_int()
        else:
            _duration = None
        _send_message = reader.tgread_object()
        return BotInlineResult(id=_id, type=_type, send_message=_send_message, title=_title, description=_description, url=_url, thumb_url=_thumb_url, content_url=_content_url, content_type=_content_type, w=_w, h=_h, duration=_duration)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class CdnConfig(TLObject):
    CONSTRUCTOR_ID = 0x5725e40a
    SUBCLASS_OF_ID = 0xecda397c

    def __init__(self, public_keys):
        """
        :param list[TLObject] public_keys:

        Constructor for CdnConfig: Instance of CdnConfig.
        """
        super().__init__()

        self.public_keys = public_keys

    def to_dict(self, recursive=True):
        return {
            'public_keys': ([] if self.public_keys is None else [None if x is None else x.to_dict() for x in self.public_keys]) if recursive else self.public_keys,
        }

    def __bytes__(self):
        return b''.join((
            b'\n\xe4%W',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.public_keys)),b''.join(bytes(x) for x in self.public_keys),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _public_keys = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _public_keys.append(_x)

        return CdnConfig(public_keys=_public_keys)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class CdnFileHash(TLObject):
    CONSTRUCTOR_ID = 0x77eec38f
    SUBCLASS_OF_ID = 0xe776d7e4

    def __init__(self, offset, limit, hash):
        """
        :param int offset:
        :param int limit:
        :param bytes hash:

        Constructor for CdnFileHash: Instance of CdnFileHash.
        """
        super().__init__()

        self.offset = offset
        self.limit = limit
        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'limit': self.limit,
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\x8f\xc3\xeew',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.limit),
            TLObject.serialize_bytes(self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _limit = reader.read_int()
        _hash = reader.tgread_bytes()
        return CdnFileHash(offset=_offset, limit=_limit, hash=_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class CdnPublicKey(TLObject):
    CONSTRUCTOR_ID = 0xc982eaba
    SUBCLASS_OF_ID = 0x16db47f3

    def __init__(self, dc_id, public_key):
        """
        :param int dc_id:
        :param str public_key:

        Constructor for CdnPublicKey: Instance of CdnPublicKey.
        """
        super().__init__()

        self.dc_id = dc_id
        self.public_key = public_key

    def to_dict(self, recursive=True):
        return {
            'dc_id': self.dc_id,
            'public_key': self.public_key,
        }

    def __bytes__(self):
        return b''.join((
            b'\xba\xea\x82\xc9',
            struct.pack('<i', self.dc_id),
            TLObject.serialize_bytes(self.public_key),
        ))

    @staticmethod
    def from_reader(reader):
        _dc_id = reader.read_int()
        _public_key = reader.tgread_string()
        return CdnPublicKey(dc_id=_dc_id, public_key=_public_key)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Channel(TLObject):
    CONSTRUCTOR_ID = 0xcb44b1c
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, title, photo, date, version, creator=None, left=None, editor=None, broadcast=None, verified=None, megagroup=None, restricted=None, democracy=None, signatures=None, min=None, access_hash=None, username=None, restriction_reason=None, admin_rights=None, banned_rights=None):
        """
        :param bool | None creator:
        :param bool | None left:
        :param bool | None editor:
        :param bool | None broadcast:
        :param bool | None verified:
        :param bool | None megagroup:
        :param bool | None restricted:
        :param bool | None democracy:
        :param bool | None signatures:
        :param bool | None min:
        :param int id:
        :param int | None access_hash:
        :param str title:
        :param str | None username:
        :param TLObject photo:
        :param datetime.datetime | None date:
        :param int version:
        :param str | None restriction_reason:
        :param TLObject | None admin_rights:
        :param TLObject | None banned_rights:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.creator = creator
        self.left = left
        self.editor = editor
        self.broadcast = broadcast
        self.verified = verified
        self.megagroup = megagroup
        self.restricted = restricted
        self.democracy = democracy
        self.signatures = signatures
        self.min = min
        self.id = id
        self.access_hash = access_hash
        self.title = title
        self.username = username
        self.photo = photo
        self.date = date
        self.version = version
        self.restriction_reason = restriction_reason
        self.admin_rights = admin_rights
        self.banned_rights = banned_rights

    def to_dict(self, recursive=True):
        return {
            'creator': self.creator,
            'left': self.left,
            'editor': self.editor,
            'broadcast': self.broadcast,
            'verified': self.verified,
            'megagroup': self.megagroup,
            'restricted': self.restricted,
            'democracy': self.democracy,
            'signatures': self.signatures,
            'min': self.min,
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'username': self.username,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'date': self.date,
            'version': self.version,
            'restriction_reason': self.restriction_reason,
            'admin_rights': (None if self.admin_rights is None else self.admin_rights.to_dict()) if recursive else self.admin_rights,
            'banned_rights': (None if self.banned_rights is None else self.banned_rights.to_dict()) if recursive else self.banned_rights,
        }

    def __bytes__(self):
        assert (self.restricted is None and self.restriction_reason is None) or (self.restricted is not None and self.restriction_reason is not None), 'restricted, restriction_reason parameters must all be None or neither be None'
        return b''.join((
            b'\x1cK\xb4\x0c',
            struct.pack('<I', (1 if self.creator else 0) | (4 if self.left else 0) | (8 if self.editor else 0) | (32 if self.broadcast else 0) | (128 if self.verified else 0) | (256 if self.megagroup else 0) | (512 if self.restricted else 0) | (1024 if self.democracy else 0) | (2048 if self.signatures else 0) | (4096 if self.min else 0) | (8192 if self.access_hash else 0) | (64 if self.username else 0) | (512 if self.restriction_reason else 0) | (16384 if self.admin_rights else 0) | (32768 if self.banned_rights else 0)),
            struct.pack('<i', self.id),
            b'' if not self.access_hash else (struct.pack('<q', self.access_hash)),
            TLObject.serialize_bytes(self.title),
            b'' if not self.username else (TLObject.serialize_bytes(self.username)),
            bytes(self.photo),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.version),
            b'' if not self.restriction_reason else (TLObject.serialize_bytes(self.restriction_reason)),
            b'' if not self.admin_rights else (bytes(self.admin_rights)),
            b'' if not self.banned_rights else (bytes(self.banned_rights)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _creator = bool(flags & 1)
        _left = bool(flags & 4)
        _editor = bool(flags & 8)
        _broadcast = bool(flags & 32)
        _verified = bool(flags & 128)
        _megagroup = bool(flags & 256)
        _restricted = bool(flags & 512)
        _democracy = bool(flags & 1024)
        _signatures = bool(flags & 2048)
        _min = bool(flags & 4096)
        _id = reader.read_int()
        if flags & 8192:
            _access_hash = reader.read_long()
        else:
            _access_hash = None
        _title = reader.tgread_string()
        if flags & 64:
            _username = reader.tgread_string()
        else:
            _username = None
        _photo = reader.tgread_object()
        _date = reader.tgread_date()
        _version = reader.read_int()
        if flags & 512:
            _restriction_reason = reader.tgread_string()
        else:
            _restriction_reason = None
        if flags & 16384:
            _admin_rights = reader.tgread_object()
        else:
            _admin_rights = None
        if flags & 32768:
            _banned_rights = reader.tgread_object()
        else:
            _banned_rights = None
        return Channel(id=_id, title=_title, photo=_photo, date=_date, version=_version, creator=_creator, left=_left, editor=_editor, broadcast=_broadcast, verified=_verified, megagroup=_megagroup, restricted=_restricted, democracy=_democracy, signatures=_signatures, min=_min, access_hash=_access_hash, username=_username, restriction_reason=_restriction_reason, admin_rights=_admin_rights, banned_rights=_banned_rights)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEvent(TLObject):
    CONSTRUCTOR_ID = 0x3b5a3e40
    SUBCLASS_OF_ID = 0x408f0999

    def __init__(self, id, date, user_id, action):
        """
        :param int id:
        :param datetime.datetime | None date:
        :param int user_id:
        :param TLObject action:

        Constructor for ChannelAdminLogEvent: Instance of ChannelAdminLogEvent.
        """
        super().__init__()

        self.id = id
        self.date = date
        self.user_id = user_id
        self.action = action

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'date': self.date,
            'user_id': self.user_id,
            'action': (None if self.action is None else self.action.to_dict()) if recursive else self.action,
        }

    def __bytes__(self):
        return b''.join((
            b'@>Z;',
            struct.pack('<q', self.id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.user_id),
            bytes(self.action),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _date = reader.tgread_date()
        _user_id = reader.read_int()
        _action = reader.tgread_object()
        return ChannelAdminLogEvent(id=_id, date=_date, user_id=_user_id, action=_action)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionChangeAbout(TLObject):
    CONSTRUCTOR_ID = 0x55188a2e
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param str prev_value:
        :param str new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_value = prev_value
        self.new_value = new_value

    def to_dict(self, recursive=True):
        return {
            'prev_value': self.prev_value,
            'new_value': self.new_value,
        }

    def __bytes__(self):
        return b''.join((
            b'.\x8a\x18U',
            TLObject.serialize_bytes(self.prev_value),
            TLObject.serialize_bytes(self.new_value),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_value = reader.tgread_string()
        _new_value = reader.tgread_string()
        return ChannelAdminLogEventActionChangeAbout(prev_value=_prev_value, new_value=_new_value)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionChangePhoto(TLObject):
    CONSTRUCTOR_ID = 0xb82f55c3
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_photo, new_photo):
        """
        :param TLObject prev_photo:
        :param TLObject new_photo:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_photo = prev_photo
        self.new_photo = new_photo

    def to_dict(self, recursive=True):
        return {
            'prev_photo': (None if self.prev_photo is None else self.prev_photo.to_dict()) if recursive else self.prev_photo,
            'new_photo': (None if self.new_photo is None else self.new_photo.to_dict()) if recursive else self.new_photo,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3U/\xb8',
            bytes(self.prev_photo),
            bytes(self.new_photo),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_photo = reader.tgread_object()
        _new_photo = reader.tgread_object()
        return ChannelAdminLogEventActionChangePhoto(prev_photo=_prev_photo, new_photo=_new_photo)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionChangeStickerSet(TLObject):
    CONSTRUCTOR_ID = 0xb1c3caa7
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_stickerset, new_stickerset):
        """
        :param TLObject prev_stickerset:
        :param TLObject new_stickerset:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_stickerset = prev_stickerset
        self.new_stickerset = new_stickerset

    def to_dict(self, recursive=True):
        return {
            'prev_stickerset': (None if self.prev_stickerset is None else self.prev_stickerset.to_dict()) if recursive else self.prev_stickerset,
            'new_stickerset': (None if self.new_stickerset is None else self.new_stickerset.to_dict()) if recursive else self.new_stickerset,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa7\xca\xc3\xb1',
            bytes(self.prev_stickerset),
            bytes(self.new_stickerset),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_stickerset = reader.tgread_object()
        _new_stickerset = reader.tgread_object()
        return ChannelAdminLogEventActionChangeStickerSet(prev_stickerset=_prev_stickerset, new_stickerset=_new_stickerset)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionChangeTitle(TLObject):
    CONSTRUCTOR_ID = 0xe6dfb825
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param str prev_value:
        :param str new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_value = prev_value
        self.new_value = new_value

    def to_dict(self, recursive=True):
        return {
            'prev_value': self.prev_value,
            'new_value': self.new_value,
        }

    def __bytes__(self):
        return b''.join((
            b'%\xb8\xdf\xe6',
            TLObject.serialize_bytes(self.prev_value),
            TLObject.serialize_bytes(self.new_value),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_value = reader.tgread_string()
        _new_value = reader.tgread_string()
        return ChannelAdminLogEventActionChangeTitle(prev_value=_prev_value, new_value=_new_value)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionChangeUsername(TLObject):
    CONSTRUCTOR_ID = 0x6a4afc38
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param str prev_value:
        :param str new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_value = prev_value
        self.new_value = new_value

    def to_dict(self, recursive=True):
        return {
            'prev_value': self.prev_value,
            'new_value': self.new_value,
        }

    def __bytes__(self):
        return b''.join((
            b'8\xfcJj',
            TLObject.serialize_bytes(self.prev_value),
            TLObject.serialize_bytes(self.new_value),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_value = reader.tgread_string()
        _new_value = reader.tgread_string()
        return ChannelAdminLogEventActionChangeUsername(prev_value=_prev_value, new_value=_new_value)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionDeleteMessage(TLObject):
    CONSTRUCTOR_ID = 0x42e047bb
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, message):
        """
        :param TLObject message:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.message = message

    def to_dict(self, recursive=True):
        return {
            'message': (None if self.message is None else self.message.to_dict()) if recursive else self.message,
        }

    def __bytes__(self):
        return b''.join((
            b'\xbbG\xe0B',
            bytes(self.message),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        return ChannelAdminLogEventActionDeleteMessage(message=_message)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionEditMessage(TLObject):
    CONSTRUCTOR_ID = 0x709b2405
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_message, new_message):
        """
        :param TLObject prev_message:
        :param TLObject new_message:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_message = prev_message
        self.new_message = new_message

    def to_dict(self, recursive=True):
        return {
            'prev_message': (None if self.prev_message is None else self.prev_message.to_dict()) if recursive else self.prev_message,
            'new_message': (None if self.new_message is None else self.new_message.to_dict()) if recursive else self.new_message,
        }

    def __bytes__(self):
        return b''.join((
            b'\x05$\x9bp',
            bytes(self.prev_message),
            bytes(self.new_message),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_message = reader.tgread_object()
        _new_message = reader.tgread_object()
        return ChannelAdminLogEventActionEditMessage(prev_message=_prev_message, new_message=_new_message)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionParticipantInvite(TLObject):
    CONSTRUCTOR_ID = 0xe31c34d8
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, participant):
        """
        :param TLObject participant:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.participant = participant

    def to_dict(self, recursive=True):
        return {
            'participant': (None if self.participant is None else self.participant.to_dict()) if recursive else self.participant,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd84\x1c\xe3',
            bytes(self.participant),
        ))

    @staticmethod
    def from_reader(reader):
        _participant = reader.tgread_object()
        return ChannelAdminLogEventActionParticipantInvite(participant=_participant)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionParticipantJoin(TLObject):
    CONSTRUCTOR_ID = 0x183040d3
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xd3@0\x18',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelAdminLogEventActionParticipantJoin()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionParticipantLeave(TLObject):
    CONSTRUCTOR_ID = 0xf89777f2
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xf2w\x97\xf8',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelAdminLogEventActionParticipantLeave()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionParticipantToggleAdmin(TLObject):
    CONSTRUCTOR_ID = 0xd5676710
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_participant, new_participant):
        """
        :param TLObject prev_participant:
        :param TLObject new_participant:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_participant = prev_participant
        self.new_participant = new_participant

    def to_dict(self, recursive=True):
        return {
            'prev_participant': (None if self.prev_participant is None else self.prev_participant.to_dict()) if recursive else self.prev_participant,
            'new_participant': (None if self.new_participant is None else self.new_participant.to_dict()) if recursive else self.new_participant,
        }

    def __bytes__(self):
        return b''.join((
            b'\x10gg\xd5',
            bytes(self.prev_participant),
            bytes(self.new_participant),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_participant = reader.tgread_object()
        _new_participant = reader.tgread_object()
        return ChannelAdminLogEventActionParticipantToggleAdmin(prev_participant=_prev_participant, new_participant=_new_participant)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionParticipantToggleBan(TLObject):
    CONSTRUCTOR_ID = 0xe6d83d7e
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_participant, new_participant):
        """
        :param TLObject prev_participant:
        :param TLObject new_participant:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.prev_participant = prev_participant
        self.new_participant = new_participant

    def to_dict(self, recursive=True):
        return {
            'prev_participant': (None if self.prev_participant is None else self.prev_participant.to_dict()) if recursive else self.prev_participant,
            'new_participant': (None if self.new_participant is None else self.new_participant.to_dict()) if recursive else self.new_participant,
        }

    def __bytes__(self):
        return b''.join((
            b'~=\xd8\xe6',
            bytes(self.prev_participant),
            bytes(self.new_participant),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_participant = reader.tgread_object()
        _new_participant = reader.tgread_object()
        return ChannelAdminLogEventActionParticipantToggleBan(prev_participant=_prev_participant, new_participant=_new_participant)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionToggleInvites(TLObject):
    CONSTRUCTOR_ID = 0x1b7907ae
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, new_value):
        """
        :param TLObject new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.new_value = new_value

    def to_dict(self, recursive=True):
        return {
            'new_value': self.new_value,
        }

    def __bytes__(self):
        return b''.join((
            b'\xae\x07y\x1b',
            b'\xb5ur\x99' if self.new_value else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _new_value = reader.tgread_bool()
        return ChannelAdminLogEventActionToggleInvites(new_value=_new_value)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionToggleSignatures(TLObject):
    CONSTRUCTOR_ID = 0x26ae0971
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, new_value):
        """
        :param TLObject new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.new_value = new_value

    def to_dict(self, recursive=True):
        return {
            'new_value': self.new_value,
        }

    def __bytes__(self):
        return b''.join((
            b'q\t\xae&',
            b'\xb5ur\x99' if self.new_value else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _new_value = reader.tgread_bool()
        return ChannelAdminLogEventActionToggleSignatures(new_value=_new_value)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventActionUpdatePinned(TLObject):
    CONSTRUCTOR_ID = 0xe9e82c18
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, message):
        """
        :param TLObject message:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet.
        """
        super().__init__()

        self.message = message

    def to_dict(self, recursive=True):
        return {
            'message': (None if self.message is None else self.message.to_dict()) if recursive else self.message,
        }

    def __bytes__(self):
        return b''.join((
            b'\x18,\xe8\xe9',
            bytes(self.message),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        return ChannelAdminLogEventActionUpdatePinned(message=_message)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminLogEventsFilter(TLObject):
    CONSTRUCTOR_ID = 0xea107ae4
    SUBCLASS_OF_ID = 0x7cbbf319

    def __init__(self, join=None, leave=None, invite=None, ban=None, unban=None, kick=None, unkick=None, promote=None, demote=None, info=None, settings=None, pinned=None, edit=None, delete=None):
        """
        :param bool | None join:
        :param bool | None leave:
        :param bool | None invite:
        :param bool | None ban:
        :param bool | None unban:
        :param bool | None kick:
        :param bool | None unkick:
        :param bool | None promote:
        :param bool | None demote:
        :param bool | None info:
        :param bool | None settings:
        :param bool | None pinned:
        :param bool | None edit:
        :param bool | None delete:

        Constructor for ChannelAdminLogEventsFilter: Instance of ChannelAdminLogEventsFilter.
        """
        super().__init__()

        self.join = join
        self.leave = leave
        self.invite = invite
        self.ban = ban
        self.unban = unban
        self.kick = kick
        self.unkick = unkick
        self.promote = promote
        self.demote = demote
        self.info = info
        self.settings = settings
        self.pinned = pinned
        self.edit = edit
        self.delete = delete

    def to_dict(self, recursive=True):
        return {
            'join': self.join,
            'leave': self.leave,
            'invite': self.invite,
            'ban': self.ban,
            'unban': self.unban,
            'kick': self.kick,
            'unkick': self.unkick,
            'promote': self.promote,
            'demote': self.demote,
            'info': self.info,
            'settings': self.settings,
            'pinned': self.pinned,
            'edit': self.edit,
            'delete': self.delete,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4z\x10\xea',
            struct.pack('<I', (1 if self.join else 0) | (2 if self.leave else 0) | (4 if self.invite else 0) | (8 if self.ban else 0) | (16 if self.unban else 0) | (32 if self.kick else 0) | (64 if self.unkick else 0) | (128 if self.promote else 0) | (256 if self.demote else 0) | (512 if self.info else 0) | (1024 if self.settings else 0) | (2048 if self.pinned else 0) | (4096 if self.edit else 0) | (8192 if self.delete else 0)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _join = bool(flags & 1)
        _leave = bool(flags & 2)
        _invite = bool(flags & 4)
        _ban = bool(flags & 8)
        _unban = bool(flags & 16)
        _kick = bool(flags & 32)
        _unkick = bool(flags & 64)
        _promote = bool(flags & 128)
        _demote = bool(flags & 256)
        _info = bool(flags & 512)
        _settings = bool(flags & 1024)
        _pinned = bool(flags & 2048)
        _edit = bool(flags & 4096)
        _delete = bool(flags & 8192)
        return ChannelAdminLogEventsFilter(join=_join, leave=_leave, invite=_invite, ban=_ban, unban=_unban, kick=_kick, unkick=_unkick, promote=_promote, demote=_demote, info=_info, settings=_settings, pinned=_pinned, edit=_edit, delete=_delete)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelAdminRights(TLObject):
    CONSTRUCTOR_ID = 0x5d7ceba5
    SUBCLASS_OF_ID = 0x2286545a

    def __init__(self, change_info=None, post_messages=None, edit_messages=None, delete_messages=None, ban_users=None, invite_users=None, invite_link=None, pin_messages=None, add_admins=None):
        """
        :param bool | None change_info:
        :param bool | None post_messages:
        :param bool | None edit_messages:
        :param bool | None delete_messages:
        :param bool | None ban_users:
        :param bool | None invite_users:
        :param bool | None invite_link:
        :param bool | None pin_messages:
        :param bool | None add_admins:

        Constructor for ChannelAdminRights: Instance of ChannelAdminRights.
        """
        super().__init__()

        self.change_info = change_info
        self.post_messages = post_messages
        self.edit_messages = edit_messages
        self.delete_messages = delete_messages
        self.ban_users = ban_users
        self.invite_users = invite_users
        self.invite_link = invite_link
        self.pin_messages = pin_messages
        self.add_admins = add_admins

    def to_dict(self, recursive=True):
        return {
            'change_info': self.change_info,
            'post_messages': self.post_messages,
            'edit_messages': self.edit_messages,
            'delete_messages': self.delete_messages,
            'ban_users': self.ban_users,
            'invite_users': self.invite_users,
            'invite_link': self.invite_link,
            'pin_messages': self.pin_messages,
            'add_admins': self.add_admins,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa5\xeb|]',
            struct.pack('<I', (1 if self.change_info else 0) | (2 if self.post_messages else 0) | (4 if self.edit_messages else 0) | (8 if self.delete_messages else 0) | (16 if self.ban_users else 0) | (32 if self.invite_users else 0) | (64 if self.invite_link else 0) | (128 if self.pin_messages else 0) | (512 if self.add_admins else 0)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _change_info = bool(flags & 1)
        _post_messages = bool(flags & 2)
        _edit_messages = bool(flags & 4)
        _delete_messages = bool(flags & 8)
        _ban_users = bool(flags & 16)
        _invite_users = bool(flags & 32)
        _invite_link = bool(flags & 64)
        _pin_messages = bool(flags & 128)
        _add_admins = bool(flags & 512)
        return ChannelAdminRights(change_info=_change_info, post_messages=_post_messages, edit_messages=_edit_messages, delete_messages=_delete_messages, ban_users=_ban_users, invite_users=_invite_users, invite_link=_invite_link, pin_messages=_pin_messages, add_admins=_add_admins)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelBannedRights(TLObject):
    CONSTRUCTOR_ID = 0x58cf4249
    SUBCLASS_OF_ID = 0x5c474079

    def __init__(self, until_date, view_messages=None, send_messages=None, send_media=None, send_stickers=None, send_gifs=None, send_games=None, send_inline=None, embed_links=None):
        """
        :param bool | None view_messages:
        :param bool | None send_messages:
        :param bool | None send_media:
        :param bool | None send_stickers:
        :param bool | None send_gifs:
        :param bool | None send_games:
        :param bool | None send_inline:
        :param bool | None embed_links:
        :param datetime.datetime | None until_date:

        Constructor for ChannelBannedRights: Instance of ChannelBannedRights.
        """
        super().__init__()

        self.view_messages = view_messages
        self.send_messages = send_messages
        self.send_media = send_media
        self.send_stickers = send_stickers
        self.send_gifs = send_gifs
        self.send_games = send_games
        self.send_inline = send_inline
        self.embed_links = embed_links
        self.until_date = until_date

    def to_dict(self, recursive=True):
        return {
            'view_messages': self.view_messages,
            'send_messages': self.send_messages,
            'send_media': self.send_media,
            'send_stickers': self.send_stickers,
            'send_gifs': self.send_gifs,
            'send_games': self.send_games,
            'send_inline': self.send_inline,
            'embed_links': self.embed_links,
            'until_date': self.until_date,
        }

    def __bytes__(self):
        return b''.join((
            b'IB\xcfX',
            struct.pack('<I', (1 if self.view_messages else 0) | (2 if self.send_messages else 0) | (4 if self.send_media else 0) | (8 if self.send_stickers else 0) | (16 if self.send_gifs else 0) | (32 if self.send_games else 0) | (64 if self.send_inline else 0) | (128 if self.embed_links else 0)),
            b'\0\0\0\0' if self.until_date is None else struct.pack('<I', int(self.until_date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _view_messages = bool(flags & 1)
        _send_messages = bool(flags & 2)
        _send_media = bool(flags & 4)
        _send_stickers = bool(flags & 8)
        _send_gifs = bool(flags & 16)
        _send_games = bool(flags & 32)
        _send_inline = bool(flags & 64)
        _embed_links = bool(flags & 128)
        _until_date = reader.tgread_date()
        return ChannelBannedRights(until_date=_until_date, view_messages=_view_messages, send_messages=_send_messages, send_media=_send_media, send_stickers=_send_stickers, send_gifs=_send_gifs, send_games=_send_games, send_inline=_send_inline, embed_links=_embed_links)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelForbidden(TLObject):
    CONSTRUCTOR_ID = 0x289da732
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, access_hash, title, broadcast=None, megagroup=None, until_date=None):
        """
        :param bool | None broadcast:
        :param bool | None megagroup:
        :param int id:
        :param int access_hash:
        :param str title:
        :param datetime.datetime | None until_date:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.broadcast = broadcast
        self.megagroup = megagroup
        self.id = id
        self.access_hash = access_hash
        self.title = title
        self.until_date = until_date

    def to_dict(self, recursive=True):
        return {
            'broadcast': self.broadcast,
            'megagroup': self.megagroup,
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'until_date': self.until_date,
        }

    def __bytes__(self):
        return b''.join((
            b'2\xa7\x9d(',
            struct.pack('<I', (32 if self.broadcast else 0) | (256 if self.megagroup else 0) | (65536 if self.until_date else 0)),
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_bytes(self.title),
            b'' if not self.until_date else (b'\0\0\0\0' if self.until_date is None else struct.pack('<I', int(self.until_date.timestamp()))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _broadcast = bool(flags & 32)
        _megagroup = bool(flags & 256)
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _title = reader.tgread_string()
        if flags & 65536:
            _until_date = reader.tgread_date()
        else:
            _until_date = None
        return ChannelForbidden(id=_id, access_hash=_access_hash, title=_title, broadcast=_broadcast, megagroup=_megagroup, until_date=_until_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelFull(TLObject):
    CONSTRUCTOR_ID = 0x17f45fcf
    SUBCLASS_OF_ID = 0xd49a2697

    def __init__(self, id, about, read_inbox_max_id, read_outbox_max_id, unread_count, chat_photo, notify_settings, exported_invite, bot_info, can_view_participants=None, can_set_username=None, can_set_stickers=None, participants_count=None, admins_count=None, kicked_count=None, banned_count=None, migrated_from_chat_id=None, migrated_from_max_id=None, pinned_msg_id=None, stickerset=None):
        """
        :param bool | None can_view_participants:
        :param bool | None can_set_username:
        :param bool | None can_set_stickers:
        :param int id:
        :param str about:
        :param int | None participants_count:
        :param int | None admins_count:
        :param int | None kicked_count:
        :param int | None banned_count:
        :param int read_inbox_max_id:
        :param int read_outbox_max_id:
        :param int unread_count:
        :param TLObject chat_photo:
        :param TLObject notify_settings:
        :param TLObject exported_invite:
        :param list[TLObject] bot_info:
        :param int | None migrated_from_chat_id:
        :param int | None migrated_from_max_id:
        :param int | None pinned_msg_id:
        :param TLObject | None stickerset:

        Constructor for ChatFull: Instance of either ChatFull, ChannelFull.
        """
        super().__init__()

        self.can_view_participants = can_view_participants
        self.can_set_username = can_set_username
        self.can_set_stickers = can_set_stickers
        self.id = id
        self.about = about
        self.participants_count = participants_count
        self.admins_count = admins_count
        self.kicked_count = kicked_count
        self.banned_count = banned_count
        self.read_inbox_max_id = read_inbox_max_id
        self.read_outbox_max_id = read_outbox_max_id
        self.unread_count = unread_count
        self.chat_photo = chat_photo
        self.notify_settings = notify_settings
        self.exported_invite = exported_invite
        self.bot_info = bot_info
        self.migrated_from_chat_id = migrated_from_chat_id
        self.migrated_from_max_id = migrated_from_max_id
        self.pinned_msg_id = pinned_msg_id
        self.stickerset = stickerset

    def to_dict(self, recursive=True):
        return {
            'can_view_participants': self.can_view_participants,
            'can_set_username': self.can_set_username,
            'can_set_stickers': self.can_set_stickers,
            'id': self.id,
            'about': self.about,
            'participants_count': self.participants_count,
            'admins_count': self.admins_count,
            'kicked_count': self.kicked_count,
            'banned_count': self.banned_count,
            'read_inbox_max_id': self.read_inbox_max_id,
            'read_outbox_max_id': self.read_outbox_max_id,
            'unread_count': self.unread_count,
            'chat_photo': (None if self.chat_photo is None else self.chat_photo.to_dict()) if recursive else self.chat_photo,
            'notify_settings': (None if self.notify_settings is None else self.notify_settings.to_dict()) if recursive else self.notify_settings,
            'exported_invite': (None if self.exported_invite is None else self.exported_invite.to_dict()) if recursive else self.exported_invite,
            'bot_info': ([] if self.bot_info is None else [None if x is None else x.to_dict() for x in self.bot_info]) if recursive else self.bot_info,
            'migrated_from_chat_id': self.migrated_from_chat_id,
            'migrated_from_max_id': self.migrated_from_max_id,
            'pinned_msg_id': self.pinned_msg_id,
            'stickerset': (None if self.stickerset is None else self.stickerset.to_dict()) if recursive else self.stickerset,
        }

    def __bytes__(self):
        assert (self.kicked_count is None and self.banned_count is None) or (self.kicked_count is not None and self.banned_count is not None), 'kicked_count, banned_count parameters must all be None or neither be None'
        assert (self.migrated_from_chat_id is None and self.migrated_from_max_id is None) or (self.migrated_from_chat_id is not None and self.migrated_from_max_id is not None), 'migrated_from_chat_id, migrated_from_max_id parameters must all be None or neither be None'
        return b''.join((
            b'\xcf_\xf4\x17',
            struct.pack('<I', (8 if self.can_view_participants else 0) | (64 if self.can_set_username else 0) | (128 if self.can_set_stickers else 0) | (1 if self.participants_count else 0) | (2 if self.admins_count else 0) | (4 if self.kicked_count else 0) | (4 if self.banned_count else 0) | (16 if self.migrated_from_chat_id else 0) | (16 if self.migrated_from_max_id else 0) | (32 if self.pinned_msg_id else 0) | (256 if self.stickerset else 0)),
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.about),
            b'' if not self.participants_count else (struct.pack('<i', self.participants_count)),
            b'' if not self.admins_count else (struct.pack('<i', self.admins_count)),
            b'' if not self.kicked_count else (struct.pack('<i', self.kicked_count)),
            b'' if not self.banned_count else (struct.pack('<i', self.banned_count)),
            struct.pack('<i', self.read_inbox_max_id),
            struct.pack('<i', self.read_outbox_max_id),
            struct.pack('<i', self.unread_count),
            bytes(self.chat_photo),
            bytes(self.notify_settings),
            bytes(self.exported_invite),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.bot_info)),b''.join(bytes(x) for x in self.bot_info),
            b'' if not self.migrated_from_chat_id else (struct.pack('<i', self.migrated_from_chat_id)),
            b'' if not self.migrated_from_max_id else (struct.pack('<i', self.migrated_from_max_id)),
            b'' if not self.pinned_msg_id else (struct.pack('<i', self.pinned_msg_id)),
            b'' if not self.stickerset else (bytes(self.stickerset)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _can_view_participants = bool(flags & 8)
        _can_set_username = bool(flags & 64)
        _can_set_stickers = bool(flags & 128)
        _id = reader.read_int()
        _about = reader.tgread_string()
        if flags & 1:
            _participants_count = reader.read_int()
        else:
            _participants_count = None
        if flags & 2:
            _admins_count = reader.read_int()
        else:
            _admins_count = None
        if flags & 4:
            _kicked_count = reader.read_int()
        else:
            _kicked_count = None
        if flags & 4:
            _banned_count = reader.read_int()
        else:
            _banned_count = None
        _read_inbox_max_id = reader.read_int()
        _read_outbox_max_id = reader.read_int()
        _unread_count = reader.read_int()
        _chat_photo = reader.tgread_object()
        _notify_settings = reader.tgread_object()
        _exported_invite = reader.tgread_object()
        reader.read_int()
        _bot_info = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _bot_info.append(_x)

        if flags & 16:
            _migrated_from_chat_id = reader.read_int()
        else:
            _migrated_from_chat_id = None
        if flags & 16:
            _migrated_from_max_id = reader.read_int()
        else:
            _migrated_from_max_id = None
        if flags & 32:
            _pinned_msg_id = reader.read_int()
        else:
            _pinned_msg_id = None
        if flags & 256:
            _stickerset = reader.tgread_object()
        else:
            _stickerset = None
        return ChannelFull(id=_id, about=_about, read_inbox_max_id=_read_inbox_max_id, read_outbox_max_id=_read_outbox_max_id, unread_count=_unread_count, chat_photo=_chat_photo, notify_settings=_notify_settings, exported_invite=_exported_invite, bot_info=_bot_info, can_view_participants=_can_view_participants, can_set_username=_can_set_username, can_set_stickers=_can_set_stickers, participants_count=_participants_count, admins_count=_admins_count, kicked_count=_kicked_count, banned_count=_banned_count, migrated_from_chat_id=_migrated_from_chat_id, migrated_from_max_id=_migrated_from_max_id, pinned_msg_id=_pinned_msg_id, stickerset=_stickerset)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelMessagesFilter(TLObject):
    CONSTRUCTOR_ID = 0xcd77d957
    SUBCLASS_OF_ID = 0x13336a56

    def __init__(self, ranges, exclude_new_messages=None):
        """
        :param bool | None exclude_new_messages:
        :param list[TLObject] ranges:

        Constructor for ChannelMessagesFilter: Instance of either ChannelMessagesFilterEmpty, ChannelMessagesFilter.
        """
        super().__init__()

        self.exclude_new_messages = exclude_new_messages
        self.ranges = ranges

    def to_dict(self, recursive=True):
        return {
            'exclude_new_messages': self.exclude_new_messages,
            'ranges': ([] if self.ranges is None else [None if x is None else x.to_dict() for x in self.ranges]) if recursive else self.ranges,
        }

    def __bytes__(self):
        return b''.join((
            b'W\xd9w\xcd',
            struct.pack('<I', (2 if self.exclude_new_messages else 0)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.ranges)),b''.join(bytes(x) for x in self.ranges),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _exclude_new_messages = bool(flags & 2)
        reader.read_int()
        _ranges = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _ranges.append(_x)

        return ChannelMessagesFilter(ranges=_ranges, exclude_new_messages=_exclude_new_messages)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelMessagesFilterEmpty(TLObject):
    CONSTRUCTOR_ID = 0x94d42ee7
    SUBCLASS_OF_ID = 0x13336a56

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xe7.\xd4\x94',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelMessagesFilterEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipant(TLObject):
    CONSTRUCTOR_ID = 0x15ebac1d
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, date):
        """
        :param int user_id:
        :param datetime.datetime | None date:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.user_id = user_id
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1d\xac\xeb\x15',
            struct.pack('<i', self.user_id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        return ChannelParticipant(user_id=_user_id, date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipantAdmin(TLObject):
    CONSTRUCTOR_ID = 0xa82fa898
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, inviter_id, promoted_by, date, admin_rights, can_edit=None):
        """
        :param bool | None can_edit:
        :param int user_id:
        :param int inviter_id:
        :param int promoted_by:
        :param datetime.datetime | None date:
        :param TLObject admin_rights:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.can_edit = can_edit
        self.user_id = user_id
        self.inviter_id = inviter_id
        self.promoted_by = promoted_by
        self.date = date
        self.admin_rights = admin_rights

    def to_dict(self, recursive=True):
        return {
            'can_edit': self.can_edit,
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'promoted_by': self.promoted_by,
            'date': self.date,
            'admin_rights': (None if self.admin_rights is None else self.admin_rights.to_dict()) if recursive else self.admin_rights,
        }

    def __bytes__(self):
        return b''.join((
            b'\x98\xa8/\xa8',
            struct.pack('<I', (1 if self.can_edit else 0)),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            struct.pack('<i', self.promoted_by),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            bytes(self.admin_rights),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _can_edit = bool(flags & 1)
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _promoted_by = reader.read_int()
        _date = reader.tgread_date()
        _admin_rights = reader.tgread_object()
        return ChannelParticipantAdmin(user_id=_user_id, inviter_id=_inviter_id, promoted_by=_promoted_by, date=_date, admin_rights=_admin_rights, can_edit=_can_edit)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipantBanned(TLObject):
    CONSTRUCTOR_ID = 0x222c1886
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, kicked_by, date, banned_rights, left=None):
        """
        :param bool | None left:
        :param int user_id:
        :param int kicked_by:
        :param datetime.datetime | None date:
        :param TLObject banned_rights:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.left = left
        self.user_id = user_id
        self.kicked_by = kicked_by
        self.date = date
        self.banned_rights = banned_rights

    def to_dict(self, recursive=True):
        return {
            'left': self.left,
            'user_id': self.user_id,
            'kicked_by': self.kicked_by,
            'date': self.date,
            'banned_rights': (None if self.banned_rights is None else self.banned_rights.to_dict()) if recursive else self.banned_rights,
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\x18,"',
            struct.pack('<I', (1 if self.left else 0)),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.kicked_by),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            bytes(self.banned_rights),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _left = bool(flags & 1)
        _user_id = reader.read_int()
        _kicked_by = reader.read_int()
        _date = reader.tgread_date()
        _banned_rights = reader.tgread_object()
        return ChannelParticipantBanned(user_id=_user_id, kicked_by=_kicked_by, date=_date, banned_rights=_banned_rights, left=_left)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipantCreator(TLObject):
    CONSTRUCTOR_ID = 0xe3e2e1f9
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.user_id = user_id

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf9\xe1\xe2\xe3',
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        return ChannelParticipantCreator(user_id=_user_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipantSelf(TLObject):
    CONSTRUCTOR_ID = 0xa3289a6d
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, inviter_id, date):
        """
        :param int user_id:
        :param int inviter_id:
        :param datetime.datetime | None date:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'm\x9a(\xa3',
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        return ChannelParticipantSelf(user_id=_user_id, inviter_id=_inviter_id, date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipantsAdmins(TLObject):
    CONSTRUCTOR_ID = 0xb4608969
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'i\x89`\xb4',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelParticipantsAdmins()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipantsBanned(TLObject):
    CONSTRUCTOR_ID = 0x1427a5e1
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self, q):
        """
        :param str q:

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        super().__init__()

        self.q = q

    def to_dict(self, recursive=True):
        return {
            'q': self.q,
        }

    def __bytes__(self):
        return b''.join((
            b"\xe1\xa5'\x14",
            TLObject.serialize_bytes(self.q),
        ))

    @staticmethod
    def from_reader(reader):
        _q = reader.tgread_string()
        return ChannelParticipantsBanned(q=_q)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipantsBots(TLObject):
    CONSTRUCTOR_ID = 0xb0d1865b
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'[\x86\xd1\xb0',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelParticipantsBots()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipantsKicked(TLObject):
    CONSTRUCTOR_ID = 0xa3b54985
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self, q):
        """
        :param str q:

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        super().__init__()

        self.q = q

    def to_dict(self, recursive=True):
        return {
            'q': self.q,
        }

    def __bytes__(self):
        return b''.join((
            b'\x85I\xb5\xa3',
            TLObject.serialize_bytes(self.q),
        ))

    @staticmethod
    def from_reader(reader):
        _q = reader.tgread_string()
        return ChannelParticipantsKicked(q=_q)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipantsRecent(TLObject):
    CONSTRUCTOR_ID = 0xde3f3c79
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'y<?\xde',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelParticipantsRecent()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelParticipantsSearch(TLObject):
    CONSTRUCTOR_ID = 0x656ac4b
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self, q):
        """
        :param str q:

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        super().__init__()

        self.q = q

    def to_dict(self, recursive=True):
        return {
            'q': self.q,
        }

    def __bytes__(self):
        return b''.join((
            b'K\xacV\x06',
            TLObject.serialize_bytes(self.q),
        ))

    @staticmethod
    def from_reader(reader):
        _q = reader.tgread_string()
        return ChannelParticipantsSearch(q=_q)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Chat(TLObject):
    CONSTRUCTOR_ID = 0xd91cdd54
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, title, photo, participants_count, date, version, creator=None, kicked=None, left=None, admins_enabled=None, admin=None, deactivated=None, migrated_to=None):
        """
        :param bool | None creator:
        :param bool | None kicked:
        :param bool | None left:
        :param bool | None admins_enabled:
        :param bool | None admin:
        :param bool | None deactivated:
        :param int id:
        :param str title:
        :param TLObject photo:
        :param int participants_count:
        :param datetime.datetime | None date:
        :param int version:
        :param TLObject | None migrated_to:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.creator = creator
        self.kicked = kicked
        self.left = left
        self.admins_enabled = admins_enabled
        self.admin = admin
        self.deactivated = deactivated
        self.id = id
        self.title = title
        self.photo = photo
        self.participants_count = participants_count
        self.date = date
        self.version = version
        self.migrated_to = migrated_to

    def to_dict(self, recursive=True):
        return {
            'creator': self.creator,
            'kicked': self.kicked,
            'left': self.left,
            'admins_enabled': self.admins_enabled,
            'admin': self.admin,
            'deactivated': self.deactivated,
            'id': self.id,
            'title': self.title,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'participants_count': self.participants_count,
            'date': self.date,
            'version': self.version,
            'migrated_to': (None if self.migrated_to is None else self.migrated_to.to_dict()) if recursive else self.migrated_to,
        }

    def __bytes__(self):
        return b''.join((
            b'T\xdd\x1c\xd9',
            struct.pack('<I', (1 if self.creator else 0) | (2 if self.kicked else 0) | (4 if self.left else 0) | (8 if self.admins_enabled else 0) | (16 if self.admin else 0) | (32 if self.deactivated else 0) | (64 if self.migrated_to else 0)),
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.title),
            bytes(self.photo),
            struct.pack('<i', self.participants_count),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.version),
            b'' if not self.migrated_to else (bytes(self.migrated_to)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _creator = bool(flags & 1)
        _kicked = bool(flags & 2)
        _left = bool(flags & 4)
        _admins_enabled = bool(flags & 8)
        _admin = bool(flags & 16)
        _deactivated = bool(flags & 32)
        _id = reader.read_int()
        _title = reader.tgread_string()
        _photo = reader.tgread_object()
        _participants_count = reader.read_int()
        _date = reader.tgread_date()
        _version = reader.read_int()
        if flags & 64:
            _migrated_to = reader.tgread_object()
        else:
            _migrated_to = None
        return Chat(id=_id, title=_title, photo=_photo, participants_count=_participants_count, date=_date, version=_version, creator=_creator, kicked=_kicked, left=_left, admins_enabled=_admins_enabled, admin=_admin, deactivated=_deactivated, migrated_to=_migrated_to)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatEmpty(TLObject):
    CONSTRUCTOR_ID = 0x9ba2d800
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id):
        """
        :param int id:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x00\xd8\xa2\x9b',
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        return ChatEmpty(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatForbidden(TLObject):
    CONSTRUCTOR_ID = 0x7328bdb
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, title):
        """
        :param int id:
        :param str title:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.id = id
        self.title = title

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'title': self.title,
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb\x8b2\x07',
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _title = reader.tgread_string()
        return ChatForbidden(id=_id, title=_title)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatFull(TLObject):
    CONSTRUCTOR_ID = 0x2e02a614
    SUBCLASS_OF_ID = 0xd49a2697

    def __init__(self, id, participants, chat_photo, notify_settings, exported_invite, bot_info):
        """
        :param int id:
        :param TLObject participants:
        :param TLObject chat_photo:
        :param TLObject notify_settings:
        :param TLObject exported_invite:
        :param list[TLObject] bot_info:

        Constructor for ChatFull: Instance of either ChatFull, ChannelFull.
        """
        super().__init__()

        self.id = id
        self.participants = participants
        self.chat_photo = chat_photo
        self.notify_settings = notify_settings
        self.exported_invite = exported_invite
        self.bot_info = bot_info

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'participants': (None if self.participants is None else self.participants.to_dict()) if recursive else self.participants,
            'chat_photo': (None if self.chat_photo is None else self.chat_photo.to_dict()) if recursive else self.chat_photo,
            'notify_settings': (None if self.notify_settings is None else self.notify_settings.to_dict()) if recursive else self.notify_settings,
            'exported_invite': (None if self.exported_invite is None else self.exported_invite.to_dict()) if recursive else self.exported_invite,
            'bot_info': ([] if self.bot_info is None else [None if x is None else x.to_dict() for x in self.bot_info]) if recursive else self.bot_info,
        }

    def __bytes__(self):
        return b''.join((
            b'\x14\xa6\x02.',
            struct.pack('<i', self.id),
            bytes(self.participants),
            bytes(self.chat_photo),
            bytes(self.notify_settings),
            bytes(self.exported_invite),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.bot_info)),b''.join(bytes(x) for x in self.bot_info),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _participants = reader.tgread_object()
        _chat_photo = reader.tgread_object()
        _notify_settings = reader.tgread_object()
        _exported_invite = reader.tgread_object()
        reader.read_int()
        _bot_info = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _bot_info.append(_x)

        return ChatFull(id=_id, participants=_participants, chat_photo=_chat_photo, notify_settings=_notify_settings, exported_invite=_exported_invite, bot_info=_bot_info)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatInvite(TLObject):
    CONSTRUCTOR_ID = 0xdb74f558
    SUBCLASS_OF_ID = 0x4561736

    def __init__(self, title, photo, participants_count, channel=None, broadcast=None, public=None, megagroup=None, participants=None):
        """
        :param bool | None channel:
        :param bool | None broadcast:
        :param bool | None public:
        :param bool | None megagroup:
        :param str title:
        :param TLObject photo:
        :param int participants_count:
        :param list[TLObject] | None participants:

        Constructor for ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        super().__init__()

        self.channel = channel
        self.broadcast = broadcast
        self.public = public
        self.megagroup = megagroup
        self.title = title
        self.photo = photo
        self.participants_count = participants_count
        self.participants = participants

    def to_dict(self, recursive=True):
        return {
            'channel': self.channel,
            'broadcast': self.broadcast,
            'public': self.public,
            'megagroup': self.megagroup,
            'title': self.title,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'participants_count': self.participants_count,
            'participants': ([] if self.participants is None else [None if x is None else x.to_dict() for x in self.participants]) if recursive else self.participants,
        }

    def __bytes__(self):
        return b''.join((
            b'X\xf5t\xdb',
            struct.pack('<I', (1 if self.channel else 0) | (2 if self.broadcast else 0) | (4 if self.public else 0) | (8 if self.megagroup else 0) | (16 if self.participants else 0)),
            TLObject.serialize_bytes(self.title),
            bytes(self.photo),
            struct.pack('<i', self.participants_count),
            b'' if not self.participants else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.participants)),b''.join(bytes(x) for x in self.participants))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _channel = bool(flags & 1)
        _broadcast = bool(flags & 2)
        _public = bool(flags & 4)
        _megagroup = bool(flags & 8)
        _title = reader.tgread_string()
        _photo = reader.tgread_object()
        _participants_count = reader.read_int()
        if flags & 16:
            reader.read_int()
            _participants = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _participants.append(_x)

        else:
            _participants = None
        return ChatInvite(title=_title, photo=_photo, participants_count=_participants_count, channel=_channel, broadcast=_broadcast, public=_public, megagroup=_megagroup, participants=_participants)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatInviteAlready(TLObject):
    CONSTRUCTOR_ID = 0x5a686d7c
    SUBCLASS_OF_ID = 0x4561736

    def __init__(self, chat):
        """
        :param TLObject chat:

        Constructor for ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        super().__init__()

        self.chat = chat

    def to_dict(self, recursive=True):
        return {
            'chat': (None if self.chat is None else self.chat.to_dict()) if recursive else self.chat,
        }

    def __bytes__(self):
        return b''.join((
            b'|mhZ',
            bytes(self.chat),
        ))

    @staticmethod
    def from_reader(reader):
        _chat = reader.tgread_object()
        return ChatInviteAlready(chat=_chat)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatInviteEmpty(TLObject):
    CONSTRUCTOR_ID = 0x69df3769
    SUBCLASS_OF_ID = 0xb4748a58

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'i7\xdfi',
        ))

    @staticmethod
    def from_reader(reader):
        return ChatInviteEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatInviteExported(TLObject):
    CONSTRUCTOR_ID = 0xfc2e05bc
    SUBCLASS_OF_ID = 0xb4748a58

    def __init__(self, link):
        """
        :param str link:

        Constructor for ExportedChatInvite: Instance of either ChatInviteEmpty, ChatInviteExported.
        """
        super().__init__()

        self.link = link

    def to_dict(self, recursive=True):
        return {
            'link': self.link,
        }

    def __bytes__(self):
        return b''.join((
            b'\xbc\x05.\xfc',
            TLObject.serialize_bytes(self.link),
        ))

    @staticmethod
    def from_reader(reader):
        _link = reader.tgread_string()
        return ChatInviteExported(link=_link)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatParticipant(TLObject):
    CONSTRUCTOR_ID = 0xc8d7493e
    SUBCLASS_OF_ID = 0x7d7c6f86

    def __init__(self, user_id, inviter_id, date):
        """
        :param int user_id:
        :param int inviter_id:
        :param datetime.datetime | None date:

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        super().__init__()

        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'>I\xd7\xc8',
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        return ChatParticipant(user_id=_user_id, inviter_id=_inviter_id, date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatParticipantAdmin(TLObject):
    CONSTRUCTOR_ID = 0xe2d6e436
    SUBCLASS_OF_ID = 0x7d7c6f86

    def __init__(self, user_id, inviter_id, date):
        """
        :param int user_id:
        :param int inviter_id:
        :param datetime.datetime | None date:

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        super().__init__()

        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'6\xe4\xd6\xe2',
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        return ChatParticipantAdmin(user_id=_user_id, inviter_id=_inviter_id, date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatParticipantCreator(TLObject):
    CONSTRUCTOR_ID = 0xda13538a
    SUBCLASS_OF_ID = 0x7d7c6f86

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        super().__init__()

        self.user_id = user_id

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x8aS\x13\xda',
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        return ChatParticipantCreator(user_id=_user_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatParticipants(TLObject):
    CONSTRUCTOR_ID = 0x3f460fed
    SUBCLASS_OF_ID = 0x1fa89571

    def __init__(self, chat_id, participants, version):
        """
        :param int chat_id:
        :param list[TLObject] participants:
        :param int version:

        Constructor for ChatParticipants: Instance of either ChatParticipantsForbidden, ChatParticipants.
        """
        super().__init__()

        self.chat_id = chat_id
        self.participants = participants
        self.version = version

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'participants': ([] if self.participants is None else [None if x is None else x.to_dict() for x in self.participants]) if recursive else self.participants,
            'version': self.version,
        }

    def __bytes__(self):
        return b''.join((
            b'\xed\x0fF?',
            struct.pack('<i', self.chat_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.participants)),b''.join(bytes(x) for x in self.participants),
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        reader.read_int()
        _participants = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _participants.append(_x)

        _version = reader.read_int()
        return ChatParticipants(chat_id=_chat_id, participants=_participants, version=_version)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatParticipantsForbidden(TLObject):
    CONSTRUCTOR_ID = 0xfc900c2b
    SUBCLASS_OF_ID = 0x1fa89571

    def __init__(self, chat_id, self_participant=None):
        """
        :param int chat_id:
        :param TLObject | None self_participant:

        Constructor for ChatParticipants: Instance of either ChatParticipantsForbidden, ChatParticipants.
        """
        super().__init__()

        self.chat_id = chat_id
        self.self_participant = self_participant

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'self_participant': (None if self.self_participant is None else self.self_participant.to_dict()) if recursive else self.self_participant,
        }

    def __bytes__(self):
        return b''.join((
            b'+\x0c\x90\xfc',
            struct.pack('<I', (1 if self.self_participant else 0)),
            struct.pack('<i', self.chat_id),
            b'' if not self.self_participant else (bytes(self.self_participant)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _chat_id = reader.read_int()
        if flags & 1:
            _self_participant = reader.tgread_object()
        else:
            _self_participant = None
        return ChatParticipantsForbidden(chat_id=_chat_id, self_participant=_self_participant)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatPhoto(TLObject):
    CONSTRUCTOR_ID = 0x6153276a
    SUBCLASS_OF_ID = 0xac3ec4e5

    def __init__(self, photo_small, photo_big):
        """
        :param TLObject photo_small:
        :param TLObject photo_big:

        Constructor for ChatPhoto: Instance of either ChatPhotoEmpty, ChatPhoto.
        """
        super().__init__()

        self.photo_small = photo_small
        self.photo_big = photo_big

    def to_dict(self, recursive=True):
        return {
            'photo_small': (None if self.photo_small is None else self.photo_small.to_dict()) if recursive else self.photo_small,
            'photo_big': (None if self.photo_big is None else self.photo_big.to_dict()) if recursive else self.photo_big,
        }

    def __bytes__(self):
        return b''.join((
            b"j'Sa",
            bytes(self.photo_small),
            bytes(self.photo_big),
        ))

    @staticmethod
    def from_reader(reader):
        _photo_small = reader.tgread_object()
        _photo_big = reader.tgread_object()
        return ChatPhoto(photo_small=_photo_small, photo_big=_photo_big)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatPhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x37c1011c
    SUBCLASS_OF_ID = 0xac3ec4e5

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x1c\x01\xc17',
        ))

    @staticmethod
    def from_reader(reader):
        return ChatPhotoEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ClientDHInnerData(TLObject):
    CONSTRUCTOR_ID = 0x6643b654
    SUBCLASS_OF_ID = 0xf8eeef6a

    def __init__(self, nonce, server_nonce, retry_id, g_b):
        """
        :param int nonce:
        :param int server_nonce:
        :param int retry_id:
        :param bytes g_b:

        Constructor for Client_DH_Inner_Data: Instance of ClientDHInnerData.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.retry_id = retry_id
        self.g_b = g_b

    def to_dict(self, recursive=True):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'retry_id': self.retry_id,
            'g_b': self.g_b,
        }

    def __bytes__(self):
        return b''.join((
            b'T\xb6Cf',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            struct.pack('<q', self.retry_id),
            TLObject.serialize_bytes(self.g_b),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _retry_id = reader.read_long()
        _g_b = reader.tgread_bytes()
        return ClientDHInnerData(nonce=_nonce, server_nonce=_server_nonce, retry_id=_retry_id, g_b=_g_b)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Config(TLObject):
    CONSTRUCTOR_ID = 0x8df376a4
    SUBCLASS_OF_ID = 0xd3262a4a

    def __init__(self, date, expires, test_mode, this_dc, dc_options, chat_size_max, megagroup_size_max, forwarded_count_max, online_update_period_ms, offline_blur_timeout_ms, offline_idle_timeout_ms, online_cloud_timeout_ms, notify_cloud_delay_ms, notify_default_delay_ms, chat_big_size, push_chat_period_ms, push_chat_limit, saved_gifs_limit, edit_time_limit, rating_e_decay, stickers_recent_limit, stickers_faved_limit, pinned_dialogs_count_max, call_receive_timeout_ms, call_ring_timeout_ms, call_connect_timeout_ms, call_packet_timeout_ms, me_url_prefix, disabled_features, phonecalls_enabled=None, tmp_sessions=None, suggested_lang_code=None, lang_pack_version=None):
        """
        :param bool | None phonecalls_enabled:
        :param datetime.datetime | None date:
        :param datetime.datetime | None expires:
        :param TLObject test_mode:
        :param int this_dc:
        :param list[TLObject] dc_options:
        :param int chat_size_max:
        :param int megagroup_size_max:
        :param int forwarded_count_max:
        :param int online_update_period_ms:
        :param int offline_blur_timeout_ms:
        :param int offline_idle_timeout_ms:
        :param int online_cloud_timeout_ms:
        :param int notify_cloud_delay_ms:
        :param int notify_default_delay_ms:
        :param int chat_big_size:
        :param int push_chat_period_ms:
        :param int push_chat_limit:
        :param int saved_gifs_limit:
        :param int edit_time_limit:
        :param int rating_e_decay:
        :param int stickers_recent_limit:
        :param int stickers_faved_limit:
        :param int | None tmp_sessions:
        :param int pinned_dialogs_count_max:
        :param int call_receive_timeout_ms:
        :param int call_ring_timeout_ms:
        :param int call_connect_timeout_ms:
        :param int call_packet_timeout_ms:
        :param str me_url_prefix:
        :param str | None suggested_lang_code:
        :param int | None lang_pack_version:
        :param list[TLObject] disabled_features:

        Constructor for Config: Instance of Config.
        """
        super().__init__()

        self.phonecalls_enabled = phonecalls_enabled
        self.date = date
        self.expires = expires
        self.test_mode = test_mode
        self.this_dc = this_dc
        self.dc_options = dc_options
        self.chat_size_max = chat_size_max
        self.megagroup_size_max = megagroup_size_max
        self.forwarded_count_max = forwarded_count_max
        self.online_update_period_ms = online_update_period_ms
        self.offline_blur_timeout_ms = offline_blur_timeout_ms
        self.offline_idle_timeout_ms = offline_idle_timeout_ms
        self.online_cloud_timeout_ms = online_cloud_timeout_ms
        self.notify_cloud_delay_ms = notify_cloud_delay_ms
        self.notify_default_delay_ms = notify_default_delay_ms
        self.chat_big_size = chat_big_size
        self.push_chat_period_ms = push_chat_period_ms
        self.push_chat_limit = push_chat_limit
        self.saved_gifs_limit = saved_gifs_limit
        self.edit_time_limit = edit_time_limit
        self.rating_e_decay = rating_e_decay
        self.stickers_recent_limit = stickers_recent_limit
        self.stickers_faved_limit = stickers_faved_limit
        self.tmp_sessions = tmp_sessions
        self.pinned_dialogs_count_max = pinned_dialogs_count_max
        self.call_receive_timeout_ms = call_receive_timeout_ms
        self.call_ring_timeout_ms = call_ring_timeout_ms
        self.call_connect_timeout_ms = call_connect_timeout_ms
        self.call_packet_timeout_ms = call_packet_timeout_ms
        self.me_url_prefix = me_url_prefix
        self.suggested_lang_code = suggested_lang_code
        self.lang_pack_version = lang_pack_version
        self.disabled_features = disabled_features

    def to_dict(self, recursive=True):
        return {
            'phonecalls_enabled': self.phonecalls_enabled,
            'date': self.date,
            'expires': self.expires,
            'test_mode': self.test_mode,
            'this_dc': self.this_dc,
            'dc_options': ([] if self.dc_options is None else [None if x is None else x.to_dict() for x in self.dc_options]) if recursive else self.dc_options,
            'chat_size_max': self.chat_size_max,
            'megagroup_size_max': self.megagroup_size_max,
            'forwarded_count_max': self.forwarded_count_max,
            'online_update_period_ms': self.online_update_period_ms,
            'offline_blur_timeout_ms': self.offline_blur_timeout_ms,
            'offline_idle_timeout_ms': self.offline_idle_timeout_ms,
            'online_cloud_timeout_ms': self.online_cloud_timeout_ms,
            'notify_cloud_delay_ms': self.notify_cloud_delay_ms,
            'notify_default_delay_ms': self.notify_default_delay_ms,
            'chat_big_size': self.chat_big_size,
            'push_chat_period_ms': self.push_chat_period_ms,
            'push_chat_limit': self.push_chat_limit,
            'saved_gifs_limit': self.saved_gifs_limit,
            'edit_time_limit': self.edit_time_limit,
            'rating_e_decay': self.rating_e_decay,
            'stickers_recent_limit': self.stickers_recent_limit,
            'stickers_faved_limit': self.stickers_faved_limit,
            'tmp_sessions': self.tmp_sessions,
            'pinned_dialogs_count_max': self.pinned_dialogs_count_max,
            'call_receive_timeout_ms': self.call_receive_timeout_ms,
            'call_ring_timeout_ms': self.call_ring_timeout_ms,
            'call_connect_timeout_ms': self.call_connect_timeout_ms,
            'call_packet_timeout_ms': self.call_packet_timeout_ms,
            'me_url_prefix': self.me_url_prefix,
            'suggested_lang_code': self.suggested_lang_code,
            'lang_pack_version': self.lang_pack_version,
            'disabled_features': ([] if self.disabled_features is None else [None if x is None else x.to_dict() for x in self.disabled_features]) if recursive else self.disabled_features,
        }

    def __bytes__(self):
        assert (self.suggested_lang_code is None and self.lang_pack_version is None) or (self.suggested_lang_code is not None and self.lang_pack_version is not None), 'suggested_lang_code, lang_pack_version parameters must all be None or neither be None'
        return b''.join((
            b'\xa4v\xf3\x8d',
            struct.pack('<I', (2 if self.phonecalls_enabled else 0) | (1 if self.tmp_sessions else 0) | (4 if self.suggested_lang_code else 0) | (4 if self.lang_pack_version else 0)),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            b'\0\0\0\0' if self.expires is None else struct.pack('<I', int(self.expires.timestamp())),
            b'\xb5ur\x99' if self.test_mode else b'7\x97y\xbc',
            struct.pack('<i', self.this_dc),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dc_options)),b''.join(bytes(x) for x in self.dc_options),
            struct.pack('<i', self.chat_size_max),
            struct.pack('<i', self.megagroup_size_max),
            struct.pack('<i', self.forwarded_count_max),
            struct.pack('<i', self.online_update_period_ms),
            struct.pack('<i', self.offline_blur_timeout_ms),
            struct.pack('<i', self.offline_idle_timeout_ms),
            struct.pack('<i', self.online_cloud_timeout_ms),
            struct.pack('<i', self.notify_cloud_delay_ms),
            struct.pack('<i', self.notify_default_delay_ms),
            struct.pack('<i', self.chat_big_size),
            struct.pack('<i', self.push_chat_period_ms),
            struct.pack('<i', self.push_chat_limit),
            struct.pack('<i', self.saved_gifs_limit),
            struct.pack('<i', self.edit_time_limit),
            struct.pack('<i', self.rating_e_decay),
            struct.pack('<i', self.stickers_recent_limit),
            struct.pack('<i', self.stickers_faved_limit),
            b'' if not self.tmp_sessions else (struct.pack('<i', self.tmp_sessions)),
            struct.pack('<i', self.pinned_dialogs_count_max),
            struct.pack('<i', self.call_receive_timeout_ms),
            struct.pack('<i', self.call_ring_timeout_ms),
            struct.pack('<i', self.call_connect_timeout_ms),
            struct.pack('<i', self.call_packet_timeout_ms),
            TLObject.serialize_bytes(self.me_url_prefix),
            b'' if not self.suggested_lang_code else (TLObject.serialize_bytes(self.suggested_lang_code)),
            b'' if not self.lang_pack_version else (struct.pack('<i', self.lang_pack_version)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.disabled_features)),b''.join(bytes(x) for x in self.disabled_features),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _phonecalls_enabled = bool(flags & 2)
        _date = reader.tgread_date()
        _expires = reader.tgread_date()
        _test_mode = reader.tgread_bool()
        _this_dc = reader.read_int()
        reader.read_int()
        _dc_options = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dc_options.append(_x)

        _chat_size_max = reader.read_int()
        _megagroup_size_max = reader.read_int()
        _forwarded_count_max = reader.read_int()
        _online_update_period_ms = reader.read_int()
        _offline_blur_timeout_ms = reader.read_int()
        _offline_idle_timeout_ms = reader.read_int()
        _online_cloud_timeout_ms = reader.read_int()
        _notify_cloud_delay_ms = reader.read_int()
        _notify_default_delay_ms = reader.read_int()
        _chat_big_size = reader.read_int()
        _push_chat_period_ms = reader.read_int()
        _push_chat_limit = reader.read_int()
        _saved_gifs_limit = reader.read_int()
        _edit_time_limit = reader.read_int()
        _rating_e_decay = reader.read_int()
        _stickers_recent_limit = reader.read_int()
        _stickers_faved_limit = reader.read_int()
        if flags & 1:
            _tmp_sessions = reader.read_int()
        else:
            _tmp_sessions = None
        _pinned_dialogs_count_max = reader.read_int()
        _call_receive_timeout_ms = reader.read_int()
        _call_ring_timeout_ms = reader.read_int()
        _call_connect_timeout_ms = reader.read_int()
        _call_packet_timeout_ms = reader.read_int()
        _me_url_prefix = reader.tgread_string()
        if flags & 4:
            _suggested_lang_code = reader.tgread_string()
        else:
            _suggested_lang_code = None
        if flags & 4:
            _lang_pack_version = reader.read_int()
        else:
            _lang_pack_version = None
        reader.read_int()
        _disabled_features = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _disabled_features.append(_x)

        return Config(date=_date, expires=_expires, test_mode=_test_mode, this_dc=_this_dc, dc_options=_dc_options, chat_size_max=_chat_size_max, megagroup_size_max=_megagroup_size_max, forwarded_count_max=_forwarded_count_max, online_update_period_ms=_online_update_period_ms, offline_blur_timeout_ms=_offline_blur_timeout_ms, offline_idle_timeout_ms=_offline_idle_timeout_ms, online_cloud_timeout_ms=_online_cloud_timeout_ms, notify_cloud_delay_ms=_notify_cloud_delay_ms, notify_default_delay_ms=_notify_default_delay_ms, chat_big_size=_chat_big_size, push_chat_period_ms=_push_chat_period_ms, push_chat_limit=_push_chat_limit, saved_gifs_limit=_saved_gifs_limit, edit_time_limit=_edit_time_limit, rating_e_decay=_rating_e_decay, stickers_recent_limit=_stickers_recent_limit, stickers_faved_limit=_stickers_faved_limit, pinned_dialogs_count_max=_pinned_dialogs_count_max, call_receive_timeout_ms=_call_receive_timeout_ms, call_ring_timeout_ms=_call_ring_timeout_ms, call_connect_timeout_ms=_call_connect_timeout_ms, call_packet_timeout_ms=_call_packet_timeout_ms, me_url_prefix=_me_url_prefix, disabled_features=_disabled_features, phonecalls_enabled=_phonecalls_enabled, tmp_sessions=_tmp_sessions, suggested_lang_code=_suggested_lang_code, lang_pack_version=_lang_pack_version)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Contact(TLObject):
    CONSTRUCTOR_ID = 0xf911c994
    SUBCLASS_OF_ID = 0x83dfdfa4

    def __init__(self, user_id, mutual):
        """
        :param int user_id:
        :param TLObject mutual:

        Constructor for Contact: Instance of Contact.
        """
        super().__init__()

        self.user_id = user_id
        self.mutual = mutual

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'mutual': self.mutual,
        }

    def __bytes__(self):
        return b''.join((
            b'\x94\xc9\x11\xf9',
            struct.pack('<i', self.user_id),
            b'\xb5ur\x99' if self.mutual else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _mutual = reader.tgread_bool()
        return Contact(user_id=_user_id, mutual=_mutual)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ContactBlocked(TLObject):
    CONSTRUCTOR_ID = 0x561bc879
    SUBCLASS_OF_ID = 0xb12d7ac6

    def __init__(self, user_id, date):
        """
        :param int user_id:
        :param datetime.datetime | None date:

        Constructor for ContactBlocked: Instance of ContactBlocked.
        """
        super().__init__()

        self.user_id = user_id
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'y\xc8\x1bV',
            struct.pack('<i', self.user_id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        return ContactBlocked(user_id=_user_id, date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ContactLinkContact(TLObject):
    CONSTRUCTOR_ID = 0xd502c2d0
    SUBCLASS_OF_ID = 0xa053c1da

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xd0\xc2\x02\xd5',
        ))

    @staticmethod
    def from_reader(reader):
        return ContactLinkContact()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ContactLinkHasPhone(TLObject):
    CONSTRUCTOR_ID = 0x268f3f59
    SUBCLASS_OF_ID = 0xa053c1da

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'Y?\x8f&',
        ))

    @staticmethod
    def from_reader(reader):
        return ContactLinkHasPhone()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ContactLinkNone(TLObject):
    CONSTRUCTOR_ID = 0xfeedd3ad
    SUBCLASS_OF_ID = 0xa053c1da

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xad\xd3\xed\xfe',
        ))

    @staticmethod
    def from_reader(reader):
        return ContactLinkNone()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ContactLinkUnknown(TLObject):
    CONSTRUCTOR_ID = 0x5f4f9247
    SUBCLASS_OF_ID = 0xa053c1da

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'G\x92O_',
        ))

    @staticmethod
    def from_reader(reader):
        return ContactLinkUnknown()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ContactStatus(TLObject):
    CONSTRUCTOR_ID = 0xd3680c61
    SUBCLASS_OF_ID = 0x68c0d74c

    def __init__(self, user_id, status):
        """
        :param int user_id:
        :param TLObject status:

        Constructor for ContactStatus: Instance of ContactStatus.
        """
        super().__init__()

        self.user_id = user_id
        self.status = status

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'status': (None if self.status is None else self.status.to_dict()) if recursive else self.status,
        }

    def __bytes__(self):
        return b''.join((
            b'a\x0ch\xd3',
            struct.pack('<i', self.user_id),
            bytes(self.status),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _status = reader.tgread_object()
        return ContactStatus(user_id=_user_id, status=_status)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DataJSON(TLObject):
    CONSTRUCTOR_ID = 0x7d748d04
    SUBCLASS_OF_ID = 0xad0352e8

    def __init__(self, data):
        """
        :param str data:

        Constructor for DataJSON: Instance of DataJSON.
        """
        super().__init__()

        self.data = data

    def to_dict(self, recursive=True):
        return {
            'data': self.data,
        }

    def __bytes__(self):
        return b''.join((
            b'\x04\x8dt}',
            TLObject.serialize_bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        _data = reader.tgread_string()
        return DataJSON(data=_data)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DcOption(TLObject):
    CONSTRUCTOR_ID = 0x5d8c6cc
    SUBCLASS_OF_ID = 0x9e43e123

    def __init__(self, id, ip_address, port, ipv6=None, media_only=None, tcpo_only=None, cdn=None, static=None):
        """
        :param bool | None ipv6:
        :param bool | None media_only:
        :param bool | None tcpo_only:
        :param bool | None cdn:
        :param bool | None static:
        :param int id:
        :param str ip_address:
        :param int port:

        Constructor for DcOption: Instance of DcOption.
        """
        super().__init__()

        self.ipv6 = ipv6
        self.media_only = media_only
        self.tcpo_only = tcpo_only
        self.cdn = cdn
        self.static = static
        self.id = id
        self.ip_address = ip_address
        self.port = port

    def to_dict(self, recursive=True):
        return {
            'ipv6': self.ipv6,
            'media_only': self.media_only,
            'tcpo_only': self.tcpo_only,
            'cdn': self.cdn,
            'static': self.static,
            'id': self.id,
            'ip_address': self.ip_address,
            'port': self.port,
        }

    def __bytes__(self):
        return b''.join((
            b'\xcc\xc6\xd8\x05',
            struct.pack('<I', (1 if self.ipv6 else 0) | (2 if self.media_only else 0) | (4 if self.tcpo_only else 0) | (8 if self.cdn else 0) | (16 if self.static else 0)),
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.ip_address),
            struct.pack('<i', self.port),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _ipv6 = bool(flags & 1)
        _media_only = bool(flags & 2)
        _tcpo_only = bool(flags & 4)
        _cdn = bool(flags & 8)
        _static = bool(flags & 16)
        _id = reader.read_int()
        _ip_address = reader.tgread_string()
        _port = reader.read_int()
        return DcOption(id=_id, ip_address=_ip_address, port=_port, ipv6=_ipv6, media_only=_media_only, tcpo_only=_tcpo_only, cdn=_cdn, static=_static)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DestroyAuthKeyFail(TLObject):
    CONSTRUCTOR_ID = 0xea109b13
    SUBCLASS_OF_ID = 0x8291e68e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x13\x9b\x10\xea',
        ))

    @staticmethod
    def from_reader(reader):
        return DestroyAuthKeyFail()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DestroyAuthKeyNone(TLObject):
    CONSTRUCTOR_ID = 0xa9f2259
    SUBCLASS_OF_ID = 0x8291e68e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'Y"\x9f\n',
        ))

    @staticmethod
    def from_reader(reader):
        return DestroyAuthKeyNone()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DestroyAuthKeyOk(TLObject):
    CONSTRUCTOR_ID = 0xf660e1d4
    SUBCLASS_OF_ID = 0x8291e68e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xd4\xe1`\xf6',
        ))

    @staticmethod
    def from_reader(reader):
        return DestroyAuthKeyOk()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DestroySessionNone(TLObject):
    CONSTRUCTOR_ID = 0x62d350c9
    SUBCLASS_OF_ID = 0xaf0ce7bd

    def __init__(self, session_id):
        """
        :param int session_id:

        Constructor for DestroySessionRes: Instance of either DestroySessionOk, DestroySessionNone.
        """
        super().__init__()

        self.session_id = session_id

    def to_dict(self, recursive=True):
        return {
            'session_id': self.session_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9P\xd3b',
            struct.pack('<q', self.session_id),
        ))

    @staticmethod
    def from_reader(reader):
        _session_id = reader.read_long()
        return DestroySessionNone(session_id=_session_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DestroySessionOk(TLObject):
    CONSTRUCTOR_ID = 0xe22045fc
    SUBCLASS_OF_ID = 0xaf0ce7bd

    def __init__(self, session_id):
        """
        :param int session_id:

        Constructor for DestroySessionRes: Instance of either DestroySessionOk, DestroySessionNone.
        """
        super().__init__()

        self.session_id = session_id

    def to_dict(self, recursive=True):
        return {
            'session_id': self.session_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xfcE \xe2',
            struct.pack('<q', self.session_id),
        ))

    @staticmethod
    def from_reader(reader):
        _session_id = reader.read_long()
        return DestroySessionOk(session_id=_session_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DhGenFail(TLObject):
    CONSTRUCTOR_ID = 0xa69dae02
    SUBCLASS_OF_ID = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash3):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash3:

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.new_nonce_hash3 = new_nonce_hash3

    def to_dict(self, recursive=True):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash3': self.new_nonce_hash3,
        }

    def __bytes__(self):
        return b''.join((
            b'\x02\xae\x9d\xa6',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash3.to_bytes(16, 'little', signed=True),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash3 = reader.read_large_int(bits=128)
        return DhGenFail(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash3=_new_nonce_hash3)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DhGenOk(TLObject):
    CONSTRUCTOR_ID = 0x3bcbf734
    SUBCLASS_OF_ID = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash1):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash1:

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.new_nonce_hash1 = new_nonce_hash1

    def to_dict(self, recursive=True):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash1': self.new_nonce_hash1,
        }

    def __bytes__(self):
        return b''.join((
            b'4\xf7\xcb;',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash1.to_bytes(16, 'little', signed=True),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash1 = reader.read_large_int(bits=128)
        return DhGenOk(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash1=_new_nonce_hash1)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DhGenRetry(TLObject):
    CONSTRUCTOR_ID = 0x46dc1fb9
    SUBCLASS_OF_ID = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash2):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash2:

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.new_nonce_hash2 = new_nonce_hash2

    def to_dict(self, recursive=True):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash2': self.new_nonce_hash2,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb9\x1f\xdcF',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash2.to_bytes(16, 'little', signed=True),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash2 = reader.read_large_int(bits=128)
        return DhGenRetry(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash2=_new_nonce_hash2)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Dialog(TLObject):
    CONSTRUCTOR_ID = 0xe4def5db
    SUBCLASS_OF_ID = 0x42cddd54

    def __init__(self, peer, top_message, read_inbox_max_id, read_outbox_max_id, unread_count, unread_mentions_count, notify_settings, pinned=None, pts=None, draft=None):
        """
        :param bool | None pinned:
        :param TLObject peer:
        :param int top_message:
        :param int read_inbox_max_id:
        :param int read_outbox_max_id:
        :param int unread_count:
        :param int unread_mentions_count:
        :param TLObject notify_settings:
        :param int | None pts:
        :param TLObject | None draft:

        Constructor for Dialog: Instance of Dialog.
        """
        super().__init__()

        self.pinned = pinned
        self.peer = peer
        self.top_message = top_message
        self.read_inbox_max_id = read_inbox_max_id
        self.read_outbox_max_id = read_outbox_max_id
        self.unread_count = unread_count
        self.unread_mentions_count = unread_mentions_count
        self.notify_settings = notify_settings
        self.pts = pts
        self.draft = draft

    def to_dict(self, recursive=True):
        return {
            'pinned': self.pinned,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'top_message': self.top_message,
            'read_inbox_max_id': self.read_inbox_max_id,
            'read_outbox_max_id': self.read_outbox_max_id,
            'unread_count': self.unread_count,
            'unread_mentions_count': self.unread_mentions_count,
            'notify_settings': (None if self.notify_settings is None else self.notify_settings.to_dict()) if recursive else self.notify_settings,
            'pts': self.pts,
            'draft': (None if self.draft is None else self.draft.to_dict()) if recursive else self.draft,
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb\xf5\xde\xe4',
            struct.pack('<I', (4 if self.pinned else 0) | (1 if self.pts else 0) | (2 if self.draft else 0)),
            bytes(self.peer),
            struct.pack('<i', self.top_message),
            struct.pack('<i', self.read_inbox_max_id),
            struct.pack('<i', self.read_outbox_max_id),
            struct.pack('<i', self.unread_count),
            struct.pack('<i', self.unread_mentions_count),
            bytes(self.notify_settings),
            b'' if not self.pts else (struct.pack('<i', self.pts)),
            b'' if not self.draft else (bytes(self.draft)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _pinned = bool(flags & 4)
        _peer = reader.tgread_object()
        _top_message = reader.read_int()
        _read_inbox_max_id = reader.read_int()
        _read_outbox_max_id = reader.read_int()
        _unread_count = reader.read_int()
        _unread_mentions_count = reader.read_int()
        _notify_settings = reader.tgread_object()
        if flags & 1:
            _pts = reader.read_int()
        else:
            _pts = None
        if flags & 2:
            _draft = reader.tgread_object()
        else:
            _draft = None
        return Dialog(peer=_peer, top_message=_top_message, read_inbox_max_id=_read_inbox_max_id, read_outbox_max_id=_read_outbox_max_id, unread_count=_unread_count, unread_mentions_count=_unread_mentions_count, notify_settings=_notify_settings, pinned=_pinned, pts=_pts, draft=_draft)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DisabledFeature(TLObject):
    CONSTRUCTOR_ID = 0xae636f24
    SUBCLASS_OF_ID = 0xcd266f94

    def __init__(self, feature, description):
        """
        :param str feature:
        :param str description:

        Constructor for DisabledFeature: Instance of DisabledFeature.
        """
        super().__init__()

        self.feature = feature
        self.description = description

    def to_dict(self, recursive=True):
        return {
            'feature': self.feature,
            'description': self.description,
        }

    def __bytes__(self):
        return b''.join((
            b'$oc\xae',
            TLObject.serialize_bytes(self.feature),
            TLObject.serialize_bytes(self.description),
        ))

    @staticmethod
    def from_reader(reader):
        _feature = reader.tgread_string()
        _description = reader.tgread_string()
        return DisabledFeature(feature=_feature, description=_description)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Document(TLObject):
    CONSTRUCTOR_ID = 0x87232bc7
    SUBCLASS_OF_ID = 0x211fe820

    def __init__(self, id, access_hash, date, mime_type, size, thumb, dc_id, version, attributes):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param str mime_type:
        :param int size:
        :param TLObject thumb:
        :param int dc_id:
        :param int version:
        :param list[TLObject] attributes:

        Constructor for Document: Instance of either DocumentEmpty, Document.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.mime_type = mime_type
        self.size = size
        self.thumb = thumb
        self.dc_id = dc_id
        self.version = version
        self.attributes = attributes

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'mime_type': self.mime_type,
            'size': self.size,
            'thumb': (None if self.thumb is None else self.thumb.to_dict()) if recursive else self.thumb,
            'dc_id': self.dc_id,
            'version': self.version,
            'attributes': ([] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes]) if recursive else self.attributes,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7+#\x87',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            TLObject.serialize_bytes(self.mime_type),
            struct.pack('<i', self.size),
            bytes(self.thumb),
            struct.pack('<i', self.dc_id),
            struct.pack('<i', self.version),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _mime_type = reader.tgread_string()
        _size = reader.read_int()
        _thumb = reader.tgread_object()
        _dc_id = reader.read_int()
        _version = reader.read_int()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        return Document(id=_id, access_hash=_access_hash, date=_date, mime_type=_mime_type, size=_size, thumb=_thumb, dc_id=_dc_id, version=_version, attributes=_attributes)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DocumentAttributeAnimated(TLObject):
    CONSTRUCTOR_ID = 0x11b58939
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'9\x89\xb5\x11',
        ))

    @staticmethod
    def from_reader(reader):
        return DocumentAttributeAnimated()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DocumentAttributeAudio(TLObject):
    CONSTRUCTOR_ID = 0x9852f9c6
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, duration, voice=None, title=None, performer=None, waveform=None):
        """
        :param bool | None voice:
        :param int duration:
        :param str | None title:
        :param str | None performer:
        :param bytes | None waveform:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.voice = voice
        self.duration = duration
        self.title = title
        self.performer = performer
        self.waveform = waveform

    def to_dict(self, recursive=True):
        return {
            'voice': self.voice,
            'duration': self.duration,
            'title': self.title,
            'performer': self.performer,
            'waveform': self.waveform,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc6\xf9R\x98',
            struct.pack('<I', (1024 if self.voice else 0) | (1 if self.title else 0) | (2 if self.performer else 0) | (4 if self.waveform else 0)),
            struct.pack('<i', self.duration),
            b'' if not self.title else (TLObject.serialize_bytes(self.title)),
            b'' if not self.performer else (TLObject.serialize_bytes(self.performer)),
            b'' if not self.waveform else (TLObject.serialize_bytes(self.waveform)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _voice = bool(flags & 1024)
        _duration = reader.read_int()
        if flags & 1:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 2:
            _performer = reader.tgread_string()
        else:
            _performer = None
        if flags & 4:
            _waveform = reader.tgread_bytes()
        else:
            _waveform = None
        return DocumentAttributeAudio(duration=_duration, voice=_voice, title=_title, performer=_performer, waveform=_waveform)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DocumentAttributeFilename(TLObject):
    CONSTRUCTOR_ID = 0x15590068
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, file_name):
        """
        :param str file_name:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.file_name = file_name

    def to_dict(self, recursive=True):
        return {
            'file_name': self.file_name,
        }

    def __bytes__(self):
        return b''.join((
            b'h\x00Y\x15',
            TLObject.serialize_bytes(self.file_name),
        ))

    @staticmethod
    def from_reader(reader):
        _file_name = reader.tgread_string()
        return DocumentAttributeFilename(file_name=_file_name)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DocumentAttributeHasStickers(TLObject):
    CONSTRUCTOR_ID = 0x9801d2f7
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xf7\xd2\x01\x98',
        ))

    @staticmethod
    def from_reader(reader):
        return DocumentAttributeHasStickers()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DocumentAttributeImageSize(TLObject):
    CONSTRUCTOR_ID = 0x6c37c15c
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, w, h):
        """
        :param int w:
        :param int h:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.w = w
        self.h = h

    def to_dict(self, recursive=True):
        return {
            'w': self.w,
            'h': self.h,
        }

    def __bytes__(self):
        return b''.join((
            b'\\\xc17l',
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
        ))

    @staticmethod
    def from_reader(reader):
        _w = reader.read_int()
        _h = reader.read_int()
        return DocumentAttributeImageSize(w=_w, h=_h)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DocumentAttributeSticker(TLObject):
    CONSTRUCTOR_ID = 0x6319d612
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, alt, stickerset, mask=None, mask_coords=None):
        """
        :param bool | None mask:
        :param str alt:
        :param TLObject stickerset:
        :param TLObject | None mask_coords:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.mask = mask
        self.alt = alt
        self.stickerset = stickerset
        self.mask_coords = mask_coords

    def to_dict(self, recursive=True):
        return {
            'mask': self.mask,
            'alt': self.alt,
            'stickerset': (None if self.stickerset is None else self.stickerset.to_dict()) if recursive else self.stickerset,
            'mask_coords': (None if self.mask_coords is None else self.mask_coords.to_dict()) if recursive else self.mask_coords,
        }

    def __bytes__(self):
        return b''.join((
            b'\x12\xd6\x19c',
            struct.pack('<I', (2 if self.mask else 0) | (1 if self.mask_coords else 0)),
            TLObject.serialize_bytes(self.alt),
            bytes(self.stickerset),
            b'' if not self.mask_coords else (bytes(self.mask_coords)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _mask = bool(flags & 2)
        _alt = reader.tgread_string()
        _stickerset = reader.tgread_object()
        if flags & 1:
            _mask_coords = reader.tgread_object()
        else:
            _mask_coords = None
        return DocumentAttributeSticker(alt=_alt, stickerset=_stickerset, mask=_mask, mask_coords=_mask_coords)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DocumentAttributeVideo(TLObject):
    CONSTRUCTOR_ID = 0xef02ce6
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, duration, w, h, round_message=None):
        """
        :param bool | None round_message:
        :param int duration:
        :param int w:
        :param int h:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.round_message = round_message
        self.duration = duration
        self.w = w
        self.h = h

    def to_dict(self, recursive=True):
        return {
            'round_message': self.round_message,
            'duration': self.duration,
            'w': self.w,
            'h': self.h,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe6,\xf0\x0e',
            struct.pack('<I', (1 if self.round_message else 0)),
            struct.pack('<i', self.duration),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _round_message = bool(flags & 1)
        _duration = reader.read_int()
        _w = reader.read_int()
        _h = reader.read_int()
        return DocumentAttributeVideo(duration=_duration, w=_w, h=_h, round_message=_round_message)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DocumentEmpty(TLObject):
    CONSTRUCTOR_ID = 0x36f8c871
    SUBCLASS_OF_ID = 0x211fe820

    def __init__(self, id):
        """
        :param int id:

        Constructor for Document: Instance of either DocumentEmpty, Document.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'q\xc8\xf86',
            struct.pack('<q', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        return DocumentEmpty(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DraftMessage(TLObject):
    CONSTRUCTOR_ID = 0xfd8e711f
    SUBCLASS_OF_ID = 0x33d47f45

    def __init__(self, message, date, no_webpage=None, reply_to_msg_id=None, entities=None):
        """
        :param bool | None no_webpage:
        :param int | None reply_to_msg_id:
        :param str message:
        :param list[TLObject] | None entities:
        :param datetime.datetime | None date:

        Constructor for DraftMessage: Instance of either DraftMessageEmpty, DraftMessage.
        """
        super().__init__()

        self.no_webpage = no_webpage
        self.reply_to_msg_id = reply_to_msg_id
        self.message = message
        self.entities = entities
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'reply_to_msg_id': self.reply_to_msg_id,
            'message': self.message,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1fq\x8e\xfd',
            struct.pack('<I', (2 if self.no_webpage else 0) | (1 if self.reply_to_msg_id else 0) | (8 if self.entities else 0)),
            b'' if not self.reply_to_msg_id else (struct.pack('<i', self.reply_to_msg_id)),
            TLObject.serialize_bytes(self.message),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _message = reader.tgread_string()
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        _date = reader.tgread_date()
        return DraftMessage(message=_message, date=_date, no_webpage=_no_webpage, reply_to_msg_id=_reply_to_msg_id, entities=_entities)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DraftMessageEmpty(TLObject):
    CONSTRUCTOR_ID = 0xba4baec5
    SUBCLASS_OF_ID = 0x33d47f45

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xc5\xaeK\xba',
        ))

    @staticmethod
    def from_reader(reader):
        return DraftMessageEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EncryptedChat(TLObject):
    CONSTRUCTOR_ID = 0xfa56ce36
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_or_b, key_fingerprint):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a_or_b:
        :param int key_fingerprint:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a_or_b = g_a_or_b
        self.key_fingerprint = key_fingerprint

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_or_b': self.g_a_or_b,
            'key_fingerprint': self.key_fingerprint,
        }

    def __bytes__(self):
        return b''.join((
            b'6\xceV\xfa',
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            TLObject.serialize_bytes(self.g_a_or_b),
            struct.pack('<q', self.key_fingerprint),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a_or_b = reader.tgread_bytes()
        _key_fingerprint = reader.read_long()
        return EncryptedChat(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a_or_b=_g_a_or_b, key_fingerprint=_key_fingerprint)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EncryptedChatDiscarded(TLObject):
    CONSTRUCTOR_ID = 0x13d6dd27
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id):
        """
        :param int id:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b"'\xdd\xd6\x13",
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        return EncryptedChatDiscarded(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EncryptedChatEmpty(TLObject):
    CONSTRUCTOR_ID = 0xab7ec0a0
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id):
        """
        :param int id:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\xc0~\xab',
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        return EncryptedChatEmpty(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EncryptedChatRequested(TLObject):
    CONSTRUCTOR_ID = 0xc878527e
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a = g_a

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a': self.g_a,
        }

    def __bytes__(self):
        return b''.join((
            b'~Rx\xc8',
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            TLObject.serialize_bytes(self.g_a),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a = reader.tgread_bytes()
        return EncryptedChatRequested(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a=_g_a)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EncryptedChatWaiting(TLObject):
    CONSTRUCTOR_ID = 0x3bf703dc
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xdc\x03\xf7;',
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        return EncryptedChatWaiting(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EncryptedFile(TLObject):
    CONSTRUCTOR_ID = 0x4a70994c
    SUBCLASS_OF_ID = 0x842a67c0

    def __init__(self, id, access_hash, size, dc_id, key_fingerprint):
        """
        :param int id:
        :param int access_hash:
        :param int size:
        :param int dc_id:
        :param int key_fingerprint:

        Constructor for EncryptedFile: Instance of either EncryptedFileEmpty, EncryptedFile.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.size = size
        self.dc_id = dc_id
        self.key_fingerprint = key_fingerprint

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'size': self.size,
            'dc_id': self.dc_id,
            'key_fingerprint': self.key_fingerprint,
        }

    def __bytes__(self):
        return b''.join((
            b'L\x99pJ',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.size),
            struct.pack('<i', self.dc_id),
            struct.pack('<i', self.key_fingerprint),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _size = reader.read_int()
        _dc_id = reader.read_int()
        _key_fingerprint = reader.read_int()
        return EncryptedFile(id=_id, access_hash=_access_hash, size=_size, dc_id=_dc_id, key_fingerprint=_key_fingerprint)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EncryptedFileEmpty(TLObject):
    CONSTRUCTOR_ID = 0xc21f497e
    SUBCLASS_OF_ID = 0x842a67c0

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'~I\x1f\xc2',
        ))

    @staticmethod
    def from_reader(reader):
        return EncryptedFileEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EncryptedMessage(TLObject):
    CONSTRUCTOR_ID = 0xed18c118
    SUBCLASS_OF_ID = 0x239f2e51

    def __init__(self, chat_id, date, bytes, file, random_id=None):
        """
        :param int random_id:
        :param int chat_id:
        :param datetime.datetime | None date:
        :param bytes bytes:
        :param TLObject file:

        Constructor for EncryptedMessage: Instance of either EncryptedMessage, EncryptedMessageService.
        """
        super().__init__()

        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.chat_id = chat_id
        self.date = date
        self.bytes = bytes
        self.file = file

    def to_dict(self, recursive=True):
        return {
            'random_id': self.random_id,
            'chat_id': self.chat_id,
            'date': self.date,
            'bytes': self.bytes,
            'file': (None if self.file is None else self.file.to_dict()) if recursive else self.file,
        }

    def __bytes__(self):
        return b''.join((
            b'\x18\xc1\x18\xed',
            struct.pack('<q', self.random_id),
            struct.pack('<i', self.chat_id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            TLObject.serialize_bytes(self.bytes),
            bytes(self.file),
        ))

    @staticmethod
    def from_reader(reader):
        _random_id = reader.read_long()
        _chat_id = reader.read_int()
        _date = reader.tgread_date()
        _bytes = reader.tgread_bytes()
        _file = reader.tgread_object()
        return EncryptedMessage(chat_id=_chat_id, date=_date, bytes=_bytes, file=_file, random_id=_random_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class EncryptedMessageService(TLObject):
    CONSTRUCTOR_ID = 0x23734b06
    SUBCLASS_OF_ID = 0x239f2e51

    def __init__(self, chat_id, date, bytes, random_id=None):
        """
        :param int random_id:
        :param int chat_id:
        :param datetime.datetime | None date:
        :param bytes bytes:

        Constructor for EncryptedMessage: Instance of either EncryptedMessage, EncryptedMessageService.
        """
        super().__init__()

        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.chat_id = chat_id
        self.date = date
        self.bytes = bytes

    def to_dict(self, recursive=True):
        return {
            'random_id': self.random_id,
            'chat_id': self.chat_id,
            'date': self.date,
            'bytes': self.bytes,
        }

    def __bytes__(self):
        return b''.join((
            b'\x06Ks#',
            struct.pack('<q', self.random_id),
            struct.pack('<i', self.chat_id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            TLObject.serialize_bytes(self.bytes),
        ))

    @staticmethod
    def from_reader(reader):
        _random_id = reader.read_long()
        _chat_id = reader.read_int()
        _date = reader.tgread_date()
        _bytes = reader.tgread_bytes()
        return EncryptedMessageService(chat_id=_chat_id, date=_date, bytes=_bytes, random_id=_random_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Error(TLObject):
    CONSTRUCTOR_ID = 0xc4b9f9bb
    SUBCLASS_OF_ID = 0x9c1c9375

    def __init__(self, code, text):
        """
        :param int code:
        :param str text:

        Constructor for Error: Instance of Error.
        """
        super().__init__()

        self.code = code
        self.text = text

    def to_dict(self, recursive=True):
        return {
            'code': self.code,
            'text': self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb\xf9\xb9\xc4',
            struct.pack('<i', self.code),
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _code = reader.read_int()
        _text = reader.tgread_string()
        return Error(code=_code, text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ExportedMessageLink(TLObject):
    CONSTRUCTOR_ID = 0x1f486803
    SUBCLASS_OF_ID = 0xdee644cc

    def __init__(self, link):
        """
        :param str link:

        Constructor for ExportedMessageLink: Instance of ExportedMessageLink.
        """
        super().__init__()

        self.link = link

    def to_dict(self, recursive=True):
        return {
            'link': self.link,
        }

    def __bytes__(self):
        return b''.join((
            b'\x03hH\x1f',
            TLObject.serialize_bytes(self.link),
        ))

    @staticmethod
    def from_reader(reader):
        _link = reader.tgread_string()
        return ExportedMessageLink(link=_link)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FileLocation(TLObject):
    CONSTRUCTOR_ID = 0x53d69076
    SUBCLASS_OF_ID = 0x90f76823

    def __init__(self, dc_id, volume_id, local_id, secret):
        """
        :param int dc_id:
        :param int volume_id:
        :param int local_id:
        :param int secret:

        Constructor for FileLocation: Instance of either FileLocationUnavailable, FileLocation.
        """
        super().__init__()

        self.dc_id = dc_id
        self.volume_id = volume_id
        self.local_id = local_id
        self.secret = secret

    def to_dict(self, recursive=True):
        return {
            'dc_id': self.dc_id,
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret,
        }

    def __bytes__(self):
        return b''.join((
            b'v\x90\xd6S',
            struct.pack('<i', self.dc_id),
            struct.pack('<q', self.volume_id),
            struct.pack('<i', self.local_id),
            struct.pack('<q', self.secret),
        ))

    @staticmethod
    def from_reader(reader):
        _dc_id = reader.read_int()
        _volume_id = reader.read_long()
        _local_id = reader.read_int()
        _secret = reader.read_long()
        return FileLocation(dc_id=_dc_id, volume_id=_volume_id, local_id=_local_id, secret=_secret)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FileLocationUnavailable(TLObject):
    CONSTRUCTOR_ID = 0x7c596b46
    SUBCLASS_OF_ID = 0x90f76823

    def __init__(self, volume_id, local_id, secret):
        """
        :param int volume_id:
        :param int local_id:
        :param int secret:

        Constructor for FileLocation: Instance of either FileLocationUnavailable, FileLocation.
        """
        super().__init__()

        self.volume_id = volume_id
        self.local_id = local_id
        self.secret = secret

    def to_dict(self, recursive=True):
        return {
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret,
        }

    def __bytes__(self):
        return b''.join((
            b'FkY|',
            struct.pack('<q', self.volume_id),
            struct.pack('<i', self.local_id),
            struct.pack('<q', self.secret),
        ))

    @staticmethod
    def from_reader(reader):
        _volume_id = reader.read_long()
        _local_id = reader.read_int()
        _secret = reader.read_long()
        return FileLocationUnavailable(volume_id=_volume_id, local_id=_local_id, secret=_secret)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FoundGif(TLObject):
    CONSTRUCTOR_ID = 0x162ecc1f
    SUBCLASS_OF_ID = 0x5bbc92c3

    def __init__(self, url, thumb_url, content_url, content_type, w, h):
        """
        :param str url:
        :param str thumb_url:
        :param str content_url:
        :param str content_type:
        :param int w:
        :param int h:

        Constructor for FoundGif: Instance of either FoundGif, FoundGifCached.
        """
        super().__init__()

        self.url = url
        self.thumb_url = thumb_url
        self.content_url = content_url
        self.content_type = content_type
        self.w = w
        self.h = h

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'thumb_url': self.thumb_url,
            'content_url': self.content_url,
            'content_type': self.content_type,
            'w': self.w,
            'h': self.h,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\xcc.\x16',
            TLObject.serialize_bytes(self.url),
            TLObject.serialize_bytes(self.thumb_url),
            TLObject.serialize_bytes(self.content_url),
            TLObject.serialize_bytes(self.content_type),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _thumb_url = reader.tgread_string()
        _content_url = reader.tgread_string()
        _content_type = reader.tgread_string()
        _w = reader.read_int()
        _h = reader.read_int()
        return FoundGif(url=_url, thumb_url=_thumb_url, content_url=_content_url, content_type=_content_type, w=_w, h=_h)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FoundGifCached(TLObject):
    CONSTRUCTOR_ID = 0x9c750409
    SUBCLASS_OF_ID = 0x5bbc92c3

    def __init__(self, url, photo, document):
        """
        :param str url:
        :param TLObject photo:
        :param TLObject document:

        Constructor for FoundGif: Instance of either FoundGif, FoundGifCached.
        """
        super().__init__()

        self.url = url
        self.photo = photo
        self.document = document

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'document': (None if self.document is None else self.document.to_dict()) if recursive else self.document,
        }

    def __bytes__(self):
        return b''.join((
            b'\t\x04u\x9c',
            TLObject.serialize_bytes(self.url),
            bytes(self.photo),
            bytes(self.document),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _photo = reader.tgread_object()
        _document = reader.tgread_object()
        return FoundGifCached(url=_url, photo=_photo, document=_document)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FutureSalt(TLObject):
    CONSTRUCTOR_ID = 0x949d9dc
    SUBCLASS_OF_ID = 0x45e53dcf

    def __init__(self, valid_since, valid_until, salt):
        """
        :param int valid_since:
        :param int valid_until:
        :param int salt:

        Constructor for FutureSalt: Instance of FutureSalt.
        """
        super().__init__()

        self.valid_since = valid_since
        self.valid_until = valid_until
        self.salt = salt

    def to_dict(self, recursive=True):
        return {
            'valid_since': self.valid_since,
            'valid_until': self.valid_until,
            'salt': self.salt,
        }

    def __bytes__(self):
        return b''.join((
            b'\xdc\xd9I\t',
            struct.pack('<i', self.valid_since),
            struct.pack('<i', self.valid_until),
            struct.pack('<q', self.salt),
        ))

    @staticmethod
    def from_reader(reader):
        _valid_since = reader.read_int()
        _valid_until = reader.read_int()
        _salt = reader.read_long()
        return FutureSalt(valid_since=_valid_since, valid_until=_valid_until, salt=_salt)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FutureSalts(TLObject):
    CONSTRUCTOR_ID = 0xae500895
    SUBCLASS_OF_ID = 0x1090f517

    def __init__(self, req_msg_id, now, salts):
        """
        :param int req_msg_id:
        :param int now:
        :param list[TLObject] salts:

        Constructor for FutureSalts: Instance of FutureSalts.
        """
        super().__init__()

        self.req_msg_id = req_msg_id
        self.now = now
        self.salts = salts

    def to_dict(self, recursive=True):
        return {
            'req_msg_id': self.req_msg_id,
            'now': self.now,
            'salts': ([] if self.salts is None else [None if x is None else x.to_dict() for x in self.salts]) if recursive else self.salts,
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\x08P\xae',
            struct.pack('<q', self.req_msg_id),
            struct.pack('<i', self.now),
            struct.pack('<i', len(self.salts)),b''.join(bytes(x) for x in self.salts),
        ))

    @staticmethod
    def from_reader(reader):
        _req_msg_id = reader.read_long()
        _now = reader.read_int()
        _salts = []
        for _ in range(reader.read_int()):
            _x = types.FutureSalt.from_reader(reader)
            _salts.append(_x)

        return FutureSalts(req_msg_id=_req_msg_id, now=_now, salts=_salts)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Game(TLObject):
    CONSTRUCTOR_ID = 0xbdf9653b
    SUBCLASS_OF_ID = 0x83199eb2

    def __init__(self, id, access_hash, short_name, title, description, photo, document=None):
        """
        :param int id:
        :param int access_hash:
        :param str short_name:
        :param str title:
        :param str description:
        :param TLObject photo:
        :param TLObject | None document:

        Constructor for Game: Instance of Game.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.short_name = short_name
        self.title = title
        self.description = description
        self.photo = photo
        self.document = document

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'short_name': self.short_name,
            'title': self.title,
            'description': self.description,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'document': (None if self.document is None else self.document.to_dict()) if recursive else self.document,
        }

    def __bytes__(self):
        return b''.join((
            b';e\xf9\xbd',
            struct.pack('<I', (1 if self.document else 0)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_bytes(self.short_name),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.description),
            bytes(self.photo),
            b'' if not self.document else (bytes(self.document)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.read_long()
        _access_hash = reader.read_long()
        _short_name = reader.tgread_string()
        _title = reader.tgread_string()
        _description = reader.tgread_string()
        _photo = reader.tgread_object()
        if flags & 1:
            _document = reader.tgread_object()
        else:
            _document = None
        return Game(id=_id, access_hash=_access_hash, short_name=_short_name, title=_title, description=_description, photo=_photo, document=_document)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GeoPoint(TLObject):
    CONSTRUCTOR_ID = 0x2049d70c
    SUBCLASS_OF_ID = 0xd610e16d

    def __init__(self, long, lat):
        """
        :param TLObject long:
        :param TLObject lat:

        Constructor for GeoPoint: Instance of either GeoPointEmpty, GeoPoint.
        """
        super().__init__()

        self.long = long
        self.lat = lat

    def to_dict(self, recursive=True):
        return {
            'long': self.long,
            'lat': self.lat,
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c\xd7I ',
            struct.pack('<d', self.long),
            struct.pack('<d', self.lat),
        ))

    @staticmethod
    def from_reader(reader):
        _long = reader.read_double()
        _lat = reader.read_double()
        return GeoPoint(long=_long, lat=_lat)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class GeoPointEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1117dd5f
    SUBCLASS_OF_ID = 0xd610e16d

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'_\xdd\x17\x11',
        ))

    @staticmethod
    def from_reader(reader):
        return GeoPointEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class HighScore(TLObject):
    CONSTRUCTOR_ID = 0x58fffcd0
    SUBCLASS_OF_ID = 0xd32b1e35

    def __init__(self, pos, user_id, score):
        """
        :param int pos:
        :param int user_id:
        :param int score:

        Constructor for HighScore: Instance of HighScore.
        """
        super().__init__()

        self.pos = pos
        self.user_id = user_id
        self.score = score

    def to_dict(self, recursive=True):
        return {
            'pos': self.pos,
            'user_id': self.user_id,
            'score': self.score,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd0\xfc\xffX',
            struct.pack('<i', self.pos),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.score),
        ))

    @staticmethod
    def from_reader(reader):
        _pos = reader.read_int()
        _user_id = reader.read_int()
        _score = reader.read_int()
        return HighScore(pos=_pos, user_id=_user_id, score=_score)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class HttpWait(TLObject):
    CONSTRUCTOR_ID = 0x9299359f
    SUBCLASS_OF_ID = 0x1284aed6

    def __init__(self, max_delay, wait_after, max_wait):
        """
        :param int max_delay:
        :param int wait_after:
        :param int max_wait:

        Constructor for HttpWait: Instance of HttpWait.
        """
        super().__init__()

        self.max_delay = max_delay
        self.wait_after = wait_after
        self.max_wait = max_wait

    def to_dict(self, recursive=True):
        return {
            'max_delay': self.max_delay,
            'wait_after': self.wait_after,
            'max_wait': self.max_wait,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9f5\x99\x92',
            struct.pack('<i', self.max_delay),
            struct.pack('<i', self.wait_after),
            struct.pack('<i', self.max_wait),
        ))

    @staticmethod
    def from_reader(reader):
        _max_delay = reader.read_int()
        _wait_after = reader.read_int()
        _max_wait = reader.read_int()
        return HttpWait(max_delay=_max_delay, wait_after=_wait_after, max_wait=_max_wait)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ImportedContact(TLObject):
    CONSTRUCTOR_ID = 0xd0028438
    SUBCLASS_OF_ID = 0xb545bbda

    def __init__(self, user_id, client_id):
        """
        :param int user_id:
        :param int client_id:

        Constructor for ImportedContact: Instance of ImportedContact.
        """
        super().__init__()

        self.user_id = user_id
        self.client_id = client_id

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'client_id': self.client_id,
        }

    def __bytes__(self):
        return b''.join((
            b'8\x84\x02\xd0',
            struct.pack('<i', self.user_id),
            struct.pack('<q', self.client_id),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _client_id = reader.read_long()
        return ImportedContact(user_id=_user_id, client_id=_client_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InlineBotSwitchPM(TLObject):
    CONSTRUCTOR_ID = 0x3c20629f
    SUBCLASS_OF_ID = 0x82b1f73b

    def __init__(self, text, start_param):
        """
        :param str text:
        :param str start_param:

        Constructor for InlineBotSwitchPM: Instance of InlineBotSwitchPM.
        """
        super().__init__()

        self.text = text
        self.start_param = start_param

    def to_dict(self, recursive=True):
        return {
            'text': self.text,
            'start_param': self.start_param,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9fb <',
            TLObject.serialize_bytes(self.text),
            TLObject.serialize_bytes(self.start_param),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        _start_param = reader.tgread_string()
        return InlineBotSwitchPM(text=_text, start_param=_start_param)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputAppEvent(TLObject):
    CONSTRUCTOR_ID = 0x770656a8
    SUBCLASS_OF_ID = 0x89322106

    def __init__(self, time, type, peer, data):
        """
        :param TLObject time:
        :param str type:
        :param int peer:
        :param str data:

        Constructor for InputAppEvent: Instance of InputAppEvent.
        """
        super().__init__()

        self.time = time
        self.type = type
        self.peer = peer
        self.data = data

    def to_dict(self, recursive=True):
        return {
            'time': self.time,
            'type': self.type,
            'peer': self.peer,
            'data': self.data,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa8V\x06w',
            struct.pack('<d', self.time),
            TLObject.serialize_bytes(self.type),
            struct.pack('<q', self.peer),
            TLObject.serialize_bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        _time = reader.read_double()
        _type = reader.tgread_string()
        _peer = reader.read_long()
        _data = reader.tgread_string()
        return InputAppEvent(time=_time, type=_type, peer=_peer, data=_data)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineMessageGame(TLObject):
    CONSTRUCTOR_ID = 0x4b425864
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, reply_markup=None):
        """
        :param TLObject | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'dXBK',
            struct.pack('<I', (4 if self.reply_markup else 0)),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageGame(reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineMessageID(TLObject):
    CONSTRUCTOR_ID = 0x890c3d89
    SUBCLASS_OF_ID = 0x2dcd6300

    def __init__(self, dc_id, id, access_hash):
        """
        :param int dc_id:
        :param int id:
        :param int access_hash:

        Constructor for InputBotInlineMessageID: Instance of InputBotInlineMessageID.
        """
        super().__init__()

        self.dc_id = dc_id
        self.id = id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'dc_id': self.dc_id,
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\x89=\x0c\x89',
            struct.pack('<i', self.dc_id),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _dc_id = reader.read_int()
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputBotInlineMessageID(dc_id=_dc_id, id=_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineMessageMediaAuto(TLObject):
    CONSTRUCTOR_ID = 0x292fed13
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, caption, reply_markup=None):
        """
        :param str caption:
        :param TLObject | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.caption = caption
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'caption': self.caption,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'\x13\xed/)',
            struct.pack('<I', (4 if self.reply_markup else 0)),
            TLObject.serialize_bytes(self.caption),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _caption = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageMediaAuto(caption=_caption, reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineMessageMediaContact(TLObject):
    CONSTRUCTOR_ID = 0x2daf01a7
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, phone_number, first_name, last_name, reply_markup=None):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:
        :param TLObject | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa7\x01\xaf-',
            struct.pack('<I', (4 if self.reply_markup else 0)),
            TLObject.serialize_bytes(self.phone_number),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageMediaContact(phone_number=_phone_number, first_name=_first_name, last_name=_last_name, reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineMessageMediaGeo(TLObject):
    CONSTRUCTOR_ID = 0xf4a59de1
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, geo_point, reply_markup=None):
        """
        :param TLObject geo_point:
        :param TLObject | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.geo_point = geo_point
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'geo_point': (None if self.geo_point is None else self.geo_point.to_dict()) if recursive else self.geo_point,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\x9d\xa5\xf4',
            struct.pack('<I', (4 if self.reply_markup else 0)),
            bytes(self.geo_point),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _geo_point = reader.tgread_object()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageMediaGeo(geo_point=_geo_point, reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineMessageMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0xaaafadc8
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, geo_point, title, address, provider, venue_id, reply_markup=None):
        """
        :param TLObject geo_point:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:
        :param TLObject | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.geo_point = geo_point
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'geo_point': (None if self.geo_point is None else self.geo_point.to_dict()) if recursive else self.geo_point,
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8\xad\xaf\xaa',
            struct.pack('<I', (4 if self.reply_markup else 0)),
            bytes(self.geo_point),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.address),
            TLObject.serialize_bytes(self.provider),
            TLObject.serialize_bytes(self.venue_id),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _geo_point = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageMediaVenue(geo_point=_geo_point, title=_title, address=_address, provider=_provider, venue_id=_venue_id, reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineMessageText(TLObject):
    CONSTRUCTOR_ID = 0x3dcd7a87
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, message, no_webpage=None, entities=None, reply_markup=None):
        """
        :param bool | None no_webpage:
        :param str message:
        :param list[TLObject] | None entities:
        :param TLObject | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.no_webpage = no_webpage
        self.message = message
        self.entities = entities
        self.reply_markup = reply_markup

    def to_dict(self, recursive=True):
        return {
            'no_webpage': self.no_webpage,
            'message': self.message,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
        }

    def __bytes__(self):
        return b''.join((
            b'\x87z\xcd=',
            struct.pack('<I', (1 if self.no_webpage else 0) | (2 if self.entities else 0) | (4 if self.reply_markup else 0)),
            TLObject.serialize_bytes(self.message),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 1)
        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageText(message=_message, no_webpage=_no_webpage, entities=_entities, reply_markup=_reply_markup)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineResult(TLObject):
    CONSTRUCTOR_ID = 0x2cbbe15a
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, type, send_message, title=None, description=None, url=None, thumb_url=None, content_url=None, content_type=None, w=None, h=None, duration=None):
        """
        :param str id:
        :param str type:
        :param str | None title:
        :param str | None description:
        :param str | None url:
        :param str | None thumb_url:
        :param str | None content_url:
        :param str | None content_type:
        :param int | None w:
        :param int | None h:
        :param int | None duration:
        :param TLObject send_message:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.url = url
        self.thumb_url = thumb_url
        self.content_url = content_url
        self.content_type = content_type
        self.w = w
        self.h = h
        self.duration = duration
        self.send_message = send_message

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'type': self.type,
            'title': self.title,
            'description': self.description,
            'url': self.url,
            'thumb_url': self.thumb_url,
            'content_url': self.content_url,
            'content_type': self.content_type,
            'w': self.w,
            'h': self.h,
            'duration': self.duration,
            'send_message': (None if self.send_message is None else self.send_message.to_dict()) if recursive else self.send_message,
        }

    def __bytes__(self):
        assert (self.content_url is None and self.content_type is None) or (self.content_url is not None and self.content_type is not None), 'content_url, content_type parameters must all be None or neither be None'
        assert (self.w is None and self.h is None) or (self.w is not None and self.h is not None), 'w, h parameters must all be None or neither be None'
        return b''.join((
            b'Z\xe1\xbb,',
            struct.pack('<I', (2 if self.title else 0) | (4 if self.description else 0) | (8 if self.url else 0) | (16 if self.thumb_url else 0) | (32 if self.content_url else 0) | (32 if self.content_type else 0) | (64 if self.w else 0) | (64 if self.h else 0) | (128 if self.duration else 0)),
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.type),
            b'' if not self.title else (TLObject.serialize_bytes(self.title)),
            b'' if not self.description else (TLObject.serialize_bytes(self.description)),
            b'' if not self.url else (TLObject.serialize_bytes(self.url)),
            b'' if not self.thumb_url else (TLObject.serialize_bytes(self.thumb_url)),
            b'' if not self.content_url else (TLObject.serialize_bytes(self.content_url)),
            b'' if not self.content_type else (TLObject.serialize_bytes(self.content_type)),
            b'' if not self.w else (struct.pack('<i', self.w)),
            b'' if not self.h else (struct.pack('<i', self.h)),
            b'' if not self.duration else (struct.pack('<i', self.duration)),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 2:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 4:
            _description = reader.tgread_string()
        else:
            _description = None
        if flags & 8:
            _url = reader.tgread_string()
        else:
            _url = None
        if flags & 16:
            _thumb_url = reader.tgread_string()
        else:
            _thumb_url = None
        if flags & 32:
            _content_url = reader.tgread_string()
        else:
            _content_url = None
        if flags & 32:
            _content_type = reader.tgread_string()
        else:
            _content_type = None
        if flags & 64:
            _w = reader.read_int()
        else:
            _w = None
        if flags & 64:
            _h = reader.read_int()
        else:
            _h = None
        if flags & 128:
            _duration = reader.read_int()
        else:
            _duration = None
        _send_message = reader.tgread_object()
        return InputBotInlineResult(id=_id, type=_type, send_message=_send_message, title=_title, description=_description, url=_url, thumb_url=_thumb_url, content_url=_content_url, content_type=_content_type, w=_w, h=_h, duration=_duration)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineResultDocument(TLObject):
    CONSTRUCTOR_ID = 0xfff8fdc4
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, type, document, send_message, title=None, description=None):
        """
        :param str id:
        :param str type:
        :param str | None title:
        :param str | None description:
        :param TLObject document:
        :param TLObject send_message:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.document = document
        self.send_message = send_message

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'type': self.type,
            'title': self.title,
            'description': self.description,
            'document': (None if self.document is None else self.document.to_dict()) if recursive else self.document,
            'send_message': (None if self.send_message is None else self.send_message.to_dict()) if recursive else self.send_message,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4\xfd\xf8\xff',
            struct.pack('<I', (2 if self.title else 0) | (4 if self.description else 0)),
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.type),
            b'' if not self.title else (TLObject.serialize_bytes(self.title)),
            b'' if not self.description else (TLObject.serialize_bytes(self.description)),
            bytes(self.document),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 2:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 4:
            _description = reader.tgread_string()
        else:
            _description = None
        _document = reader.tgread_object()
        _send_message = reader.tgread_object()
        return InputBotInlineResultDocument(id=_id, type=_type, document=_document, send_message=_send_message, title=_title, description=_description)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineResultGame(TLObject):
    CONSTRUCTOR_ID = 0x4fa417f2
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, short_name, send_message):
        """
        :param str id:
        :param str short_name:
        :param TLObject send_message:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id
        self.short_name = short_name
        self.send_message = send_message

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'short_name': self.short_name,
            'send_message': (None if self.send_message is None else self.send_message.to_dict()) if recursive else self.send_message,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf2\x17\xa4O',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.short_name),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _short_name = reader.tgread_string()
        _send_message = reader.tgread_object()
        return InputBotInlineResultGame(id=_id, short_name=_short_name, send_message=_send_message)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputBotInlineResultPhoto(TLObject):
    CONSTRUCTOR_ID = 0xa8d864a7
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, type, photo, send_message):
        """
        :param str id:
        :param str type:
        :param TLObject photo:
        :param TLObject send_message:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id
        self.type = type
        self.photo = photo
        self.send_message = send_message

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'type': self.type,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'send_message': (None if self.send_message is None else self.send_message.to_dict()) if recursive else self.send_message,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa7d\xd8\xa8',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.type),
            bytes(self.photo),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _type = reader.tgread_string()
        _photo = reader.tgread_object()
        _send_message = reader.tgread_object()
        return InputBotInlineResultPhoto(id=_id, type=_type, photo=_photo, send_message=_send_message)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputChannel(TLObject):
    CONSTRUCTOR_ID = 0xafeb712e
    SUBCLASS_OF_ID = 0x40f202fd

    def __init__(self, channel_id, access_hash):
        """
        :param int channel_id:
        :param int access_hash:

        Constructor for InputChannel: Instance of either InputChannelEmpty, InputChannel.
        """
        super().__init__()

        self.channel_id = channel_id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'.q\xeb\xaf',
            struct.pack('<i', self.channel_id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _access_hash = reader.read_long()
        return InputChannel(channel_id=_channel_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputChannelEmpty(TLObject):
    CONSTRUCTOR_ID = 0xee8c1e86
    SUBCLASS_OF_ID = 0x40f202fd

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x86\x1e\x8c\xee',
        ))

    @staticmethod
    def from_reader(reader):
        return InputChannelEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputChatPhoto(TLObject):
    CONSTRUCTOR_ID = 0x8953ad37
    SUBCLASS_OF_ID = 0xd4eb2d74

    def __init__(self, id):
        """
        :param TLObject id:

        Constructor for InputChatPhoto: Instance of either InputChatPhotoEmpty, InputChatUploadedPhoto, InputChatPhoto.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'7\xadS\x89',
            bytes(self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        return InputChatPhoto(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputChatPhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1ca48f57
    SUBCLASS_OF_ID = 0xd4eb2d74

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'W\x8f\xa4\x1c',
        ))

    @staticmethod
    def from_reader(reader):
        return InputChatPhotoEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputChatUploadedPhoto(TLObject):
    CONSTRUCTOR_ID = 0x927c55b4
    SUBCLASS_OF_ID = 0xd4eb2d74

    def __init__(self, file):
        """
        :param TLObject file:

        Constructor for InputChatPhoto: Instance of either InputChatPhotoEmpty, InputChatUploadedPhoto, InputChatPhoto.
        """
        super().__init__()

        self.file = file

    def to_dict(self, recursive=True):
        return {
            'file': (None if self.file is None else self.file.to_dict()) if recursive else self.file,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb4U|\x92',
            bytes(self.file),
        ))

    @staticmethod
    def from_reader(reader):
        _file = reader.tgread_object()
        return InputChatUploadedPhoto(file=_file)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputDocument(TLObject):
    CONSTRUCTOR_ID = 0x18798952
    SUBCLASS_OF_ID = 0xf33fdb68

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputDocument: Instance of either InputDocumentEmpty, InputDocument.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'R\x89y\x18',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputDocument(id=_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputDocumentEmpty(TLObject):
    CONSTRUCTOR_ID = 0x72f0eaae
    SUBCLASS_OF_ID = 0xf33fdb68

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xae\xea\xf0r',
        ))

    @staticmethod
    def from_reader(reader):
        return InputDocumentEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputDocumentFileLocation(TLObject):
    CONSTRUCTOR_ID = 0x430f0724
    SUBCLASS_OF_ID = 0x1523d462

    def __init__(self, id, access_hash, version):
        """
        :param int id:
        :param int access_hash:
        :param int version:

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.version = version

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'version': self.version,
        }

    def __bytes__(self):
        return b''.join((
            b'$\x07\x0fC',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _version = reader.read_int()
        return InputDocumentFileLocation(id=_id, access_hash=_access_hash, version=_version)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputEncryptedChat(TLObject):
    CONSTRUCTOR_ID = 0xf141b5e1
    SUBCLASS_OF_ID = 0x6c7606c0

    def __init__(self, chat_id, access_hash):
        """
        :param int chat_id:
        :param int access_hash:

        Constructor for InputEncryptedChat: Instance of InputEncryptedChat.
        """
        super().__init__()

        self.chat_id = chat_id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xb5A\xf1',
            struct.pack('<i', self.chat_id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _access_hash = reader.read_long()
        return InputEncryptedChat(chat_id=_chat_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputEncryptedFile(TLObject):
    CONSTRUCTOR_ID = 0x5a17b5e5
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe5\xb5\x17Z',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputEncryptedFile(id=_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputEncryptedFileBigUploaded(TLObject):
    CONSTRUCTOR_ID = 0x2dc173c8
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self, id, parts, key_fingerprint):
        """
        :param int id:
        :param int parts:
        :param int key_fingerprint:

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        super().__init__()

        self.id = id
        self.parts = parts
        self.key_fingerprint = key_fingerprint

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'parts': self.parts,
            'key_fingerprint': self.key_fingerprint,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8s\xc1-',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            struct.pack('<i', self.key_fingerprint),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _key_fingerprint = reader.read_int()
        return InputEncryptedFileBigUploaded(id=_id, parts=_parts, key_fingerprint=_key_fingerprint)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputEncryptedFileEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1837c364
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'd\xc37\x18',
        ))

    @staticmethod
    def from_reader(reader):
        return InputEncryptedFileEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputEncryptedFileLocation(TLObject):
    CONSTRUCTOR_ID = 0xf5235d55
    SUBCLASS_OF_ID = 0x1523d462

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'U]#\xf5',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputEncryptedFileLocation(id=_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputEncryptedFileUploaded(TLObject):
    CONSTRUCTOR_ID = 0x64bd0306
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self, id, parts, md5_checksum, key_fingerprint):
        """
        :param int id:
        :param int parts:
        :param str md5_checksum:
        :param int key_fingerprint:

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        super().__init__()

        self.id = id
        self.parts = parts
        self.md5_checksum = md5_checksum
        self.key_fingerprint = key_fingerprint

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'parts': self.parts,
            'md5_checksum': self.md5_checksum,
            'key_fingerprint': self.key_fingerprint,
        }

    def __bytes__(self):
        return b''.join((
            b'\x06\x03\xbdd',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            TLObject.serialize_bytes(self.md5_checksum),
            struct.pack('<i', self.key_fingerprint),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _md5_checksum = reader.tgread_string()
        _key_fingerprint = reader.read_int()
        return InputEncryptedFileUploaded(id=_id, parts=_parts, md5_checksum=_md5_checksum, key_fingerprint=_key_fingerprint)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputFile(TLObject):
    CONSTRUCTOR_ID = 0xf52ff27f
    SUBCLASS_OF_ID = 0xe7655f1f

    def __init__(self, id, parts, name, md5_checksum):
        """
        :param int id:
        :param int parts:
        :param str name:
        :param str md5_checksum:

        Constructor for InputFile: Instance of either InputFile, InputFileBig.
        """
        super().__init__()

        self.id = id
        self.parts = parts
        self.name = name
        self.md5_checksum = md5_checksum

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'parts': self.parts,
            'name': self.name,
            'md5_checksum': self.md5_checksum,
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xf2/\xf5',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            TLObject.serialize_bytes(self.name),
            TLObject.serialize_bytes(self.md5_checksum),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _name = reader.tgread_string()
        _md5_checksum = reader.tgread_string()
        return InputFile(id=_id, parts=_parts, name=_name, md5_checksum=_md5_checksum)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputFileBig(TLObject):
    CONSTRUCTOR_ID = 0xfa4f0bb5
    SUBCLASS_OF_ID = 0xe7655f1f

    def __init__(self, id, parts, name):
        """
        :param int id:
        :param int parts:
        :param str name:

        Constructor for InputFile: Instance of either InputFile, InputFileBig.
        """
        super().__init__()

        self.id = id
        self.parts = parts
        self.name = name

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'parts': self.parts,
            'name': self.name,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb5\x0bO\xfa',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            TLObject.serialize_bytes(self.name),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _name = reader.tgread_string()
        return InputFileBig(id=_id, parts=_parts, name=_name)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputFileLocation(TLObject):
    CONSTRUCTOR_ID = 0x14637196
    SUBCLASS_OF_ID = 0x1523d462

    def __init__(self, volume_id, local_id, secret):
        """
        :param int volume_id:
        :param int local_id:
        :param int secret:

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation.
        """
        super().__init__()

        self.volume_id = volume_id
        self.local_id = local_id
        self.secret = secret

    def to_dict(self, recursive=True):
        return {
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret,
        }

    def __bytes__(self):
        return b''.join((
            b'\x96qc\x14',
            struct.pack('<q', self.volume_id),
            struct.pack('<i', self.local_id),
            struct.pack('<q', self.secret),
        ))

    @staticmethod
    def from_reader(reader):
        _volume_id = reader.read_long()
        _local_id = reader.read_int()
        _secret = reader.read_long()
        return InputFileLocation(volume_id=_volume_id, local_id=_local_id, secret=_secret)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputGameID(TLObject):
    CONSTRUCTOR_ID = 0x32c3e77
    SUBCLASS_OF_ID = 0x48d15883

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputGame: Instance of either InputGameID, InputGameShortName.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'w>,\x03',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputGameID(id=_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputGameShortName(TLObject):
    CONSTRUCTOR_ID = 0xc331e80a
    SUBCLASS_OF_ID = 0x48d15883

    def __init__(self, bot_id, short_name):
        """
        :param TLObject bot_id:
        :param str short_name:

        Constructor for InputGame: Instance of either InputGameID, InputGameShortName.
        """
        super().__init__()

        self.bot_id = bot_id
        self.short_name = short_name

    def to_dict(self, recursive=True):
        return {
            'bot_id': (None if self.bot_id is None else self.bot_id.to_dict()) if recursive else self.bot_id,
            'short_name': self.short_name,
        }

    def __bytes__(self):
        return b''.join((
            b'\n\xe81\xc3',
            bytes(self.bot_id),
            TLObject.serialize_bytes(self.short_name),
        ))

    @staticmethod
    def from_reader(reader):
        _bot_id = reader.tgread_object()
        _short_name = reader.tgread_string()
        return InputGameShortName(bot_id=_bot_id, short_name=_short_name)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputGeoPoint(TLObject):
    CONSTRUCTOR_ID = 0xf3b7acc9
    SUBCLASS_OF_ID = 0x430d225

    def __init__(self, lat, long):
        """
        :param TLObject lat:
        :param TLObject long:

        Constructor for InputGeoPoint: Instance of either InputGeoPointEmpty, InputGeoPoint.
        """
        super().__init__()

        self.lat = lat
        self.long = long

    def to_dict(self, recursive=True):
        return {
            'lat': self.lat,
            'long': self.long,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9\xac\xb7\xf3',
            struct.pack('<d', self.lat),
            struct.pack('<d', self.long),
        ))

    @staticmethod
    def from_reader(reader):
        _lat = reader.read_double()
        _long = reader.read_double()
        return InputGeoPoint(lat=_lat, long=_long)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputGeoPointEmpty(TLObject):
    CONSTRUCTOR_ID = 0xe4c123d6
    SUBCLASS_OF_ID = 0x430d225

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xd6#\xc1\xe4',
        ))

    @staticmethod
    def from_reader(reader):
        return InputGeoPointEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaContact(TLObject):
    CONSTRUCTOR_ID = 0xa6e45987
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, phone_number, first_name, last_name):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name

    def to_dict(self, recursive=True):
        return {
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
        }

    def __bytes__(self):
        return b''.join((
            b'\x87Y\xe4\xa6',
            TLObject.serialize_bytes(self.phone_number),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
        ))

    @staticmethod
    def from_reader(reader):
        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        return InputMediaContact(phone_number=_phone_number, first_name=_first_name, last_name=_last_name)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaDocument(TLObject):
    CONSTRUCTOR_ID = 0x5acb668e
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, id, caption, ttl_seconds=None):
        """
        :param TLObject id:
        :param str caption:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.id = id
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def __bytes__(self):
        return b''.join((
            b'\x8ef\xcbZ',
            struct.pack('<I', (1 if self.ttl_seconds else 0)),
            bytes(self.id),
            TLObject.serialize_bytes(self.caption),
            b'' if not self.ttl_seconds else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_object()
        _caption = reader.tgread_string()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaDocument(id=_id, caption=_caption, ttl_seconds=_ttl_seconds)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaDocumentExternal(TLObject):
    CONSTRUCTOR_ID = 0xb6f74335
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, url, caption, ttl_seconds=None):
        """
        :param str url:
        :param str caption:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.url = url
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def __bytes__(self):
        return b''.join((
            b'5C\xf7\xb6',
            struct.pack('<I', (1 if self.ttl_seconds else 0)),
            TLObject.serialize_bytes(self.url),
            TLObject.serialize_bytes(self.caption),
            b'' if not self.ttl_seconds else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _url = reader.tgread_string()
        _caption = reader.tgread_string()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaDocumentExternal(url=_url, caption=_caption, ttl_seconds=_ttl_seconds)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaEmpty(TLObject):
    CONSTRUCTOR_ID = 0x9664f57f
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x7f\xf5d\x96',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMediaEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaGame(TLObject):
    CONSTRUCTOR_ID = 0xd33f43f3
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, id):
        """
        :param TLObject id:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf3C?\xd3',
            bytes(self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        return InputMediaGame(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaGeoPoint(TLObject):
    CONSTRUCTOR_ID = 0xf9c44144
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, geo_point):
        """
        :param TLObject geo_point:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.geo_point = geo_point

    def to_dict(self, recursive=True):
        return {
            'geo_point': (None if self.geo_point is None else self.geo_point.to_dict()) if recursive else self.geo_point,
        }

    def __bytes__(self):
        return b''.join((
            b'DA\xc4\xf9',
            bytes(self.geo_point),
        ))

    @staticmethod
    def from_reader(reader):
        _geo_point = reader.tgread_object()
        return InputMediaGeoPoint(geo_point=_geo_point)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaGifExternal(TLObject):
    CONSTRUCTOR_ID = 0x4843b0fd
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, url, q):
        """
        :param str url:
        :param str q:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.url = url
        self.q = q

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'q': self.q,
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\xb0CH',
            TLObject.serialize_bytes(self.url),
            TLObject.serialize_bytes(self.q),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _q = reader.tgread_string()
        return InputMediaGifExternal(url=_url, q=_q)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaInvoice(TLObject):
    CONSTRUCTOR_ID = 0x92153685
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, title, description, invoice, payload, provider, start_param, photo=None):
        """
        :param str title:
        :param str description:
        :param TLObject | None photo:
        :param TLObject invoice:
        :param bytes payload:
        :param str provider:
        :param str start_param:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.title = title
        self.description = description
        self.photo = photo
        self.invoice = invoice
        self.payload = payload
        self.provider = provider
        self.start_param = start_param

    def to_dict(self, recursive=True):
        return {
            'title': self.title,
            'description': self.description,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'invoice': (None if self.invoice is None else self.invoice.to_dict()) if recursive else self.invoice,
            'payload': self.payload,
            'provider': self.provider,
            'start_param': self.start_param,
        }

    def __bytes__(self):
        return b''.join((
            b'\x856\x15\x92',
            struct.pack('<I', (1 if self.photo else 0)),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.description),
            b'' if not self.photo else (bytes(self.photo)),
            bytes(self.invoice),
            TLObject.serialize_bytes(self.payload),
            TLObject.serialize_bytes(self.provider),
            TLObject.serialize_bytes(self.start_param),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _title = reader.tgread_string()
        _description = reader.tgread_string()
        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        _invoice = reader.tgread_object()
        _payload = reader.tgread_bytes()
        _provider = reader.tgread_string()
        _start_param = reader.tgread_string()
        return InputMediaInvoice(title=_title, description=_description, invoice=_invoice, payload=_payload, provider=_provider, start_param=_start_param, photo=_photo)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaPhoto(TLObject):
    CONSTRUCTOR_ID = 0x81fa373a
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, id, caption, ttl_seconds=None):
        """
        :param TLObject id:
        :param str caption:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.id = id
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def __bytes__(self):
        return b''.join((
            b':7\xfa\x81',
            struct.pack('<I', (1 if self.ttl_seconds else 0)),
            bytes(self.id),
            TLObject.serialize_bytes(self.caption),
            b'' if not self.ttl_seconds else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_object()
        _caption = reader.tgread_string()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaPhoto(id=_id, caption=_caption, ttl_seconds=_ttl_seconds)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaPhotoExternal(TLObject):
    CONSTRUCTOR_ID = 0x922aec1
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, url, caption, ttl_seconds=None):
        """
        :param str url:
        :param str caption:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.url = url
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc1\xae"\t',
            struct.pack('<I', (1 if self.ttl_seconds else 0)),
            TLObject.serialize_bytes(self.url),
            TLObject.serialize_bytes(self.caption),
            b'' if not self.ttl_seconds else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _url = reader.tgread_string()
        _caption = reader.tgread_string()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaPhotoExternal(url=_url, caption=_caption, ttl_seconds=_ttl_seconds)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaUploadedDocument(TLObject):
    CONSTRUCTOR_ID = 0xe39621fd
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, file, mime_type, attributes, caption, thumb=None, stickers=None, ttl_seconds=None):
        """
        :param TLObject file:
        :param TLObject | None thumb:
        :param str mime_type:
        :param list[TLObject] attributes:
        :param str caption:
        :param list[TLObject] | None stickers:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.file = file
        self.thumb = thumb
        self.mime_type = mime_type
        self.attributes = attributes
        self.caption = caption
        self.stickers = stickers
        self.ttl_seconds = ttl_seconds

    def to_dict(self, recursive=True):
        return {
            'file': (None if self.file is None else self.file.to_dict()) if recursive else self.file,
            'thumb': (None if self.thumb is None else self.thumb.to_dict()) if recursive else self.thumb,
            'mime_type': self.mime_type,
            'attributes': ([] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes]) if recursive else self.attributes,
            'caption': self.caption,
            'stickers': ([] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]) if recursive else self.stickers,
            'ttl_seconds': self.ttl_seconds,
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd!\x96\xe3',
            struct.pack('<I', (4 if self.thumb else 0) | (1 if self.stickers else 0) | (2 if self.ttl_seconds else 0)),
            bytes(self.file),
            b'' if not self.thumb else (bytes(self.thumb)),
            TLObject.serialize_bytes(self.mime_type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
            TLObject.serialize_bytes(self.caption),
            b'' if not self.stickers else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers))),
            b'' if not self.ttl_seconds else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _file = reader.tgread_object()
        if flags & 4:
            _thumb = reader.tgread_object()
        else:
            _thumb = None
        _mime_type = reader.tgread_string()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        _caption = reader.tgread_string()
        if flags & 1:
            reader.read_int()
            _stickers = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _stickers.append(_x)

        else:
            _stickers = None
        if flags & 2:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaUploadedDocument(file=_file, mime_type=_mime_type, attributes=_attributes, caption=_caption, thumb=_thumb, stickers=_stickers, ttl_seconds=_ttl_seconds)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaUploadedPhoto(TLObject):
    CONSTRUCTOR_ID = 0x2f37e231
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, file, caption, stickers=None, ttl_seconds=None):
        """
        :param TLObject file:
        :param str caption:
        :param list[TLObject] | None stickers:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.file = file
        self.caption = caption
        self.stickers = stickers
        self.ttl_seconds = ttl_seconds

    def to_dict(self, recursive=True):
        return {
            'file': (None if self.file is None else self.file.to_dict()) if recursive else self.file,
            'caption': self.caption,
            'stickers': ([] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]) if recursive else self.stickers,
            'ttl_seconds': self.ttl_seconds,
        }

    def __bytes__(self):
        return b''.join((
            b'1\xe27/',
            struct.pack('<I', (1 if self.stickers else 0) | (2 if self.ttl_seconds else 0)),
            bytes(self.file),
            TLObject.serialize_bytes(self.caption),
            b'' if not self.stickers else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers))),
            b'' if not self.ttl_seconds else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _file = reader.tgread_object()
        _caption = reader.tgread_string()
        if flags & 1:
            reader.read_int()
            _stickers = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _stickers.append(_x)

        else:
            _stickers = None
        if flags & 2:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaUploadedPhoto(file=_file, caption=_caption, stickers=_stickers, ttl_seconds=_ttl_seconds)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0x2827a81a
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, geo_point, title, address, provider, venue_id):
        """
        :param TLObject geo_point:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice.
        """
        super().__init__()

        self.geo_point = geo_point
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id

    def to_dict(self, recursive=True):
        return {
            'geo_point': (None if self.geo_point is None else self.geo_point.to_dict()) if recursive else self.geo_point,
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
        }

    def __bytes__(self):
        return b''.join((
            b"\x1a\xa8'(",
            bytes(self.geo_point),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.address),
            TLObject.serialize_bytes(self.provider),
            TLObject.serialize_bytes(self.venue_id),
        ))

    @staticmethod
    def from_reader(reader):
        _geo_point = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        return InputMediaVenue(geo_point=_geo_point, title=_title, address=_address, provider=_provider, venue_id=_venue_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessageEntityMentionName(TLObject):
    CONSTRUCTOR_ID = 0x208e68c9
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, user_id):
        """
        :param int offset:
        :param int length:
        :param TLObject user_id:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length
        self.user_id = user_id

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
            'user_id': (None if self.user_id is None else self.user_id.to_dict()) if recursive else self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9h\x8e ',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            bytes(self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _user_id = reader.tgread_object()
        return InputMessageEntityMentionName(offset=_offset, length=_length, user_id=_user_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterChatPhotos(TLObject):
    CONSTRUCTOR_ID = 0x3a20ecb8
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xb8\xec :',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterChatPhotos()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterDocument(TLObject):
    CONSTRUCTOR_ID = 0x9eddf188
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x88\xf1\xdd\x9e',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterDocument()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterEmpty(TLObject):
    CONSTRUCTOR_ID = 0x57e2f66c
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'l\xf6\xe2W',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterGif(TLObject):
    CONSTRUCTOR_ID = 0xffc86587
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x87e\xc8\xff',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterGif()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterMusic(TLObject):
    CONSTRUCTOR_ID = 0x3751b49e
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x9e\xb4Q7',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterMusic()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterMyMentions(TLObject):
    CONSTRUCTOR_ID = 0xc1f8e69a
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x9a\xe6\xf8\xc1',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterMyMentions()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterPhoneCalls(TLObject):
    CONSTRUCTOR_ID = 0x80c99768
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self, missed=None):
        """
        :param bool | None missed:

        Constructor for MessagesFilter: Instance of either InputMessagesFilterEmpty, InputMessagesFilterPhotos, InputMessagesFilterVideo, InputMessagesFilterPhotoVideo, InputMessagesFilterPhotoVideoDocuments, InputMessagesFilterDocument, InputMessagesFilterUrl, InputMessagesFilterGif, InputMessagesFilterVoice, InputMessagesFilterMusic, InputMessagesFilterChatPhotos, InputMessagesFilterPhoneCalls, InputMessagesFilterRoundVoice, InputMessagesFilterRoundVideo, InputMessagesFilterMyMentions.
        """
        super().__init__()

        self.missed = missed

    def to_dict(self, recursive=True):
        return {
            'missed': self.missed,
        }

    def __bytes__(self):
        return b''.join((
            b'h\x97\xc9\x80',
            struct.pack('<I', (1 if self.missed else 0)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _missed = bool(flags & 1)
        return InputMessagesFilterPhoneCalls(missed=_missed)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterPhotoVideo(TLObject):
    CONSTRUCTOR_ID = 0x56e9f0e4
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xe4\xf0\xe9V',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterPhotoVideo()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterPhotoVideoDocuments(TLObject):
    CONSTRUCTOR_ID = 0xd95e73bb
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xbbs^\xd9',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterPhotoVideoDocuments()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterPhotos(TLObject):
    CONSTRUCTOR_ID = 0x9609a51c
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x1c\xa5\t\x96',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterPhotos()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterRoundVideo(TLObject):
    CONSTRUCTOR_ID = 0xb549da53
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'S\xdaI\xb5',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterRoundVideo()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterRoundVoice(TLObject):
    CONSTRUCTOR_ID = 0x7a7c17a4
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xa4\x17|z',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterRoundVoice()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterUrl(TLObject):
    CONSTRUCTOR_ID = 0x7ef0dd87
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x87\xdd\xf0~',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterUrl()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterVideo(TLObject):
    CONSTRUCTOR_ID = 0x9fc00e65
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'e\x0e\xc0\x9f',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterVideo()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputMessagesFilterVoice(TLObject):
    CONSTRUCTOR_ID = 0x50f5c392
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x92\xc3\xf5P',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterVoice()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputNotifyAll(TLObject):
    CONSTRUCTOR_ID = 0xa429b886
    SUBCLASS_OF_ID = 0x58981615

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x86\xb8)\xa4',
        ))

    @staticmethod
    def from_reader(reader):
        return InputNotifyAll()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputNotifyChats(TLObject):
    CONSTRUCTOR_ID = 0x4a95e84e
    SUBCLASS_OF_ID = 0x58981615

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'N\xe8\x95J',
        ))

    @staticmethod
    def from_reader(reader):
        return InputNotifyChats()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputNotifyPeer(TLObject):
    CONSTRUCTOR_ID = 0xb8bc5b0c
    SUBCLASS_OF_ID = 0x58981615

    def __init__(self, peer):
        """
        :param TLObject peer:

        Constructor for InputNotifyPeer: Instance of either InputNotifyPeer, InputNotifyUsers, InputNotifyChats, InputNotifyAll.
        """
        super().__init__()

        self.peer = peer

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c[\xbc\xb8',
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        return InputNotifyPeer(peer=_peer)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputNotifyUsers(TLObject):
    CONSTRUCTOR_ID = 0x193b4417
    SUBCLASS_OF_ID = 0x58981615

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x17D;\x19',
        ))

    @staticmethod
    def from_reader(reader):
        return InputNotifyUsers()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPaymentCredentials(TLObject):
    CONSTRUCTOR_ID = 0x3417d728
    SUBCLASS_OF_ID = 0x2899a53d

    def __init__(self, data, save=None):
        """
        :param bool | None save:
        :param TLObject data:

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials.
        """
        super().__init__()

        self.save = save
        self.data = data

    def to_dict(self, recursive=True):
        return {
            'save': self.save,
            'data': (None if self.data is None else self.data.to_dict()) if recursive else self.data,
        }

    def __bytes__(self):
        return b''.join((
            b'(\xd7\x174',
            struct.pack('<I', (1 if self.save else 0)),
            bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _save = bool(flags & 1)
        _data = reader.tgread_object()
        return InputPaymentCredentials(data=_data, save=_save)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPaymentCredentialsSaved(TLObject):
    CONSTRUCTOR_ID = 0xc10eb2cf
    SUBCLASS_OF_ID = 0x2899a53d

    def __init__(self, id, tmp_password):
        """
        :param str id:
        :param bytes tmp_password:

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials.
        """
        super().__init__()

        self.id = id
        self.tmp_password = tmp_password

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'tmp_password': self.tmp_password,
        }

    def __bytes__(self):
        return b''.join((
            b'\xcf\xb2\x0e\xc1',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.tmp_password),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _tmp_password = reader.tgread_bytes()
        return InputPaymentCredentialsSaved(id=_id, tmp_password=_tmp_password)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPeerChannel(TLObject):
    CONSTRUCTOR_ID = 0x20adaef8
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self, channel_id, access_hash):
        """
        :param int channel_id:
        :param int access_hash:

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        super().__init__()

        self.channel_id = channel_id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf8\xae\xad ',
            struct.pack('<i', self.channel_id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _access_hash = reader.read_long()
        return InputPeerChannel(channel_id=_channel_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPeerChat(TLObject):
    CONSTRUCTOR_ID = 0x179be863
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self, chat_id):
        """
        :param int chat_id:

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        super().__init__()

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def __bytes__(self):
        return b''.join((
            b'c\xe8\x9b\x17',
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        return InputPeerChat(chat_id=_chat_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPeerEmpty(TLObject):
    CONSTRUCTOR_ID = 0x7f3b18ea
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xea\x18;\x7f',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPeerEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPeerNotifyEventsAll(TLObject):
    CONSTRUCTOR_ID = 0xe86a2c74
    SUBCLASS_OF_ID = 0x8f66c45c

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b't,j\xe8',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPeerNotifyEventsAll()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPeerNotifyEventsEmpty(TLObject):
    CONSTRUCTOR_ID = 0xf03064d8
    SUBCLASS_OF_ID = 0x8f66c45c

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xd8d0\xf0',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPeerNotifyEventsEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPeerNotifySettings(TLObject):
    CONSTRUCTOR_ID = 0x38935eb2
    SUBCLASS_OF_ID = 0x90db0b0d

    def __init__(self, mute_until, sound, show_previews=None, silent=None):
        """
        :param bool | None show_previews:
        :param bool | None silent:
        :param int mute_until:
        :param str sound:

        Constructor for InputPeerNotifySettings: Instance of InputPeerNotifySettings.
        """
        super().__init__()

        self.show_previews = show_previews
        self.silent = silent
        self.mute_until = mute_until
        self.sound = sound

    def to_dict(self, recursive=True):
        return {
            'show_previews': self.show_previews,
            'silent': self.silent,
            'mute_until': self.mute_until,
            'sound': self.sound,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb2^\x938',
            struct.pack('<I', (1 if self.show_previews else 0) | (2 if self.silent else 0)),
            struct.pack('<i', self.mute_until),
            TLObject.serialize_bytes(self.sound),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _show_previews = bool(flags & 1)
        _silent = bool(flags & 2)
        _mute_until = reader.read_int()
        _sound = reader.tgread_string()
        return InputPeerNotifySettings(mute_until=_mute_until, sound=_sound, show_previews=_show_previews, silent=_silent)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPeerSelf(TLObject):
    CONSTRUCTOR_ID = 0x7da07ec9
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xc9~\xa0}',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPeerSelf()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPeerUser(TLObject):
    CONSTRUCTOR_ID = 0x7b8e7de6
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self, user_id, access_hash):
        """
        :param int user_id:
        :param int access_hash:

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        super().__init__()

        self.user_id = user_id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe6}\x8e{',
            struct.pack('<i', self.user_id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _access_hash = reader.read_long()
        return InputPeerUser(user_id=_user_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0x1e36fded
    SUBCLASS_OF_ID = 0xbcaaf240

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputPhoneCall: Instance of InputPhoneCall.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\xed\xfd6\x1e',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputPhoneCall(id=_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPhoneContact(TLObject):
    CONSTRUCTOR_ID = 0xf392b7f4
    SUBCLASS_OF_ID = 0xae696a82

    def __init__(self, client_id, phone, first_name, last_name):
        """
        :param int client_id:
        :param str phone:
        :param str first_name:
        :param str last_name:

        Constructor for InputContact: Instance of InputPhoneContact.
        """
        super().__init__()

        self.client_id = client_id
        self.phone = phone
        self.first_name = first_name
        self.last_name = last_name

    def to_dict(self, recursive=True):
        return {
            'client_id': self.client_id,
            'phone': self.phone,
            'first_name': self.first_name,
            'last_name': self.last_name,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf4\xb7\x92\xf3',
            struct.pack('<q', self.client_id),
            TLObject.serialize_bytes(self.phone),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
        ))

    @staticmethod
    def from_reader(reader):
        _client_id = reader.read_long()
        _phone = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        return InputPhoneContact(client_id=_client_id, phone=_phone, first_name=_first_name, last_name=_last_name)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPhoto(TLObject):
    CONSTRUCTOR_ID = 0xfb95c6c4
    SUBCLASS_OF_ID = 0x846363e0

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputPhoto: Instance of either InputPhotoEmpty, InputPhoto.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4\xc6\x95\xfb',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputPhoto(id=_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1cd7bf0d
    SUBCLASS_OF_ID = 0x846363e0

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\r\xbf\xd7\x1c',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPhotoEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPrivacyKeyChatInvite(TLObject):
    CONSTRUCTOR_ID = 0xbdfb0426
    SUBCLASS_OF_ID = 0x53627f8

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'&\x04\xfb\xbd',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyKeyChatInvite()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPrivacyKeyPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0xfabadc5f
    SUBCLASS_OF_ID = 0x53627f8

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'_\xdc\xba\xfa',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyKeyPhoneCall()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPrivacyKeyStatusTimestamp(TLObject):
    CONSTRUCTOR_ID = 0x4f96cb18
    SUBCLASS_OF_ID = 0x53627f8

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x18\xcb\x96O',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyKeyStatusTimestamp()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPrivacyValueAllowAll(TLObject):
    CONSTRUCTOR_ID = 0x184b35ce
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xce5K\x18',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyValueAllowAll()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPrivacyValueAllowContacts(TLObject):
    CONSTRUCTOR_ID = 0xd09e07b
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'{\xe0\t\r',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyValueAllowContacts()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPrivacyValueAllowUsers(TLObject):
    CONSTRUCTOR_ID = 0x131cc67f
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self, users):
        """
        :param list[TLObject] users:

        Constructor for InputPrivacyRule: Instance of either InputPrivacyValueAllowContacts, InputPrivacyValueAllowAll, InputPrivacyValueAllowUsers, InputPrivacyValueDisallowContacts, InputPrivacyValueDisallowAll, InputPrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users

    def to_dict(self, recursive=True):
        return {
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xc6\x1c\x13',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return InputPrivacyValueAllowUsers(users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPrivacyValueDisallowAll(TLObject):
    CONSTRUCTOR_ID = 0xd66b66c9
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xc9fk\xd6',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyValueDisallowAll()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPrivacyValueDisallowContacts(TLObject):
    CONSTRUCTOR_ID = 0xba52007
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x07 \xa5\x0b',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyValueDisallowContacts()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputPrivacyValueDisallowUsers(TLObject):
    CONSTRUCTOR_ID = 0x90110467
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self, users):
        """
        :param list[TLObject] users:

        Constructor for InputPrivacyRule: Instance of either InputPrivacyValueAllowContacts, InputPrivacyValueAllowAll, InputPrivacyValueAllowUsers, InputPrivacyValueDisallowContacts, InputPrivacyValueDisallowAll, InputPrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users

    def to_dict(self, recursive=True):
        return {
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def __bytes__(self):
        return b''.join((
            b'g\x04\x11\x90',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return InputPrivacyValueDisallowUsers(users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputReportReasonOther(TLObject):
    CONSTRUCTOR_ID = 0xe1746d0a
    SUBCLASS_OF_ID = 0x8401bd27

    def __init__(self, text):
        """
        :param str text:

        Constructor for ReportReason: Instance of either InputReportReasonSpam, InputReportReasonViolence, InputReportReasonPornography, InputReportReasonOther.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\nmt\xe1',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return InputReportReasonOther(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputReportReasonPornography(TLObject):
    CONSTRUCTOR_ID = 0x2e59d922
    SUBCLASS_OF_ID = 0x8401bd27

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'"\xd9Y.',
        ))

    @staticmethod
    def from_reader(reader):
        return InputReportReasonPornography()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputReportReasonSpam(TLObject):
    CONSTRUCTOR_ID = 0x58dbcab8
    SUBCLASS_OF_ID = 0x8401bd27

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xb8\xca\xdbX',
        ))

    @staticmethod
    def from_reader(reader):
        return InputReportReasonSpam()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputReportReasonViolence(TLObject):
    CONSTRUCTOR_ID = 0x1e22c78d
    SUBCLASS_OF_ID = 0x8401bd27

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x8d\xc7"\x1e',
        ))

    @staticmethod
    def from_reader(reader):
        return InputReportReasonViolence()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputStickerSetEmpty(TLObject):
    CONSTRUCTOR_ID = 0xffb62b95
    SUBCLASS_OF_ID = 0x3da389aa

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x95+\xb6\xff',
        ))

    @staticmethod
    def from_reader(reader):
        return InputStickerSetEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputStickerSetID(TLObject):
    CONSTRUCTOR_ID = 0x9de7a269
    SUBCLASS_OF_ID = 0x3da389aa

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputStickerSet: Instance of either InputStickerSetEmpty, InputStickerSetID, InputStickerSetShortName.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'i\xa2\xe7\x9d',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputStickerSetID(id=_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputStickerSetItem(TLObject):
    CONSTRUCTOR_ID = 0xffa0a496
    SUBCLASS_OF_ID = 0xae59f075

    def __init__(self, document, emoji, mask_coords=None):
        """
        :param TLObject document:
        :param str emoji:
        :param TLObject | None mask_coords:

        Constructor for InputStickerSetItem: Instance of InputStickerSetItem.
        """
        super().__init__()

        self.document = document
        self.emoji = emoji
        self.mask_coords = mask_coords

    def to_dict(self, recursive=True):
        return {
            'document': (None if self.document is None else self.document.to_dict()) if recursive else self.document,
            'emoji': self.emoji,
            'mask_coords': (None if self.mask_coords is None else self.mask_coords.to_dict()) if recursive else self.mask_coords,
        }

    def __bytes__(self):
        return b''.join((
            b'\x96\xa4\xa0\xff',
            struct.pack('<I', (1 if self.mask_coords else 0)),
            bytes(self.document),
            TLObject.serialize_bytes(self.emoji),
            b'' if not self.mask_coords else (bytes(self.mask_coords)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _document = reader.tgread_object()
        _emoji = reader.tgread_string()
        if flags & 1:
            _mask_coords = reader.tgread_object()
        else:
            _mask_coords = None
        return InputStickerSetItem(document=_document, emoji=_emoji, mask_coords=_mask_coords)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputStickerSetShortName(TLObject):
    CONSTRUCTOR_ID = 0x861cc8a0
    SUBCLASS_OF_ID = 0x3da389aa

    def __init__(self, short_name):
        """
        :param str short_name:

        Constructor for InputStickerSet: Instance of either InputStickerSetEmpty, InputStickerSetID, InputStickerSetShortName.
        """
        super().__init__()

        self.short_name = short_name

    def to_dict(self, recursive=True):
        return {
            'short_name': self.short_name,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\xc8\x1c\x86',
            TLObject.serialize_bytes(self.short_name),
        ))

    @staticmethod
    def from_reader(reader):
        _short_name = reader.tgread_string()
        return InputStickerSetShortName(short_name=_short_name)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputStickeredMediaDocument(TLObject):
    CONSTRUCTOR_ID = 0x438865b
    SUBCLASS_OF_ID = 0x5146d99e

    def __init__(self, id):
        """
        :param TLObject id:

        Constructor for InputStickeredMedia: Instance of either InputStickeredMediaPhoto, InputStickeredMediaDocument.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'[\x868\x04',
            bytes(self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        return InputStickeredMediaDocument(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputStickeredMediaPhoto(TLObject):
    CONSTRUCTOR_ID = 0x4a992157
    SUBCLASS_OF_ID = 0x5146d99e

    def __init__(self, id):
        """
        :param TLObject id:

        Constructor for InputStickeredMedia: Instance of either InputStickeredMediaPhoto, InputStickeredMediaDocument.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': (None if self.id is None else self.id.to_dict()) if recursive else self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'W!\x99J',
            bytes(self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        return InputStickeredMediaPhoto(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputUser(TLObject):
    CONSTRUCTOR_ID = 0xd8292816
    SUBCLASS_OF_ID = 0xe669bf46

    def __init__(self, user_id, access_hash):
        """
        :param int user_id:
        :param int access_hash:

        Constructor for InputUser: Instance of either InputUserEmpty, InputUserSelf, InputUser.
        """
        super().__init__()

        self.user_id = user_id
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\x16()\xd8',
            struct.pack('<i', self.user_id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _access_hash = reader.read_long()
        return InputUser(user_id=_user_id, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputUserEmpty(TLObject):
    CONSTRUCTOR_ID = 0xb98886cf
    SUBCLASS_OF_ID = 0xe669bf46

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xcf\x86\x88\xb9',
        ))

    @staticmethod
    def from_reader(reader):
        return InputUserEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputUserSelf(TLObject):
    CONSTRUCTOR_ID = 0xf7c1b13f
    SUBCLASS_OF_ID = 0xe669bf46

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'?\xb1\xc1\xf7',
        ))

    @staticmethod
    def from_reader(reader):
        return InputUserSelf()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputWebDocument(TLObject):
    CONSTRUCTOR_ID = 0x9bed434d
    SUBCLASS_OF_ID = 0x8ae8b146

    def __init__(self, url, size, mime_type, attributes):
        """
        :param str url:
        :param int size:
        :param str mime_type:
        :param list[TLObject] attributes:

        Constructor for InputWebDocument: Instance of InputWebDocument.
        """
        super().__init__()

        self.url = url
        self.size = size
        self.mime_type = mime_type
        self.attributes = attributes

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'size': self.size,
            'mime_type': self.mime_type,
            'attributes': ([] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes]) if recursive else self.attributes,
        }

    def __bytes__(self):
        return b''.join((
            b'MC\xed\x9b',
            TLObject.serialize_bytes(self.url),
            struct.pack('<i', self.size),
            TLObject.serialize_bytes(self.mime_type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _size = reader.read_int()
        _mime_type = reader.tgread_string()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        return InputWebDocument(url=_url, size=_size, mime_type=_mime_type, attributes=_attributes)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class InputWebFileLocation(TLObject):
    CONSTRUCTOR_ID = 0xc239d686
    SUBCLASS_OF_ID = 0xf72ed8d9

    def __init__(self, url, access_hash):
        """
        :param str url:
        :param int access_hash:

        Constructor for InputWebFileLocation: Instance of InputWebFileLocation.
        """
        super().__init__()

        self.url = url
        self.access_hash = access_hash

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'access_hash': self.access_hash,
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\xd69\xc2',
            TLObject.serialize_bytes(self.url),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _access_hash = reader.read_long()
        return InputWebFileLocation(url=_url, access_hash=_access_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Invoice(TLObject):
    CONSTRUCTOR_ID = 0xc30aa358
    SUBCLASS_OF_ID = 0x5fd82ed8

    def __init__(self, currency, prices, test=None, name_requested=None, phone_requested=None, email_requested=None, shipping_address_requested=None, flexible=None):
        """
        :param bool | None test:
        :param bool | None name_requested:
        :param bool | None phone_requested:
        :param bool | None email_requested:
        :param bool | None shipping_address_requested:
        :param bool | None flexible:
        :param str currency:
        :param list[TLObject] prices:

        Constructor for Invoice: Instance of Invoice.
        """
        super().__init__()

        self.test = test
        self.name_requested = name_requested
        self.phone_requested = phone_requested
        self.email_requested = email_requested
        self.shipping_address_requested = shipping_address_requested
        self.flexible = flexible
        self.currency = currency
        self.prices = prices

    def to_dict(self, recursive=True):
        return {
            'test': self.test,
            'name_requested': self.name_requested,
            'phone_requested': self.phone_requested,
            'email_requested': self.email_requested,
            'shipping_address_requested': self.shipping_address_requested,
            'flexible': self.flexible,
            'currency': self.currency,
            'prices': ([] if self.prices is None else [None if x is None else x.to_dict() for x in self.prices]) if recursive else self.prices,
        }

    def __bytes__(self):
        return b''.join((
            b'X\xa3\n\xc3',
            struct.pack('<I', (1 if self.test else 0) | (2 if self.name_requested else 0) | (4 if self.phone_requested else 0) | (8 if self.email_requested else 0) | (16 if self.shipping_address_requested else 0) | (32 if self.flexible else 0)),
            TLObject.serialize_bytes(self.currency),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.prices)),b''.join(bytes(x) for x in self.prices),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _test = bool(flags & 1)
        _name_requested = bool(flags & 2)
        _phone_requested = bool(flags & 4)
        _email_requested = bool(flags & 8)
        _shipping_address_requested = bool(flags & 16)
        _flexible = bool(flags & 32)
        _currency = reader.tgread_string()
        reader.read_int()
        _prices = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _prices.append(_x)

        return Invoice(currency=_currency, prices=_prices, test=_test, name_requested=_name_requested, phone_requested=_phone_requested, email_requested=_email_requested, shipping_address_requested=_shipping_address_requested, flexible=_flexible)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class IpPort(TLObject):
    CONSTRUCTOR_ID = 0xd433ad73
    SUBCLASS_OF_ID = 0xa2a03726

    def __init__(self, ipv4, port):
        """
        :param int ipv4:
        :param int port:

        Constructor for IpPort: Instance of IpPort.
        """
        super().__init__()

        self.ipv4 = ipv4
        self.port = port

    def to_dict(self, recursive=True):
        return {
            'ipv4': self.ipv4,
            'port': self.port,
        }

    def __bytes__(self):
        return b''.join((
            b's\xad3\xd4',
            struct.pack('<i', self.ipv4),
            struct.pack('<i', self.port),
        ))

    @staticmethod
    def from_reader(reader):
        _ipv4 = reader.read_int()
        _port = reader.read_int()
        return IpPort(ipv4=_ipv4, port=_port)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class KeyboardButton(TLObject):
    CONSTRUCTOR_ID = 0xa2fa4880
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\x80H\xfa\xa2',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return KeyboardButton(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class KeyboardButtonBuy(TLObject):
    CONSTRUCTOR_ID = 0xafd93fbb
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb?\xd9\xaf',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return KeyboardButtonBuy(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class KeyboardButtonCallback(TLObject):
    CONSTRUCTOR_ID = 0x683a5e46
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text, data):
        """
        :param str text:
        :param bytes data:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text
        self.data = data

    def to_dict(self, recursive=True):
        return {
            'text': self.text,
            'data': self.data,
        }

    def __bytes__(self):
        return b''.join((
            b'F^:h',
            TLObject.serialize_bytes(self.text),
            TLObject.serialize_bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        _data = reader.tgread_bytes()
        return KeyboardButtonCallback(text=_text, data=_data)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class KeyboardButtonGame(TLObject):
    CONSTRUCTOR_ID = 0x50f41ccf
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\xcf\x1c\xf4P',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return KeyboardButtonGame(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class KeyboardButtonRequestGeoLocation(TLObject):
    CONSTRUCTOR_ID = 0xfc796b3f
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'?ky\xfc',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return KeyboardButtonRequestGeoLocation(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class KeyboardButtonRequestPhone(TLObject):
    CONSTRUCTOR_ID = 0xb16a6c29
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': self.text,
        }

    def __bytes__(self):
        return b''.join((
            b')lj\xb1',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return KeyboardButtonRequestPhone(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class KeyboardButtonRow(TLObject):
    CONSTRUCTOR_ID = 0x77608b83
    SUBCLASS_OF_ID = 0x847730ae

    def __init__(self, buttons):
        """
        :param list[TLObject] buttons:

        Constructor for KeyboardButtonRow: Instance of KeyboardButtonRow.
        """
        super().__init__()

        self.buttons = buttons

    def to_dict(self, recursive=True):
        return {
            'buttons': ([] if self.buttons is None else [None if x is None else x.to_dict() for x in self.buttons]) if recursive else self.buttons,
        }

    def __bytes__(self):
        return b''.join((
            b'\x83\x8b`w',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.buttons)),b''.join(bytes(x) for x in self.buttons),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _buttons = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _buttons.append(_x)

        return KeyboardButtonRow(buttons=_buttons)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class KeyboardButtonSwitchInline(TLObject):
    CONSTRUCTOR_ID = 0x568a748
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text, query, same_peer=None):
        """
        :param bool | None same_peer:
        :param str text:
        :param str query:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.same_peer = same_peer
        self.text = text
        self.query = query

    def to_dict(self, recursive=True):
        return {
            'same_peer': self.same_peer,
            'text': self.text,
            'query': self.query,
        }

    def __bytes__(self):
        return b''.join((
            b'H\xa7h\x05',
            struct.pack('<I', (1 if self.same_peer else 0)),
            TLObject.serialize_bytes(self.text),
            TLObject.serialize_bytes(self.query),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _same_peer = bool(flags & 1)
        _text = reader.tgread_string()
        _query = reader.tgread_string()
        return KeyboardButtonSwitchInline(text=_text, query=_query, same_peer=_same_peer)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class KeyboardButtonUrl(TLObject):
    CONSTRUCTOR_ID = 0x258aff05
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text, url):
        """
        :param str text:
        :param str url:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text
        self.url = url

    def to_dict(self, recursive=True):
        return {
            'text': self.text,
            'url': self.url,
        }

    def __bytes__(self):
        return b''.join((
            b'\x05\xff\x8a%',
            TLObject.serialize_bytes(self.text),
            TLObject.serialize_bytes(self.url),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        _url = reader.tgread_string()
        return KeyboardButtonUrl(text=_text, url=_url)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class LabeledPrice(TLObject):
    CONSTRUCTOR_ID = 0xcb296bf8
    SUBCLASS_OF_ID = 0x1c84047a

    def __init__(self, label, amount):
        """
        :param str label:
        :param int amount:

        Constructor for LabeledPrice: Instance of LabeledPrice.
        """
        super().__init__()

        self.label = label
        self.amount = amount

    def to_dict(self, recursive=True):
        return {
            'label': self.label,
            'amount': self.amount,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf8k)\xcb',
            TLObject.serialize_bytes(self.label),
            struct.pack('<q', self.amount),
        ))

    @staticmethod
    def from_reader(reader):
        _label = reader.tgread_string()
        _amount = reader.read_long()
        return LabeledPrice(label=_label, amount=_amount)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class LangPackDifference(TLObject):
    CONSTRUCTOR_ID = 0xf385c1f6
    SUBCLASS_OF_ID = 0x52662d55

    def __init__(self, lang_code, from_version, version, strings):
        """
        :param str lang_code:
        :param int from_version:
        :param int version:
        :param list[TLObject] strings:

        Constructor for LangPackDifference: Instance of LangPackDifference.
        """
        super().__init__()

        self.lang_code = lang_code
        self.from_version = from_version
        self.version = version
        self.strings = strings

    def to_dict(self, recursive=True):
        return {
            'lang_code': self.lang_code,
            'from_version': self.from_version,
            'version': self.version,
            'strings': ([] if self.strings is None else [None if x is None else x.to_dict() for x in self.strings]) if recursive else self.strings,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xc1\x85\xf3',
            TLObject.serialize_bytes(self.lang_code),
            struct.pack('<i', self.from_version),
            struct.pack('<i', self.version),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.strings)),b''.join(bytes(x) for x in self.strings),
        ))

    @staticmethod
    def from_reader(reader):
        _lang_code = reader.tgread_string()
        _from_version = reader.read_int()
        _version = reader.read_int()
        reader.read_int()
        _strings = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _strings.append(_x)

        return LangPackDifference(lang_code=_lang_code, from_version=_from_version, version=_version, strings=_strings)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class LangPackLanguage(TLObject):
    CONSTRUCTOR_ID = 0x117698f1
    SUBCLASS_OF_ID = 0xabac89b7

    def __init__(self, name, native_name, lang_code):
        """
        :param str name:
        :param str native_name:
        :param str lang_code:

        Constructor for LangPackLanguage: Instance of LangPackLanguage.
        """
        super().__init__()

        self.name = name
        self.native_name = native_name
        self.lang_code = lang_code

    def to_dict(self, recursive=True):
        return {
            'name': self.name,
            'native_name': self.native_name,
            'lang_code': self.lang_code,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf1\x98v\x11',
            TLObject.serialize_bytes(self.name),
            TLObject.serialize_bytes(self.native_name),
            TLObject.serialize_bytes(self.lang_code),
        ))

    @staticmethod
    def from_reader(reader):
        _name = reader.tgread_string()
        _native_name = reader.tgread_string()
        _lang_code = reader.tgread_string()
        return LangPackLanguage(name=_name, native_name=_native_name, lang_code=_lang_code)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class LangPackString(TLObject):
    CONSTRUCTOR_ID = 0xcad181f6
    SUBCLASS_OF_ID = 0xdc179ab9

    def __init__(self, key, value):
        """
        :param str key:
        :param str value:

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        super().__init__()

        self.key = key
        self.value = value

    def to_dict(self, recursive=True):
        return {
            'key': self.key,
            'value': self.value,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\x81\xd1\xca',
            TLObject.serialize_bytes(self.key),
            TLObject.serialize_bytes(self.value),
        ))

    @staticmethod
    def from_reader(reader):
        _key = reader.tgread_string()
        _value = reader.tgread_string()
        return LangPackString(key=_key, value=_value)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class LangPackStringDeleted(TLObject):
    CONSTRUCTOR_ID = 0x2979eeb2
    SUBCLASS_OF_ID = 0xdc179ab9

    def __init__(self, key):
        """
        :param str key:

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        super().__init__()

        self.key = key

    def to_dict(self, recursive=True):
        return {
            'key': self.key,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb2\xeey)',
            TLObject.serialize_bytes(self.key),
        ))

    @staticmethod
    def from_reader(reader):
        _key = reader.tgread_string()
        return LangPackStringDeleted(key=_key)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class LangPackStringPluralized(TLObject):
    CONSTRUCTOR_ID = 0x6c47ac9f
    SUBCLASS_OF_ID = 0xdc179ab9

    def __init__(self, key, other_value, zero_value=None, one_value=None, two_value=None, few_value=None, many_value=None):
        """
        :param str key:
        :param str | None zero_value:
        :param str | None one_value:
        :param str | None two_value:
        :param str | None few_value:
        :param str | None many_value:
        :param str other_value:

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        super().__init__()

        self.key = key
        self.zero_value = zero_value
        self.one_value = one_value
        self.two_value = two_value
        self.few_value = few_value
        self.many_value = many_value
        self.other_value = other_value

    def to_dict(self, recursive=True):
        return {
            'key': self.key,
            'zero_value': self.zero_value,
            'one_value': self.one_value,
            'two_value': self.two_value,
            'few_value': self.few_value,
            'many_value': self.many_value,
            'other_value': self.other_value,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9f\xacGl',
            struct.pack('<I', (1 if self.zero_value else 0) | (2 if self.one_value else 0) | (4 if self.two_value else 0) | (8 if self.few_value else 0) | (16 if self.many_value else 0)),
            TLObject.serialize_bytes(self.key),
            b'' if not self.zero_value else (TLObject.serialize_bytes(self.zero_value)),
            b'' if not self.one_value else (TLObject.serialize_bytes(self.one_value)),
            b'' if not self.two_value else (TLObject.serialize_bytes(self.two_value)),
            b'' if not self.few_value else (TLObject.serialize_bytes(self.few_value)),
            b'' if not self.many_value else (TLObject.serialize_bytes(self.many_value)),
            TLObject.serialize_bytes(self.other_value),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _key = reader.tgread_string()
        if flags & 1:
            _zero_value = reader.tgread_string()
        else:
            _zero_value = None
        if flags & 2:
            _one_value = reader.tgread_string()
        else:
            _one_value = None
        if flags & 4:
            _two_value = reader.tgread_string()
        else:
            _two_value = None
        if flags & 8:
            _few_value = reader.tgread_string()
        else:
            _few_value = None
        if flags & 16:
            _many_value = reader.tgread_string()
        else:
            _many_value = None
        _other_value = reader.tgread_string()
        return LangPackStringPluralized(key=_key, other_value=_other_value, zero_value=_zero_value, one_value=_one_value, two_value=_two_value, few_value=_few_value, many_value=_many_value)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MaskCoords(TLObject):
    CONSTRUCTOR_ID = 0xaed6dbb2
    SUBCLASS_OF_ID = 0x6bbb2fd

    def __init__(self, n, x, y, zoom):
        """
        :param int n:
        :param TLObject x:
        :param TLObject y:
        :param TLObject zoom:

        Constructor for MaskCoords: Instance of MaskCoords.
        """
        super().__init__()

        self.n = n
        self.x = x
        self.y = y
        self.zoom = zoom

    def to_dict(self, recursive=True):
        return {
            'n': self.n,
            'x': self.x,
            'y': self.y,
            'zoom': self.zoom,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb2\xdb\xd6\xae',
            struct.pack('<i', self.n),
            struct.pack('<d', self.x),
            struct.pack('<d', self.y),
            struct.pack('<d', self.zoom),
        ))

    @staticmethod
    def from_reader(reader):
        _n = reader.read_int()
        _x = reader.read_double()
        _y = reader.read_double()
        _zoom = reader.read_double()
        return MaskCoords(n=_n, x=_x, y=_y, zoom=_zoom)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Message(TLObject):
    CONSTRUCTOR_ID = 0x90dddc11
    SUBCLASS_OF_ID = 0x790009e3

    def __init__(self, id, to_id, date, message, out=None, mentioned=None, media_unread=None, silent=None, post=None, from_id=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, media=None, reply_markup=None, entities=None, views=None, edit_date=None, post_author=None):
        """
        :param bool | None out:
        :param bool | None mentioned:
        :param bool | None media_unread:
        :param bool | None silent:
        :param bool | None post:
        :param int id:
        :param int | None from_id:
        :param TLObject to_id:
        :param TLObject | None fwd_from:
        :param int | None via_bot_id:
        :param int | None reply_to_msg_id:
        :param datetime.datetime | None date:
        :param str message:
        :param TLObject | None media:
        :param TLObject | None reply_markup:
        :param list[TLObject] | None entities:
        :param int | None views:
        :param datetime.datetime | None edit_date:
        :param str | None post_author:

        Constructor for Message: Instance of either MessageEmpty, Message, MessageService.
        """
        super().__init__()

        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.post = post
        self.id = id
        self.from_id = from_id
        self.to_id = to_id
        self.fwd_from = fwd_from
        self.via_bot_id = via_bot_id
        self.reply_to_msg_id = reply_to_msg_id
        self.date = date
        self.message = message
        self.media = media
        self.reply_markup = reply_markup
        self.entities = entities
        self.views = views
        self.edit_date = edit_date
        self.post_author = post_author

    def to_dict(self, recursive=True):
        return {
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'post': self.post,
            'id': self.id,
            'from_id': self.from_id,
            'to_id': (None if self.to_id is None else self.to_id.to_dict()) if recursive else self.to_id,
            'fwd_from': (None if self.fwd_from is None else self.fwd_from.to_dict()) if recursive else self.fwd_from,
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'date': self.date,
            'message': self.message,
            'media': (None if self.media is None else self.media.to_dict()) if recursive else self.media,
            'reply_markup': (None if self.reply_markup is None else self.reply_markup.to_dict()) if recursive else self.reply_markup,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
            'views': self.views,
            'edit_date': self.edit_date,
            'post_author': self.post_author,
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\xdc\xdd\x90',
            struct.pack('<I', (2 if self.out else 0) | (16 if self.mentioned else 0) | (32 if self.media_unread else 0) | (8192 if self.silent else 0) | (16384 if self.post else 0) | (256 if self.from_id else 0) | (4 if self.fwd_from else 0) | (2048 if self.via_bot_id else 0) | (8 if self.reply_to_msg_id else 0) | (512 if self.media else 0) | (64 if self.reply_markup else 0) | (128 if self.entities else 0) | (1024 if self.views else 0) | (32768 if self.edit_date else 0) | (65536 if self.post_author else 0)),
            struct.pack('<i', self.id),
            b'' if not self.from_id else (struct.pack('<i', self.from_id)),
            bytes(self.to_id),
            b'' if not self.fwd_from else (bytes(self.fwd_from)),
            b'' if not self.via_bot_id else (struct.pack('<i', self.via_bot_id)),
            b'' if not self.reply_to_msg_id else (struct.pack('<i', self.reply_to_msg_id)),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            TLObject.serialize_bytes(self.message),
            b'' if not self.media else (bytes(self.media)),
            b'' if not self.reply_markup else (bytes(self.reply_markup)),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if not self.views else (struct.pack('<i', self.views)),
            b'' if not self.edit_date else (b'\0\0\0\0' if self.edit_date is None else struct.pack('<I', int(self.edit_date.timestamp()))),
            b'' if not self.post_author else (TLObject.serialize_bytes(self.post_author)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _mentioned = bool(flags & 16)
        _media_unread = bool(flags & 32)
        _silent = bool(flags & 8192)
        _post = bool(flags & 16384)
        _id = reader.read_int()
        if flags & 256:
            _from_id = reader.read_int()
        else:
            _from_id = None
        _to_id = reader.tgread_object()
        if flags & 4:
            _fwd_from = reader.tgread_object()
        else:
            _fwd_from = None
        if flags & 2048:
            _via_bot_id = reader.read_int()
        else:
            _via_bot_id = None
        if flags & 8:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _date = reader.tgread_date()
        _message = reader.tgread_string()
        if flags & 512:
            _media = reader.tgread_object()
        else:
            _media = None
        if flags & 64:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 1024:
            _views = reader.read_int()
        else:
            _views = None
        if flags & 32768:
            _edit_date = reader.tgread_date()
        else:
            _edit_date = None
        if flags & 65536:
            _post_author = reader.tgread_string()
        else:
            _post_author = None
        return Message(id=_id, to_id=_to_id, date=_date, message=_message, out=_out, mentioned=_mentioned, media_unread=_media_unread, silent=_silent, post=_post, from_id=_from_id, fwd_from=_fwd_from, via_bot_id=_via_bot_id, reply_to_msg_id=_reply_to_msg_id, media=_media, reply_markup=_reply_markup, entities=_entities, views=_views, edit_date=_edit_date, post_author=_post_author)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionChannelCreate(TLObject):
    CONSTRUCTOR_ID = 0x95d2ac92
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title):
        """
        :param str title:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.title = title

    def to_dict(self, recursive=True):
        return {
            'title': self.title,
        }

    def __bytes__(self):
        return b''.join((
            b'\x92\xac\xd2\x95',
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        _title = reader.tgread_string()
        return MessageActionChannelCreate(title=_title)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionChannelMigrateFrom(TLObject):
    CONSTRUCTOR_ID = 0xb055eaee
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title, chat_id):
        """
        :param str title:
        :param int chat_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.title = title
        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'title': self.title,
            'chat_id': self.chat_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xee\xeaU\xb0',
            TLObject.serialize_bytes(self.title),
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _title = reader.tgread_string()
        _chat_id = reader.read_int()
        return MessageActionChannelMigrateFrom(title=_title, chat_id=_chat_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionChatAddUser(TLObject):
    CONSTRUCTOR_ID = 0x488a7337
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, users):
        """
        :param list[int] users:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.users = users

    def to_dict(self, recursive=True):
        return {
            'users': [] if self.users is None else self.users[:],
        }

    def __bytes__(self):
        return b''.join((
            b'7s\x8aH',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return MessageActionChatAddUser(users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionChatCreate(TLObject):
    CONSTRUCTOR_ID = 0xa6638b9a
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title, users):
        """
        :param str title:
        :param list[int] users:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.title = title
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'title': self.title,
            'users': [] if self.users is None else self.users[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\x9a\x8bc\xa6',
            TLObject.serialize_bytes(self.title),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        _title = reader.tgread_string()
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return MessageActionChatCreate(title=_title, users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionChatDeletePhoto(TLObject):
    CONSTRUCTOR_ID = 0x95e3fbef
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xef\xfb\xe3\x95',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageActionChatDeletePhoto()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionChatDeleteUser(TLObject):
    CONSTRUCTOR_ID = 0xb2ae9b0c
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.user_id = user_id

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c\x9b\xae\xb2',
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        return MessageActionChatDeleteUser(user_id=_user_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionChatEditPhoto(TLObject):
    CONSTRUCTOR_ID = 0x7fcb13a8
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, photo):
        """
        :param TLObject photo:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.photo = photo

    def to_dict(self, recursive=True):
        return {
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa8\x13\xcb\x7f',
            bytes(self.photo),
        ))

    @staticmethod
    def from_reader(reader):
        _photo = reader.tgread_object()
        return MessageActionChatEditPhoto(photo=_photo)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionChatEditTitle(TLObject):
    CONSTRUCTOR_ID = 0xb5a1ce5a
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title):
        """
        :param str title:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.title = title

    def to_dict(self, recursive=True):
        return {
            'title': self.title,
        }

    def __bytes__(self):
        return b''.join((
            b'Z\xce\xa1\xb5',
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        _title = reader.tgread_string()
        return MessageActionChatEditTitle(title=_title)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionChatJoinedByLink(TLObject):
    CONSTRUCTOR_ID = 0xf89cf5e8
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, inviter_id):
        """
        :param int inviter_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.inviter_id = inviter_id

    def to_dict(self, recursive=True):
        return {
            'inviter_id': self.inviter_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe8\xf5\x9c\xf8',
            struct.pack('<i', self.inviter_id),
        ))

    @staticmethod
    def from_reader(reader):
        _inviter_id = reader.read_int()
        return MessageActionChatJoinedByLink(inviter_id=_inviter_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionChatMigrateTo(TLObject):
    CONSTRUCTOR_ID = 0x51bdb021
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, channel_id):
        """
        :param int channel_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.channel_id = channel_id

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
        }

    def __bytes__(self):
        return b''.join((
            b'!\xb0\xbdQ',
            struct.pack('<i', self.channel_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        return MessageActionChatMigrateTo(channel_id=_channel_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionEmpty(TLObject):
    CONSTRUCTOR_ID = 0xb6aef7b0
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xb0\xf7\xae\xb6',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageActionEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionGameScore(TLObject):
    CONSTRUCTOR_ID = 0x92a72876
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, game_id, score):
        """
        :param int game_id:
        :param int score:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.game_id = game_id
        self.score = score

    def to_dict(self, recursive=True):
        return {
            'game_id': self.game_id,
            'score': self.score,
        }

    def __bytes__(self):
        return b''.join((
            b'v(\xa7\x92',
            struct.pack('<q', self.game_id),
            struct.pack('<i', self.score),
        ))

    @staticmethod
    def from_reader(reader):
        _game_id = reader.read_long()
        _score = reader.read_int()
        return MessageActionGameScore(game_id=_game_id, score=_score)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionHistoryClear(TLObject):
    CONSTRUCTOR_ID = 0x9fbab604
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x04\xb6\xba\x9f',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageActionHistoryClear()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionPaymentSent(TLObject):
    CONSTRUCTOR_ID = 0x40699cd0
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, currency, total_amount):
        """
        :param str currency:
        :param int total_amount:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.currency = currency
        self.total_amount = total_amount

    def to_dict(self, recursive=True):
        return {
            'currency': self.currency,
            'total_amount': self.total_amount,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd0\x9ci@',
            TLObject.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
        ))

    @staticmethod
    def from_reader(reader):
        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        return MessageActionPaymentSent(currency=_currency, total_amount=_total_amount)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionPaymentSentMe(TLObject):
    CONSTRUCTOR_ID = 0x8f31b327
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, currency, total_amount, payload, charge, info=None, shipping_option_id=None):
        """
        :param str currency:
        :param int total_amount:
        :param bytes payload:
        :param TLObject | None info:
        :param str | None shipping_option_id:
        :param TLObject charge:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.currency = currency
        self.total_amount = total_amount
        self.payload = payload
        self.info = info
        self.shipping_option_id = shipping_option_id
        self.charge = charge

    def to_dict(self, recursive=True):
        return {
            'currency': self.currency,
            'total_amount': self.total_amount,
            'payload': self.payload,
            'info': (None if self.info is None else self.info.to_dict()) if recursive else self.info,
            'shipping_option_id': self.shipping_option_id,
            'charge': (None if self.charge is None else self.charge.to_dict()) if recursive else self.charge,
        }

    def __bytes__(self):
        return b''.join((
            b"'\xb31\x8f",
            struct.pack('<I', (1 if self.info else 0) | (2 if self.shipping_option_id else 0)),
            TLObject.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
            TLObject.serialize_bytes(self.payload),
            b'' if not self.info else (bytes(self.info)),
            b'' if not self.shipping_option_id else (TLObject.serialize_bytes(self.shipping_option_id)),
            bytes(self.charge),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        _payload = reader.tgread_bytes()
        if flags & 1:
            _info = reader.tgread_object()
        else:
            _info = None
        if flags & 2:
            _shipping_option_id = reader.tgread_string()
        else:
            _shipping_option_id = None
        _charge = reader.tgread_object()
        return MessageActionPaymentSentMe(currency=_currency, total_amount=_total_amount, payload=_payload, charge=_charge, info=_info, shipping_option_id=_shipping_option_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0x80e11a7f
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, call_id, reason=None, duration=None):
        """
        :param int call_id:
        :param TLObject | None reason:
        :param int | None duration:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken.
        """
        super().__init__()

        self.call_id = call_id
        self.reason = reason
        self.duration = duration

    def to_dict(self, recursive=True):
        return {
            'call_id': self.call_id,
            'reason': (None if self.reason is None else self.reason.to_dict()) if recursive else self.reason,
            'duration': self.duration,
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\x1a\xe1\x80',
            struct.pack('<I', (1 if self.reason else 0) | (2 if self.duration else 0)),
            struct.pack('<q', self.call_id),
            b'' if not self.reason else (bytes(self.reason)),
            b'' if not self.duration else (struct.pack('<i', self.duration)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _call_id = reader.read_long()
        if flags & 1:
            _reason = reader.tgread_object()
        else:
            _reason = None
        if flags & 2:
            _duration = reader.read_int()
        else:
            _duration = None
        return MessageActionPhoneCall(call_id=_call_id, reason=_reason, duration=_duration)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionPinMessage(TLObject):
    CONSTRUCTOR_ID = 0x94bd38ed
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xed8\xbd\x94',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageActionPinMessage()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageActionScreenshotTaken(TLObject):
    CONSTRUCTOR_ID = 0x4792929b
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x9b\x92\x92G',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageActionScreenshotTaken()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEmpty(TLObject):
    CONSTRUCTOR_ID = 0x83e5de54
    SUBCLASS_OF_ID = 0x790009e3

    def __init__(self, id):
        """
        :param int id:

        Constructor for Message: Instance of either MessageEmpty, Message, MessageService.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'T\xde\xe5\x83',
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        return MessageEmpty(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityBold(TLObject):
    CONSTRUCTOR_ID = 0xbd610bc9
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9\x0ba\xbd',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityBold(offset=_offset, length=_length)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityBotCommand(TLObject):
    CONSTRUCTOR_ID = 0x6cef8ac7
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7\x8a\xefl',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityBotCommand(offset=_offset, length=_length)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityCode(TLObject):
    CONSTRUCTOR_ID = 0x28a20571
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def __bytes__(self):
        return b''.join((
            b'q\x05\xa2(',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityCode(offset=_offset, length=_length)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityEmail(TLObject):
    CONSTRUCTOR_ID = 0x64e475c2
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc2u\xe4d',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityEmail(offset=_offset, length=_length)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityHashtag(TLObject):
    CONSTRUCTOR_ID = 0x6f635b0d
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def __bytes__(self):
        return b''.join((
            b'\r[co',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityHashtag(offset=_offset, length=_length)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityItalic(TLObject):
    CONSTRUCTOR_ID = 0x826f8b60
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def __bytes__(self):
        return b''.join((
            b'`\x8bo\x82',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityItalic(offset=_offset, length=_length)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityMention(TLObject):
    CONSTRUCTOR_ID = 0xfa04579d
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9dW\x04\xfa',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityMention(offset=_offset, length=_length)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityMentionName(TLObject):
    CONSTRUCTOR_ID = 0x352dca58
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, user_id):
        """
        :param int offset:
        :param int length:
        :param int user_id:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length
        self.user_id = user_id

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
            'user_id': self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'X\xca-5',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _user_id = reader.read_int()
        return MessageEntityMentionName(offset=_offset, length=_length, user_id=_user_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityPre(TLObject):
    CONSTRUCTOR_ID = 0x73924be0
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, language):
        """
        :param int offset:
        :param int length:
        :param str language:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length
        self.language = language

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
            'language': self.language,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe0K\x92s',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            TLObject.serialize_bytes(self.language),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _language = reader.tgread_string()
        return MessageEntityPre(offset=_offset, length=_length, language=_language)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityTextUrl(TLObject):
    CONSTRUCTOR_ID = 0x76a6d327
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, url):
        """
        :param int offset:
        :param int length:
        :param str url:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length
        self.url = url

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
            'url': self.url,
        }

    def __bytes__(self):
        return b''.join((
            b"'\xd3\xa6v",
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            TLObject.serialize_bytes(self.url),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _url = reader.tgread_string()
        return MessageEntityTextUrl(offset=_offset, length=_length, url=_url)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityUnknown(TLObject):
    CONSTRUCTOR_ID = 0xbb92ba95
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\xba\x92\xbb',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityUnknown(offset=_offset, length=_length)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEntityUrl(TLObject):
    CONSTRUCTOR_ID = 0x6ed02538
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset
        self.length = length

    def to_dict(self, recursive=True):
        return {
            'offset': self.offset,
            'length': self.length,
        }

    def __bytes__(self):
        return b''.join((
            b'8%\xd0n',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityUrl(offset=_offset, length=_length)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageFwdHeader(TLObject):
    CONSTRUCTOR_ID = 0xfadff4ac
    SUBCLASS_OF_ID = 0x7a286804

    def __init__(self, date, from_id=None, channel_id=None, channel_post=None, post_author=None):
        """
        :param int | None from_id:
        :param datetime.datetime | None date:
        :param int | None channel_id:
        :param int | None channel_post:
        :param str | None post_author:

        Constructor for MessageFwdHeader: Instance of MessageFwdHeader.
        """
        super().__init__()

        self.from_id = from_id
        self.date = date
        self.channel_id = channel_id
        self.channel_post = channel_post
        self.post_author = post_author

    def to_dict(self, recursive=True):
        return {
            'from_id': self.from_id,
            'date': self.date,
            'channel_id': self.channel_id,
            'channel_post': self.channel_post,
            'post_author': self.post_author,
        }

    def __bytes__(self):
        return b''.join((
            b'\xac\xf4\xdf\xfa',
            struct.pack('<I', (1 if self.from_id else 0) | (2 if self.channel_id else 0) | (4 if self.channel_post else 0) | (8 if self.post_author else 0)),
            b'' if not self.from_id else (struct.pack('<i', self.from_id)),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            b'' if not self.channel_id else (struct.pack('<i', self.channel_id)),
            b'' if not self.channel_post else (struct.pack('<i', self.channel_post)),
            b'' if not self.post_author else (TLObject.serialize_bytes(self.post_author)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 1:
            _from_id = reader.read_int()
        else:
            _from_id = None
        _date = reader.tgread_date()
        if flags & 2:
            _channel_id = reader.read_int()
        else:
            _channel_id = None
        if flags & 4:
            _channel_post = reader.read_int()
        else:
            _channel_post = None
        if flags & 8:
            _post_author = reader.tgread_string()
        else:
            _post_author = None
        return MessageFwdHeader(date=_date, from_id=_from_id, channel_id=_channel_id, channel_post=_channel_post, post_author=_post_author)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageMediaContact(TLObject):
    CONSTRUCTOR_ID = 0x5e7d2f39
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, phone_number, first_name, last_name, user_id):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:
        :param int user_id:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name
        self.user_id = user_id

    def to_dict(self, recursive=True):
        return {
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'user_id': self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'9/}^',
            TLObject.serialize_bytes(self.phone_number),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        _user_id = reader.read_int()
        return MessageMediaContact(phone_number=_phone_number, first_name=_first_name, last_name=_last_name, user_id=_user_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageMediaDocument(TLObject):
    CONSTRUCTOR_ID = 0x7c4414d3
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, document=None, caption=None, ttl_seconds=None):
        """
        :param TLObject | None document:
        :param str | None caption:
        :param int | None ttl_seconds:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.document = document
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self, recursive=True):
        return {
            'document': (None if self.document is None else self.document.to_dict()) if recursive else self.document,
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd3\x14D|',
            struct.pack('<I', (1 if self.document else 0) | (2 if self.caption else 0) | (4 if self.ttl_seconds else 0)),
            b'' if not self.document else (bytes(self.document)),
            b'' if not self.caption else (TLObject.serialize_bytes(self.caption)),
            b'' if not self.ttl_seconds else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 1:
            _document = reader.tgread_object()
        else:
            _document = None
        if flags & 2:
            _caption = reader.tgread_string()
        else:
            _caption = None
        if flags & 4:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return MessageMediaDocument(document=_document, caption=_caption, ttl_seconds=_ttl_seconds)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageMediaEmpty(TLObject):
    CONSTRUCTOR_ID = 0x3ded6320
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b' c\xed=',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageMediaEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageMediaGame(TLObject):
    CONSTRUCTOR_ID = 0xfdb19008
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, game):
        """
        :param TLObject game:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.game = game

    def to_dict(self, recursive=True):
        return {
            'game': (None if self.game is None else self.game.to_dict()) if recursive else self.game,
        }

    def __bytes__(self):
        return b''.join((
            b'\x08\x90\xb1\xfd',
            bytes(self.game),
        ))

    @staticmethod
    def from_reader(reader):
        _game = reader.tgread_object()
        return MessageMediaGame(game=_game)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageMediaGeo(TLObject):
    CONSTRUCTOR_ID = 0x56e0d474
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, geo):
        """
        :param TLObject geo:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.geo = geo

    def to_dict(self, recursive=True):
        return {
            'geo': (None if self.geo is None else self.geo.to_dict()) if recursive else self.geo,
        }

    def __bytes__(self):
        return b''.join((
            b't\xd4\xe0V',
            bytes(self.geo),
        ))

    @staticmethod
    def from_reader(reader):
        _geo = reader.tgread_object()
        return MessageMediaGeo(geo=_geo)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageMediaInvoice(TLObject):
    CONSTRUCTOR_ID = 0x84551347
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, title, description, currency, total_amount, start_param, shipping_address_requested=None, test=None, photo=None, receipt_msg_id=None):
        """
        :param bool | None shipping_address_requested:
        :param bool | None test:
        :param str title:
        :param str description:
        :param TLObject | None photo:
        :param int | None receipt_msg_id:
        :param str currency:
        :param int total_amount:
        :param str start_param:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.shipping_address_requested = shipping_address_requested
        self.test = test
        self.title = title
        self.description = description
        self.photo = photo
        self.receipt_msg_id = receipt_msg_id
        self.currency = currency
        self.total_amount = total_amount
        self.start_param = start_param

    def to_dict(self, recursive=True):
        return {
            'shipping_address_requested': self.shipping_address_requested,
            'test': self.test,
            'title': self.title,
            'description': self.description,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'receipt_msg_id': self.receipt_msg_id,
            'currency': self.currency,
            'total_amount': self.total_amount,
            'start_param': self.start_param,
        }

    def __bytes__(self):
        return b''.join((
            b'G\x13U\x84',
            struct.pack('<I', (2 if self.shipping_address_requested else 0) | (8 if self.test else 0) | (1 if self.photo else 0) | (4 if self.receipt_msg_id else 0)),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.description),
            b'' if not self.photo else (bytes(self.photo)),
            b'' if not self.receipt_msg_id else (struct.pack('<i', self.receipt_msg_id)),
            TLObject.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
            TLObject.serialize_bytes(self.start_param),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _shipping_address_requested = bool(flags & 2)
        _test = bool(flags & 8)
        _title = reader.tgread_string()
        _description = reader.tgread_string()
        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 4:
            _receipt_msg_id = reader.read_int()
        else:
            _receipt_msg_id = None
        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        _start_param = reader.tgread_string()
        return MessageMediaInvoice(title=_title, description=_description, currency=_currency, total_amount=_total_amount, start_param=_start_param, shipping_address_requested=_shipping_address_requested, test=_test, photo=_photo, receipt_msg_id=_receipt_msg_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageMediaPhoto(TLObject):
    CONSTRUCTOR_ID = 0xb5223b0f
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, photo=None, caption=None, ttl_seconds=None):
        """
        :param TLObject | None photo:
        :param str | None caption:
        :param int | None ttl_seconds:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.photo = photo
        self.caption = caption
        self.ttl_seconds = ttl_seconds

    def to_dict(self, recursive=True):
        return {
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'caption': self.caption,
            'ttl_seconds': self.ttl_seconds,
        }

    def __bytes__(self):
        return b''.join((
            b'\x0f;"\xb5',
            struct.pack('<I', (1 if self.photo else 0) | (2 if self.caption else 0) | (4 if self.ttl_seconds else 0)),
            b'' if not self.photo else (bytes(self.photo)),
            b'' if not self.caption else (TLObject.serialize_bytes(self.caption)),
            b'' if not self.ttl_seconds else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 2:
            _caption = reader.tgread_string()
        else:
            _caption = None
        if flags & 4:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return MessageMediaPhoto(photo=_photo, caption=_caption, ttl_seconds=_ttl_seconds)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageMediaUnsupported(TLObject):
    CONSTRUCTOR_ID = 0x9f84f49e
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x9e\xf4\x84\x9f',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageMediaUnsupported()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0x7912b71f
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, geo, title, address, provider, venue_id):
        """
        :param TLObject geo:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.geo = geo
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id

    def to_dict(self, recursive=True):
        return {
            'geo': (None if self.geo is None else self.geo.to_dict()) if recursive else self.geo,
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\xb7\x12y',
            bytes(self.geo),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.address),
            TLObject.serialize_bytes(self.provider),
            TLObject.serialize_bytes(self.venue_id),
        ))

    @staticmethod
    def from_reader(reader):
        _geo = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        return MessageMediaVenue(geo=_geo, title=_title, address=_address, provider=_provider, venue_id=_venue_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageMediaWebPage(TLObject):
    CONSTRUCTOR_ID = 0xa32dd600
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, webpage):
        """
        :param TLObject webpage:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice.
        """
        super().__init__()

        self.webpage = webpage

    def to_dict(self, recursive=True):
        return {
            'webpage': (None if self.webpage is None else self.webpage.to_dict()) if recursive else self.webpage,
        }

    def __bytes__(self):
        return b''.join((
            b'\x00\xd6-\xa3',
            bytes(self.webpage),
        ))

    @staticmethod
    def from_reader(reader):
        _webpage = reader.tgread_object()
        return MessageMediaWebPage(webpage=_webpage)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageRange(TLObject):
    CONSTRUCTOR_ID = 0xae30253
    SUBCLASS_OF_ID = 0xbec74577

    def __init__(self, min_id, max_id):
        """
        :param int min_id:
        :param int max_id:

        Constructor for MessageRange: Instance of MessageRange.
        """
        super().__init__()

        self.min_id = min_id
        self.max_id = max_id

    def to_dict(self, recursive=True):
        return {
            'min_id': self.min_id,
            'max_id': self.max_id,
        }

    def __bytes__(self):
        return b''.join((
            b'S\x02\xe3\n',
            struct.pack('<i', self.min_id),
            struct.pack('<i', self.max_id),
        ))

    @staticmethod
    def from_reader(reader):
        _min_id = reader.read_int()
        _max_id = reader.read_int()
        return MessageRange(min_id=_min_id, max_id=_max_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageService(TLObject):
    CONSTRUCTOR_ID = 0x9e19a1f6
    SUBCLASS_OF_ID = 0x790009e3

    def __init__(self, id, to_id, date, action, out=None, mentioned=None, media_unread=None, silent=None, post=None, from_id=None, reply_to_msg_id=None):
        """
        :param bool | None out:
        :param bool | None mentioned:
        :param bool | None media_unread:
        :param bool | None silent:
        :param bool | None post:
        :param int id:
        :param int | None from_id:
        :param TLObject to_id:
        :param int | None reply_to_msg_id:
        :param datetime.datetime | None date:
        :param TLObject action:

        Constructor for Message: Instance of either MessageEmpty, Message, MessageService.
        """
        super().__init__()

        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.post = post
        self.id = id
        self.from_id = from_id
        self.to_id = to_id
        self.reply_to_msg_id = reply_to_msg_id
        self.date = date
        self.action = action

    def to_dict(self, recursive=True):
        return {
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'post': self.post,
            'id': self.id,
            'from_id': self.from_id,
            'to_id': (None if self.to_id is None else self.to_id.to_dict()) if recursive else self.to_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'date': self.date,
            'action': (None if self.action is None else self.action.to_dict()) if recursive else self.action,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xa1\x19\x9e',
            struct.pack('<I', (2 if self.out else 0) | (16 if self.mentioned else 0) | (32 if self.media_unread else 0) | (8192 if self.silent else 0) | (16384 if self.post else 0) | (256 if self.from_id else 0) | (8 if self.reply_to_msg_id else 0)),
            struct.pack('<i', self.id),
            b'' if not self.from_id else (struct.pack('<i', self.from_id)),
            bytes(self.to_id),
            b'' if not self.reply_to_msg_id else (struct.pack('<i', self.reply_to_msg_id)),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            bytes(self.action),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _mentioned = bool(flags & 16)
        _media_unread = bool(flags & 32)
        _silent = bool(flags & 8192)
        _post = bool(flags & 16384)
        _id = reader.read_int()
        if flags & 256:
            _from_id = reader.read_int()
        else:
            _from_id = None
        _to_id = reader.tgread_object()
        if flags & 8:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _date = reader.tgread_date()
        _action = reader.tgread_object()
        return MessageService(id=_id, to_id=_to_id, date=_date, action=_action, out=_out, mentioned=_mentioned, media_unread=_media_unread, silent=_silent, post=_post, from_id=_from_id, reply_to_msg_id=_reply_to_msg_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MsgDetailedInfo(TLObject):
    CONSTRUCTOR_ID = 0x276d3ec6
    SUBCLASS_OF_ID = 0x5f32d5ee

    def __init__(self, msg_id, answer_msg_id, bytes, status):
        """
        :param int msg_id:
        :param int answer_msg_id:
        :param int bytes:
        :param int status:

        Constructor for MsgDetailedInfo: Instance of either MsgDetailedInfo, MsgNewDetailedInfo.
        """
        super().__init__()

        self.msg_id = msg_id
        self.answer_msg_id = answer_msg_id
        self.bytes = bytes
        self.status = status

    def to_dict(self, recursive=True):
        return {
            'msg_id': self.msg_id,
            'answer_msg_id': self.answer_msg_id,
            'bytes': self.bytes,
            'status': self.status,
        }

    def __bytes__(self):
        return b''.join((
            b"\xc6>m'",
            struct.pack('<q', self.msg_id),
            struct.pack('<q', self.answer_msg_id),
            struct.pack('<i', self.bytes),
            struct.pack('<i', self.status),
        ))

    @staticmethod
    def from_reader(reader):
        _msg_id = reader.read_long()
        _answer_msg_id = reader.read_long()
        _bytes = reader.read_int()
        _status = reader.read_int()
        return MsgDetailedInfo(msg_id=_msg_id, answer_msg_id=_answer_msg_id, bytes=_bytes, status=_status)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MsgNewDetailedInfo(TLObject):
    CONSTRUCTOR_ID = 0x809db6df
    SUBCLASS_OF_ID = 0x5f32d5ee

    def __init__(self, answer_msg_id, bytes, status):
        """
        :param int answer_msg_id:
        :param int bytes:
        :param int status:

        Constructor for MsgDetailedInfo: Instance of either MsgDetailedInfo, MsgNewDetailedInfo.
        """
        super().__init__()

        self.answer_msg_id = answer_msg_id
        self.bytes = bytes
        self.status = status

    def to_dict(self, recursive=True):
        return {
            'answer_msg_id': self.answer_msg_id,
            'bytes': self.bytes,
            'status': self.status,
        }

    def __bytes__(self):
        return b''.join((
            b'\xdf\xb6\x9d\x80',
            struct.pack('<q', self.answer_msg_id),
            struct.pack('<i', self.bytes),
            struct.pack('<i', self.status),
        ))

    @staticmethod
    def from_reader(reader):
        _answer_msg_id = reader.read_long()
        _bytes = reader.read_int()
        _status = reader.read_int()
        return MsgNewDetailedInfo(answer_msg_id=_answer_msg_id, bytes=_bytes, status=_status)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MsgResendReq(TLObject):
    CONSTRUCTOR_ID = 0x7d861a08
    SUBCLASS_OF_ID = 0x2024514

    def __init__(self, msg_ids):
        """
        :param list[int] msg_ids:

        Constructor for MsgResendReq: Instance of MsgResendReq.
        """
        super().__init__()

        self.msg_ids = msg_ids

    def to_dict(self, recursive=True):
        return {
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\x08\x1a\x86}',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        return MsgResendReq(msg_ids=_msg_ids)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MsgsAck(TLObject):
    CONSTRUCTOR_ID = 0x62d6b459
    SUBCLASS_OF_ID = 0x827677c4

    def __init__(self, msg_ids):
        """
        :param list[int] msg_ids:

        Constructor for MsgsAck: Instance of MsgsAck.
        """
        super().__init__()

        self.msg_ids = msg_ids

    def to_dict(self, recursive=True):
        return {
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:],
        }

    def __bytes__(self):
        return b''.join((
            b'Y\xb4\xd6b',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        return MsgsAck(msg_ids=_msg_ids)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MsgsAllInfo(TLObject):
    CONSTRUCTOR_ID = 0x8cc0d131
    SUBCLASS_OF_ID = 0xfa8fcb54

    def __init__(self, msg_ids, info):
        """
        :param list[int] msg_ids:
        :param str info:

        Constructor for MsgsAllInfo: Instance of MsgsAllInfo.
        """
        super().__init__()

        self.msg_ids = msg_ids
        self.info = info

    def to_dict(self, recursive=True):
        return {
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:],
            'info': self.info,
        }

    def __bytes__(self):
        return b''.join((
            b'1\xd1\xc0\x8c',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
            TLObject.serialize_bytes(self.info),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        _info = reader.tgread_string()
        return MsgsAllInfo(msg_ids=_msg_ids, info=_info)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MsgsStateInfo(TLObject):
    CONSTRUCTOR_ID = 0x4deb57d
    SUBCLASS_OF_ID = 0x70a0a64

    def __init__(self, req_msg_id, info):
        """
        :param int req_msg_id:
        :param str info:

        Constructor for MsgsStateInfo: Instance of MsgsStateInfo.
        """
        super().__init__()

        self.req_msg_id = req_msg_id
        self.info = info

    def to_dict(self, recursive=True):
        return {
            'req_msg_id': self.req_msg_id,
            'info': self.info,
        }

    def __bytes__(self):
        return b''.join((
            b'}\xb5\xde\x04',
            struct.pack('<q', self.req_msg_id),
            TLObject.serialize_bytes(self.info),
        ))

    @staticmethod
    def from_reader(reader):
        _req_msg_id = reader.read_long()
        _info = reader.tgread_string()
        return MsgsStateInfo(req_msg_id=_req_msg_id, info=_info)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MsgsStateReq(TLObject):
    CONSTRUCTOR_ID = 0xda69fb52
    SUBCLASS_OF_ID = 0x18f01dd0

    def __init__(self, msg_ids):
        """
        :param list[int] msg_ids:

        Constructor for MsgsStateReq: Instance of MsgsStateReq.
        """
        super().__init__()

        self.msg_ids = msg_ids

    def to_dict(self, recursive=True):
        return {
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:],
        }

    def __bytes__(self):
        return b''.join((
            b'R\xfbi\xda',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        return MsgsStateReq(msg_ids=_msg_ids)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class NearestDc(TLObject):
    CONSTRUCTOR_ID = 0x8e1a1775
    SUBCLASS_OF_ID = 0x3877045f

    def __init__(self, country, this_dc, nearest_dc):
        """
        :param str country:
        :param int this_dc:
        :param int nearest_dc:

        Constructor for NearestDc: Instance of NearestDc.
        """
        super().__init__()

        self.country = country
        self.this_dc = this_dc
        self.nearest_dc = nearest_dc

    def to_dict(self, recursive=True):
        return {
            'country': self.country,
            'this_dc': self.this_dc,
            'nearest_dc': self.nearest_dc,
        }

    def __bytes__(self):
        return b''.join((
            b'u\x17\x1a\x8e',
            TLObject.serialize_bytes(self.country),
            struct.pack('<i', self.this_dc),
            struct.pack('<i', self.nearest_dc),
        ))

    @staticmethod
    def from_reader(reader):
        _country = reader.tgread_string()
        _this_dc = reader.read_int()
        _nearest_dc = reader.read_int()
        return NearestDc(country=_country, this_dc=_this_dc, nearest_dc=_nearest_dc)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class NewSessionCreated(TLObject):
    CONSTRUCTOR_ID = 0x9ec20908
    SUBCLASS_OF_ID = 0x510d3031

    def __init__(self, first_msg_id, unique_id, server_salt):
        """
        :param int first_msg_id:
        :param int unique_id:
        :param int server_salt:

        Constructor for NewSession: Instance of NewSessionCreated.
        """
        super().__init__()

        self.first_msg_id = first_msg_id
        self.unique_id = unique_id
        self.server_salt = server_salt

    def to_dict(self, recursive=True):
        return {
            'first_msg_id': self.first_msg_id,
            'unique_id': self.unique_id,
            'server_salt': self.server_salt,
        }

    def __bytes__(self):
        return b''.join((
            b'\x08\t\xc2\x9e',
            struct.pack('<q', self.first_msg_id),
            struct.pack('<q', self.unique_id),
            struct.pack('<q', self.server_salt),
        ))

    @staticmethod
    def from_reader(reader):
        _first_msg_id = reader.read_long()
        _unique_id = reader.read_long()
        _server_salt = reader.read_long()
        return NewSessionCreated(first_msg_id=_first_msg_id, unique_id=_unique_id, server_salt=_server_salt)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class NotifyAll(TLObject):
    CONSTRUCTOR_ID = 0x74d07c60
    SUBCLASS_OF_ID = 0xdfe8602e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'`|\xd0t',
        ))

    @staticmethod
    def from_reader(reader):
        return NotifyAll()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class NotifyChats(TLObject):
    CONSTRUCTOR_ID = 0xc007cec3
    SUBCLASS_OF_ID = 0xdfe8602e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xc3\xce\x07\xc0',
        ))

    @staticmethod
    def from_reader(reader):
        return NotifyChats()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class NotifyPeer(TLObject):
    CONSTRUCTOR_ID = 0x9fd40bd8
    SUBCLASS_OF_ID = 0xdfe8602e

    def __init__(self, peer):
        """
        :param TLObject peer:

        Constructor for NotifyPeer: Instance of either NotifyPeer, NotifyUsers, NotifyChats, NotifyAll.
        """
        super().__init__()

        self.peer = peer

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd8\x0b\xd4\x9f',
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        return NotifyPeer(peer=_peer)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class NotifyUsers(TLObject):
    CONSTRUCTOR_ID = 0xb4c83b4c
    SUBCLASS_OF_ID = 0xdfe8602e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'L;\xc8\xb4',
        ))

    @staticmethod
    def from_reader(reader):
        return NotifyUsers()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Null(TLObject):
    CONSTRUCTOR_ID = 0x56730bcc
    SUBCLASS_OF_ID = 0x85f95371

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xcc\x0bsV',
        ))

    @staticmethod
    def from_reader(reader):
        return Null()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PQInnerData(TLObject):
    CONSTRUCTOR_ID = 0x83c95aec
    SUBCLASS_OF_ID = 0x41701377

    def __init__(self, pq, p, q, nonce, server_nonce, new_nonce):
        """
        :param bytes pq:
        :param bytes p:
        :param bytes q:
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce:

        Constructor for P_Q_inner_data: Instance of PQInnerData.
        """
        super().__init__()

        self.pq = pq
        self.p = p
        self.q = q
        self.nonce = nonce
        self.server_nonce = server_nonce
        self.new_nonce = new_nonce

    def to_dict(self, recursive=True):
        return {
            'pq': self.pq,
            'p': self.p,
            'q': self.q,
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce': self.new_nonce,
        }

    def __bytes__(self):
        return b''.join((
            b'\xecZ\xc9\x83',
            TLObject.serialize_bytes(self.pq),
            TLObject.serialize_bytes(self.p),
            TLObject.serialize_bytes(self.q),
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce.to_bytes(32, 'little', signed=True),
        ))

    @staticmethod
    def from_reader(reader):
        _pq = reader.tgread_bytes()
        _p = reader.tgread_bytes()
        _q = reader.tgread_bytes()
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce = reader.read_large_int(bits=256)
        return PQInnerData(pq=_pq, p=_p, q=_q, nonce=_nonce, server_nonce=_server_nonce, new_nonce=_new_nonce)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockAnchor(TLObject):
    CONSTRUCTOR_ID = 0xce0d37b0
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, name):
        """
        :param str name:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.name = name

    def to_dict(self, recursive=True):
        return {
            'name': self.name,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb07\r\xce',
            TLObject.serialize_bytes(self.name),
        ))

    @staticmethod
    def from_reader(reader):
        _name = reader.tgread_string()
        return PageBlockAnchor(name=_name)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockAudio(TLObject):
    CONSTRUCTOR_ID = 0x31b81a7f
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, audio_id, caption):
        """
        :param int audio_id:
        :param TLObject caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.audio_id = audio_id
        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'audio_id': self.audio_id,
            'caption': (None if self.caption is None else self.caption.to_dict()) if recursive else self.caption,
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\x1a\xb81',
            struct.pack('<q', self.audio_id),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        _audio_id = reader.read_long()
        _caption = reader.tgread_object()
        return PageBlockAudio(audio_id=_audio_id, caption=_caption)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockAuthorDate(TLObject):
    CONSTRUCTOR_ID = 0xbaafe5e0
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, author, published_date):
        """
        :param TLObject author:
        :param datetime.datetime | None published_date:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.author = author
        self.published_date = published_date

    def to_dict(self, recursive=True):
        return {
            'author': (None if self.author is None else self.author.to_dict()) if recursive else self.author,
            'published_date': self.published_date,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe0\xe5\xaf\xba',
            bytes(self.author),
            b'\0\0\0\0' if self.published_date is None else struct.pack('<I', int(self.published_date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _author = reader.tgread_object()
        _published_date = reader.tgread_date()
        return PageBlockAuthorDate(author=_author, published_date=_published_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockBlockquote(TLObject):
    CONSTRUCTOR_ID = 0x263d7c26
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text, caption):
        """
        :param TLObject text:
        :param TLObject caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text
        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
            'caption': (None if self.caption is None else self.caption.to_dict()) if recursive else self.caption,
        }

    def __bytes__(self):
        return b''.join((
            b'&|=&',
            bytes(self.text),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        _caption = reader.tgread_object()
        return PageBlockBlockquote(text=_text, caption=_caption)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockChannel(TLObject):
    CONSTRUCTOR_ID = 0xef1751b5
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, channel):
        """
        :param TLObject channel:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.channel = channel

    def to_dict(self, recursive=True):
        return {
            'channel': (None if self.channel is None else self.channel.to_dict()) if recursive else self.channel,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb5Q\x17\xef',
            bytes(self.channel),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        return PageBlockChannel(channel=_channel)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockCollage(TLObject):
    CONSTRUCTOR_ID = 0x8b31c4f
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, items, caption):
        """
        :param list[TLObject] items:
        :param TLObject caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.items = items
        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'items': ([] if self.items is None else [None if x is None else x.to_dict() for x in self.items]) if recursive else self.items,
            'caption': (None if self.caption is None else self.caption.to_dict()) if recursive else self.caption,
        }

    def __bytes__(self):
        return b''.join((
            b'O\x1c\xb3\x08',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.items)),b''.join(bytes(x) for x in self.items),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _items = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _items.append(_x)

        _caption = reader.tgread_object()
        return PageBlockCollage(items=_items, caption=_caption)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockCover(TLObject):
    CONSTRUCTOR_ID = 0x39f23300
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, cover):
        """
        :param TLObject cover:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.cover = cover

    def to_dict(self, recursive=True):
        return {
            'cover': (None if self.cover is None else self.cover.to_dict()) if recursive else self.cover,
        }

    def __bytes__(self):
        return b''.join((
            b'\x003\xf29',
            bytes(self.cover),
        ))

    @staticmethod
    def from_reader(reader):
        _cover = reader.tgread_object()
        return PageBlockCover(cover=_cover)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockDivider(TLObject):
    CONSTRUCTOR_ID = 0xdb20b188
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x88\xb1 \xdb',
        ))

    @staticmethod
    def from_reader(reader):
        return PageBlockDivider()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockEmbed(TLObject):
    CONSTRUCTOR_ID = 0xcde200d1
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, w, h, caption, full_width=None, allow_scrolling=None, url=None, html=None, poster_photo_id=None):
        """
        :param bool | None full_width:
        :param bool | None allow_scrolling:
        :param str | None url:
        :param str | None html:
        :param int | None poster_photo_id:
        :param int w:
        :param int h:
        :param TLObject caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.full_width = full_width
        self.allow_scrolling = allow_scrolling
        self.url = url
        self.html = html
        self.poster_photo_id = poster_photo_id
        self.w = w
        self.h = h
        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'full_width': self.full_width,
            'allow_scrolling': self.allow_scrolling,
            'url': self.url,
            'html': self.html,
            'poster_photo_id': self.poster_photo_id,
            'w': self.w,
            'h': self.h,
            'caption': (None if self.caption is None else self.caption.to_dict()) if recursive else self.caption,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd1\x00\xe2\xcd',
            struct.pack('<I', (1 if self.full_width else 0) | (8 if self.allow_scrolling else 0) | (2 if self.url else 0) | (4 if self.html else 0) | (16 if self.poster_photo_id else 0)),
            b'' if not self.url else (TLObject.serialize_bytes(self.url)),
            b'' if not self.html else (TLObject.serialize_bytes(self.html)),
            b'' if not self.poster_photo_id else (struct.pack('<q', self.poster_photo_id)),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _full_width = bool(flags & 1)
        _allow_scrolling = bool(flags & 8)
        if flags & 2:
            _url = reader.tgread_string()
        else:
            _url = None
        if flags & 4:
            _html = reader.tgread_string()
        else:
            _html = None
        if flags & 16:
            _poster_photo_id = reader.read_long()
        else:
            _poster_photo_id = None
        _w = reader.read_int()
        _h = reader.read_int()
        _caption = reader.tgread_object()
        return PageBlockEmbed(w=_w, h=_h, caption=_caption, full_width=_full_width, allow_scrolling=_allow_scrolling, url=_url, html=_html, poster_photo_id=_poster_photo_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockEmbedPost(TLObject):
    CONSTRUCTOR_ID = 0x292c7be9
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, url, webpage_id, author_photo_id, author, date, blocks, caption):
        """
        :param str url:
        :param int webpage_id:
        :param int author_photo_id:
        :param str author:
        :param datetime.datetime | None date:
        :param list[TLObject] blocks:
        :param TLObject caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.url = url
        self.webpage_id = webpage_id
        self.author_photo_id = author_photo_id
        self.author = author
        self.date = date
        self.blocks = blocks
        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'webpage_id': self.webpage_id,
            'author_photo_id': self.author_photo_id,
            'author': self.author,
            'date': self.date,
            'blocks': ([] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks]) if recursive else self.blocks,
            'caption': (None if self.caption is None else self.caption.to_dict()) if recursive else self.caption,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe9{,)',
            TLObject.serialize_bytes(self.url),
            struct.pack('<q', self.webpage_id),
            struct.pack('<q', self.author_photo_id),
            TLObject.serialize_bytes(self.author),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.blocks)),b''.join(bytes(x) for x in self.blocks),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _webpage_id = reader.read_long()
        _author_photo_id = reader.read_long()
        _author = reader.tgread_string()
        _date = reader.tgread_date()
        reader.read_int()
        _blocks = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _blocks.append(_x)

        _caption = reader.tgread_object()
        return PageBlockEmbedPost(url=_url, webpage_id=_webpage_id, author_photo_id=_author_photo_id, author=_author, date=_date, blocks=_blocks, caption=_caption)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockFooter(TLObject):
    CONSTRUCTOR_ID = 0x48870999
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\x99\t\x87H',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockFooter(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockHeader(TLObject):
    CONSTRUCTOR_ID = 0xbfd064ec
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\xecd\xd0\xbf',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockHeader(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockList(TLObject):
    CONSTRUCTOR_ID = 0x3a58c7f4
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, ordered, items):
        """
        :param TLObject ordered:
        :param list[TLObject] items:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.ordered = ordered
        self.items = items

    def to_dict(self, recursive=True):
        return {
            'ordered': self.ordered,
            'items': ([] if self.items is None else [None if x is None else x.to_dict() for x in self.items]) if recursive else self.items,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf4\xc7X:',
            b'\xb5ur\x99' if self.ordered else b'7\x97y\xbc',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.items)),b''.join(bytes(x) for x in self.items),
        ))

    @staticmethod
    def from_reader(reader):
        _ordered = reader.tgread_bool()
        reader.read_int()
        _items = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _items.append(_x)

        return PageBlockList(ordered=_ordered, items=_items)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockParagraph(TLObject):
    CONSTRUCTOR_ID = 0x467a0766
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'f\x07zF',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockParagraph(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockPhoto(TLObject):
    CONSTRUCTOR_ID = 0xe9c69982
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, photo_id, caption):
        """
        :param int photo_id:
        :param TLObject caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.photo_id = photo_id
        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'photo_id': self.photo_id,
            'caption': (None if self.caption is None else self.caption.to_dict()) if recursive else self.caption,
        }

    def __bytes__(self):
        return b''.join((
            b'\x82\x99\xc6\xe9',
            struct.pack('<q', self.photo_id),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        _photo_id = reader.read_long()
        _caption = reader.tgread_object()
        return PageBlockPhoto(photo_id=_photo_id, caption=_caption)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockPreformatted(TLObject):
    CONSTRUCTOR_ID = 0xc070d93e
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text, language):
        """
        :param TLObject text:
        :param str language:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text
        self.language = language

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
            'language': self.language,
        }

    def __bytes__(self):
        return b''.join((
            b'>\xd9p\xc0',
            bytes(self.text),
            TLObject.serialize_bytes(self.language),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        _language = reader.tgread_string()
        return PageBlockPreformatted(text=_text, language=_language)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockPullquote(TLObject):
    CONSTRUCTOR_ID = 0x4f4456d3
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text, caption):
        """
        :param TLObject text:
        :param TLObject caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text
        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
            'caption': (None if self.caption is None else self.caption.to_dict()) if recursive else self.caption,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd3VDO',
            bytes(self.text),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        _caption = reader.tgread_object()
        return PageBlockPullquote(text=_text, caption=_caption)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockSlideshow(TLObject):
    CONSTRUCTOR_ID = 0x130c8963
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, items, caption):
        """
        :param list[TLObject] items:
        :param TLObject caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.items = items
        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'items': ([] if self.items is None else [None if x is None else x.to_dict() for x in self.items]) if recursive else self.items,
            'caption': (None if self.caption is None else self.caption.to_dict()) if recursive else self.caption,
        }

    def __bytes__(self):
        return b''.join((
            b'c\x89\x0c\x13',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.items)),b''.join(bytes(x) for x in self.items),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _items = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _items.append(_x)

        _caption = reader.tgread_object()
        return PageBlockSlideshow(items=_items, caption=_caption)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockSubheader(TLObject):
    CONSTRUCTOR_ID = 0xf12bb6e1
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xb6+\xf1',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockSubheader(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockSubtitle(TLObject):
    CONSTRUCTOR_ID = 0x8ffa9a1f
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\x9a\xfa\x8f',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockSubtitle(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockTitle(TLObject):
    CONSTRUCTOR_ID = 0x70abc3fd
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\xc3\xabp',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockTitle(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockUnsupported(TLObject):
    CONSTRUCTOR_ID = 0x13567e8a
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x8a~V\x13',
        ))

    @staticmethod
    def from_reader(reader):
        return PageBlockUnsupported()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageBlockVideo(TLObject):
    CONSTRUCTOR_ID = 0xd9d71866
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, video_id, caption, autoplay=None, loop=None):
        """
        :param bool | None autoplay:
        :param bool | None loop:
        :param int video_id:
        :param TLObject caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.autoplay = autoplay
        self.loop = loop
        self.video_id = video_id
        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'autoplay': self.autoplay,
            'loop': self.loop,
            'video_id': self.video_id,
            'caption': (None if self.caption is None else self.caption.to_dict()) if recursive else self.caption,
        }

    def __bytes__(self):
        return b''.join((
            b'f\x18\xd7\xd9',
            struct.pack('<I', (1 if self.autoplay else 0) | (2 if self.loop else 0)),
            struct.pack('<q', self.video_id),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _autoplay = bool(flags & 1)
        _loop = bool(flags & 2)
        _video_id = reader.read_long()
        _caption = reader.tgread_object()
        return PageBlockVideo(video_id=_video_id, caption=_caption, autoplay=_autoplay, loop=_loop)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PageFull(TLObject):
    CONSTRUCTOR_ID = 0x556ec7aa
    SUBCLASS_OF_ID = 0xb438191e

    def __init__(self, blocks, photos, documents):
        """
        :param list[TLObject] blocks:
        :param list[TLObject] photos:
        :param list[TLObject] documents:

        Constructor for Page: Instance of either PagePart, PageFull.
        """
        super().__init__()

        self.blocks = blocks
        self.photos = photos
        self.documents = documents

    def to_dict(self, recursive=True):
        return {
            'blocks': ([] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks]) if recursive else self.blocks,
            'photos': ([] if self.photos is None else [None if x is None else x.to_dict() for x in self.photos]) if recursive else self.photos,
            'documents': ([] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents]) if recursive else self.documents,
        }

    def __bytes__(self):
        return b''.join((
            b'\xaa\xc7nU',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.blocks)),b''.join(bytes(x) for x in self.blocks),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.photos)),b''.join(bytes(x) for x in self.photos),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(bytes(x) for x in self.documents),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _blocks = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _blocks.append(_x)

        reader.read_int()
        _photos = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _photos.append(_x)

        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _documents.append(_x)

        return PageFull(blocks=_blocks, photos=_photos, documents=_documents)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PagePart(TLObject):
    CONSTRUCTOR_ID = 0x8e3f9ebe
    SUBCLASS_OF_ID = 0xb438191e

    def __init__(self, blocks, photos, documents):
        """
        :param list[TLObject] blocks:
        :param list[TLObject] photos:
        :param list[TLObject] documents:

        Constructor for Page: Instance of either PagePart, PageFull.
        """
        super().__init__()

        self.blocks = blocks
        self.photos = photos
        self.documents = documents

    def to_dict(self, recursive=True):
        return {
            'blocks': ([] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks]) if recursive else self.blocks,
            'photos': ([] if self.photos is None else [None if x is None else x.to_dict() for x in self.photos]) if recursive else self.photos,
            'documents': ([] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents]) if recursive else self.documents,
        }

    def __bytes__(self):
        return b''.join((
            b'\xbe\x9e?\x8e',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.blocks)),b''.join(bytes(x) for x in self.blocks),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.photos)),b''.join(bytes(x) for x in self.photos),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(bytes(x) for x in self.documents),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _blocks = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _blocks.append(_x)

        reader.read_int()
        _photos = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _photos.append(_x)

        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _documents.append(_x)

        return PagePart(blocks=_blocks, photos=_photos, documents=_documents)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PaymentCharge(TLObject):
    CONSTRUCTOR_ID = 0xea02c27e
    SUBCLASS_OF_ID = 0x3cc830d9

    def __init__(self, id, provider_charge_id):
        """
        :param str id:
        :param str provider_charge_id:

        Constructor for PaymentCharge: Instance of PaymentCharge.
        """
        super().__init__()

        self.id = id
        self.provider_charge_id = provider_charge_id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'provider_charge_id': self.provider_charge_id,
        }

    def __bytes__(self):
        return b''.join((
            b'~\xc2\x02\xea',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.provider_charge_id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _provider_charge_id = reader.tgread_string()
        return PaymentCharge(id=_id, provider_charge_id=_provider_charge_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PaymentRequestedInfo(TLObject):
    CONSTRUCTOR_ID = 0x909c3f94
    SUBCLASS_OF_ID = 0x8db03146

    def __init__(self, name=None, phone=None, email=None, shipping_address=None):
        """
        :param str | None name:
        :param str | None phone:
        :param str | None email:
        :param TLObject | None shipping_address:

        Constructor for PaymentRequestedInfo: Instance of PaymentRequestedInfo.
        """
        super().__init__()

        self.name = name
        self.phone = phone
        self.email = email
        self.shipping_address = shipping_address

    def to_dict(self, recursive=True):
        return {
            'name': self.name,
            'phone': self.phone,
            'email': self.email,
            'shipping_address': (None if self.shipping_address is None else self.shipping_address.to_dict()) if recursive else self.shipping_address,
        }

    def __bytes__(self):
        return b''.join((
            b'\x94?\x9c\x90',
            struct.pack('<I', (1 if self.name else 0) | (2 if self.phone else 0) | (4 if self.email else 0) | (8 if self.shipping_address else 0)),
            b'' if not self.name else (TLObject.serialize_bytes(self.name)),
            b'' if not self.phone else (TLObject.serialize_bytes(self.phone)),
            b'' if not self.email else (TLObject.serialize_bytes(self.email)),
            b'' if not self.shipping_address else (bytes(self.shipping_address)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 1:
            _name = reader.tgread_string()
        else:
            _name = None
        if flags & 2:
            _phone = reader.tgread_string()
        else:
            _phone = None
        if flags & 4:
            _email = reader.tgread_string()
        else:
            _email = None
        if flags & 8:
            _shipping_address = reader.tgread_object()
        else:
            _shipping_address = None
        return PaymentRequestedInfo(name=_name, phone=_phone, email=_email, shipping_address=_shipping_address)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PaymentSavedCredentialsCard(TLObject):
    CONSTRUCTOR_ID = 0xcdc27a1f
    SUBCLASS_OF_ID = 0xb3627ee3

    def __init__(self, id, title):
        """
        :param str id:
        :param str title:

        Constructor for PaymentSavedCredentials: Instance of PaymentSavedCredentialsCard.
        """
        super().__init__()

        self.id = id
        self.title = title

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'title': self.title,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1fz\xc2\xcd',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _title = reader.tgread_string()
        return PaymentSavedCredentialsCard(id=_id, title=_title)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PeerChannel(TLObject):
    CONSTRUCTOR_ID = 0xbddde532
    SUBCLASS_OF_ID = 0x2d45687

    def __init__(self, channel_id):
        """
        :param int channel_id:

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        super().__init__()

        self.channel_id = channel_id

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
        }

    def __bytes__(self):
        return b''.join((
            b'2\xe5\xdd\xbd',
            struct.pack('<i', self.channel_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        return PeerChannel(channel_id=_channel_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PeerChat(TLObject):
    CONSTRUCTOR_ID = 0xbad0e5bb
    SUBCLASS_OF_ID = 0x2d45687

    def __init__(self, chat_id):
        """
        :param int chat_id:

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        super().__init__()

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb\xe5\xd0\xba',
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        return PeerChat(chat_id=_chat_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PeerNotifyEventsAll(TLObject):
    CONSTRUCTOR_ID = 0x6d1ded88
    SUBCLASS_OF_ID = 0x180c8bc4

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x88\xed\x1dm',
        ))

    @staticmethod
    def from_reader(reader):
        return PeerNotifyEventsAll()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PeerNotifyEventsEmpty(TLObject):
    CONSTRUCTOR_ID = 0xadd53cb3
    SUBCLASS_OF_ID = 0x180c8bc4

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xb3<\xd5\xad',
        ))

    @staticmethod
    def from_reader(reader):
        return PeerNotifyEventsEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PeerNotifySettings(TLObject):
    CONSTRUCTOR_ID = 0x9acda4c0
    SUBCLASS_OF_ID = 0xcf20c074

    def __init__(self, mute_until, sound, show_previews=None, silent=None):
        """
        :param bool | None show_previews:
        :param bool | None silent:
        :param int mute_until:
        :param str sound:

        Constructor for PeerNotifySettings: Instance of either PeerNotifySettingsEmpty, PeerNotifySettings.
        """
        super().__init__()

        self.show_previews = show_previews
        self.silent = silent
        self.mute_until = mute_until
        self.sound = sound

    def to_dict(self, recursive=True):
        return {
            'show_previews': self.show_previews,
            'silent': self.silent,
            'mute_until': self.mute_until,
            'sound': self.sound,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc0\xa4\xcd\x9a',
            struct.pack('<I', (1 if self.show_previews else 0) | (2 if self.silent else 0)),
            struct.pack('<i', self.mute_until),
            TLObject.serialize_bytes(self.sound),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _show_previews = bool(flags & 1)
        _silent = bool(flags & 2)
        _mute_until = reader.read_int()
        _sound = reader.tgread_string()
        return PeerNotifySettings(mute_until=_mute_until, sound=_sound, show_previews=_show_previews, silent=_silent)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PeerNotifySettingsEmpty(TLObject):
    CONSTRUCTOR_ID = 0x70a68512
    SUBCLASS_OF_ID = 0xcf20c074

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x12\x85\xa6p',
        ))

    @staticmethod
    def from_reader(reader):
        return PeerNotifySettingsEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PeerSettings(TLObject):
    CONSTRUCTOR_ID = 0x818426cd
    SUBCLASS_OF_ID = 0xf6a79f84

    def __init__(self, report_spam=None):
        """
        :param bool | None report_spam:

        Constructor for PeerSettings: Instance of PeerSettings.
        """
        super().__init__()

        self.report_spam = report_spam

    def to_dict(self, recursive=True):
        return {
            'report_spam': self.report_spam,
        }

    def __bytes__(self):
        return b''.join((
            b'\xcd&\x84\x81',
            struct.pack('<I', (1 if self.report_spam else 0)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _report_spam = bool(flags & 1)
        return PeerSettings(report_spam=_report_spam)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PeerUser(TLObject):
    CONSTRUCTOR_ID = 0x9db1bc6d
    SUBCLASS_OF_ID = 0x2d45687

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        super().__init__()

        self.user_id = user_id

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
        }

    def __bytes__(self):
        return b''.join((
            b'm\xbc\xb1\x9d',
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        return PeerUser(user_id=_user_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCall(TLObject):
    CONSTRUCTOR_ID = 0xffe6ab67
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_or_b, key_fingerprint, protocol, connection, alternative_connections, start_date):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a_or_b:
        :param int key_fingerprint:
        :param TLObject protocol:
        :param TLObject connection:
        :param list[TLObject] alternative_connections:
        :param datetime.datetime | None start_date:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a_or_b = g_a_or_b
        self.key_fingerprint = key_fingerprint
        self.protocol = protocol
        self.connection = connection
        self.alternative_connections = alternative_connections
        self.start_date = start_date

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_or_b': self.g_a_or_b,
            'key_fingerprint': self.key_fingerprint,
            'protocol': (None if self.protocol is None else self.protocol.to_dict()) if recursive else self.protocol,
            'connection': (None if self.connection is None else self.connection.to_dict()) if recursive else self.connection,
            'alternative_connections': ([] if self.alternative_connections is None else [None if x is None else x.to_dict() for x in self.alternative_connections]) if recursive else self.alternative_connections,
            'start_date': self.start_date,
        }

    def __bytes__(self):
        return b''.join((
            b'g\xab\xe6\xff',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            TLObject.serialize_bytes(self.g_a_or_b),
            struct.pack('<q', self.key_fingerprint),
            bytes(self.protocol),
            bytes(self.connection),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.alternative_connections)),b''.join(bytes(x) for x in self.alternative_connections),
            b'\0\0\0\0' if self.start_date is None else struct.pack('<I', int(self.start_date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a_or_b = reader.tgread_bytes()
        _key_fingerprint = reader.read_long()
        _protocol = reader.tgread_object()
        _connection = reader.tgread_object()
        reader.read_int()
        _alternative_connections = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _alternative_connections.append(_x)

        _start_date = reader.tgread_date()
        return PhoneCall(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a_or_b=_g_a_or_b, key_fingerprint=_key_fingerprint, protocol=_protocol, connection=_connection, alternative_connections=_alternative_connections, start_date=_start_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCallAccepted(TLObject):
    CONSTRUCTOR_ID = 0x6d003d3f
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_b, protocol):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_b:
        :param TLObject protocol:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_b = g_b
        self.protocol = protocol

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_b': self.g_b,
            'protocol': (None if self.protocol is None else self.protocol.to_dict()) if recursive else self.protocol,
        }

    def __bytes__(self):
        return b''.join((
            b'?=\x00m',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            TLObject.serialize_bytes(self.g_b),
            bytes(self.protocol),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_b = reader.tgread_bytes()
        _protocol = reader.tgread_object()
        return PhoneCallAccepted(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_b=_g_b, protocol=_protocol)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCallDiscardReasonBusy(TLObject):
    CONSTRUCTOR_ID = 0xfaf7e8c9
    SUBCLASS_OF_ID = 0xd89bad3d

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xc9\xe8\xf7\xfa',
        ))

    @staticmethod
    def from_reader(reader):
        return PhoneCallDiscardReasonBusy()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCallDiscardReasonDisconnect(TLObject):
    CONSTRUCTOR_ID = 0xe095c1a0
    SUBCLASS_OF_ID = 0xd89bad3d

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xa0\xc1\x95\xe0',
        ))

    @staticmethod
    def from_reader(reader):
        return PhoneCallDiscardReasonDisconnect()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCallDiscardReasonHangup(TLObject):
    CONSTRUCTOR_ID = 0x57adc690
    SUBCLASS_OF_ID = 0xd89bad3d

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x90\xc6\xadW',
        ))

    @staticmethod
    def from_reader(reader):
        return PhoneCallDiscardReasonHangup()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCallDiscardReasonMissed(TLObject):
    CONSTRUCTOR_ID = 0x85e42301
    SUBCLASS_OF_ID = 0xd89bad3d

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x01#\xe4\x85',
        ))

    @staticmethod
    def from_reader(reader):
        return PhoneCallDiscardReasonMissed()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCallDiscarded(TLObject):
    CONSTRUCTOR_ID = 0x50ca4de1
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, need_rating=None, need_debug=None, reason=None, duration=None):
        """
        :param bool | None need_rating:
        :param bool | None need_debug:
        :param int id:
        :param TLObject | None reason:
        :param int | None duration:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.need_rating = need_rating
        self.need_debug = need_debug
        self.id = id
        self.reason = reason
        self.duration = duration

    def to_dict(self, recursive=True):
        return {
            'need_rating': self.need_rating,
            'need_debug': self.need_debug,
            'id': self.id,
            'reason': (None if self.reason is None else self.reason.to_dict()) if recursive else self.reason,
            'duration': self.duration,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1M\xcaP',
            struct.pack('<I', (4 if self.need_rating else 0) | (8 if self.need_debug else 0) | (1 if self.reason else 0) | (2 if self.duration else 0)),
            struct.pack('<q', self.id),
            b'' if not self.reason else (bytes(self.reason)),
            b'' if not self.duration else (struct.pack('<i', self.duration)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _need_rating = bool(flags & 4)
        _need_debug = bool(flags & 8)
        _id = reader.read_long()
        if flags & 1:
            _reason = reader.tgread_object()
        else:
            _reason = None
        if flags & 2:
            _duration = reader.read_int()
        else:
            _duration = None
        return PhoneCallDiscarded(id=_id, need_rating=_need_rating, need_debug=_need_debug, reason=_reason, duration=_duration)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCallEmpty(TLObject):
    CONSTRUCTOR_ID = 0x5366c915
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id):
        """
        :param int id:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x15\xc9fS',
            struct.pack('<q', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        return PhoneCallEmpty(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCallProtocol(TLObject):
    CONSTRUCTOR_ID = 0xa2bb35cb
    SUBCLASS_OF_ID = 0x783991a3

    def __init__(self, min_layer, max_layer, udp_p2p=None, udp_reflector=None):
        """
        :param bool | None udp_p2p:
        :param bool | None udp_reflector:
        :param int min_layer:
        :param int max_layer:

        Constructor for PhoneCallProtocol: Instance of PhoneCallProtocol.
        """
        super().__init__()

        self.udp_p2p = udp_p2p
        self.udp_reflector = udp_reflector
        self.min_layer = min_layer
        self.max_layer = max_layer

    def to_dict(self, recursive=True):
        return {
            'udp_p2p': self.udp_p2p,
            'udp_reflector': self.udp_reflector,
            'min_layer': self.min_layer,
            'max_layer': self.max_layer,
        }

    def __bytes__(self):
        return b''.join((
            b'\xcb5\xbb\xa2',
            struct.pack('<I', (1 if self.udp_p2p else 0) | (2 if self.udp_reflector else 0)),
            struct.pack('<i', self.min_layer),
            struct.pack('<i', self.max_layer),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _udp_p2p = bool(flags & 1)
        _udp_reflector = bool(flags & 2)
        _min_layer = reader.read_int()
        _max_layer = reader.read_int()
        return PhoneCallProtocol(min_layer=_min_layer, max_layer=_max_layer, udp_p2p=_udp_p2p, udp_reflector=_udp_reflector)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCallRequested(TLObject):
    CONSTRUCTOR_ID = 0x83761ce4
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_hash, protocol):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a_hash:
        :param TLObject protocol:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a_hash = g_a_hash
        self.protocol = protocol

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_hash': self.g_a_hash,
            'protocol': (None if self.protocol is None else self.protocol.to_dict()) if recursive else self.protocol,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4\x1cv\x83',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            TLObject.serialize_bytes(self.g_a_hash),
            bytes(self.protocol),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a_hash = reader.tgread_bytes()
        _protocol = reader.tgread_object()
        return PhoneCallRequested(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a_hash=_g_a_hash, protocol=_protocol)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneCallWaiting(TLObject):
    CONSTRUCTOR_ID = 0x1b8f4ad1
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, protocol, receive_date=None):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param TLObject protocol:
        :param datetime.datetime | None receive_date:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.protocol = protocol
        self.receive_date = receive_date

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'protocol': (None if self.protocol is None else self.protocol.to_dict()) if recursive else self.protocol,
            'receive_date': self.receive_date,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd1J\x8f\x1b',
            struct.pack('<I', (1 if self.receive_date else 0)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            bytes(self.protocol),
            b'' if not self.receive_date else (b'\0\0\0\0' if self.receive_date is None else struct.pack('<I', int(self.receive_date.timestamp()))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _protocol = reader.tgread_object()
        if flags & 1:
            _receive_date = reader.tgread_date()
        else:
            _receive_date = None
        return PhoneCallWaiting(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, protocol=_protocol, receive_date=_receive_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhoneConnection(TLObject):
    CONSTRUCTOR_ID = 0x9d4c17c0
    SUBCLASS_OF_ID = 0xaa8de40d

    def __init__(self, id, ip, ipv6, port, peer_tag):
        """
        :param int id:
        :param str ip:
        :param str ipv6:
        :param int port:
        :param bytes peer_tag:

        Constructor for PhoneConnection: Instance of PhoneConnection.
        """
        super().__init__()

        self.id = id
        self.ip = ip
        self.ipv6 = ipv6
        self.port = port
        self.peer_tag = peer_tag

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'ip': self.ip,
            'ipv6': self.ipv6,
            'port': self.port,
            'peer_tag': self.peer_tag,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc0\x17L\x9d',
            struct.pack('<q', self.id),
            TLObject.serialize_bytes(self.ip),
            TLObject.serialize_bytes(self.ipv6),
            struct.pack('<i', self.port),
            TLObject.serialize_bytes(self.peer_tag),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _ip = reader.tgread_string()
        _ipv6 = reader.tgread_string()
        _port = reader.read_int()
        _peer_tag = reader.tgread_bytes()
        return PhoneConnection(id=_id, ip=_ip, ipv6=_ipv6, port=_port, peer_tag=_peer_tag)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Photo(TLObject):
    CONSTRUCTOR_ID = 0x9288dd29
    SUBCLASS_OF_ID = 0xd576ab1c

    def __init__(self, id, access_hash, date, sizes, has_stickers=None):
        """
        :param bool | None has_stickers:
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param list[TLObject] sizes:

        Constructor for Photo: Instance of either PhotoEmpty, Photo.
        """
        super().__init__()

        self.has_stickers = has_stickers
        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.sizes = sizes

    def to_dict(self, recursive=True):
        return {
            'has_stickers': self.has_stickers,
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'sizes': ([] if self.sizes is None else [None if x is None else x.to_dict() for x in self.sizes]) if recursive else self.sizes,
        }

    def __bytes__(self):
        return b''.join((
            b')\xdd\x88\x92',
            struct.pack('<I', (1 if self.has_stickers else 0)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sizes)),b''.join(bytes(x) for x in self.sizes),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _has_stickers = bool(flags & 1)
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        reader.read_int()
        _sizes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sizes.append(_x)

        return Photo(id=_id, access_hash=_access_hash, date=_date, sizes=_sizes, has_stickers=_has_stickers)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhotoCachedSize(TLObject):
    CONSTRUCTOR_ID = 0xe9a734fa
    SUBCLASS_OF_ID = 0x17cc29d9

    def __init__(self, type, location, w, h, bytes):
        """
        :param str type:
        :param TLObject location:
        :param int w:
        :param int h:
        :param bytes bytes:

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        super().__init__()

        self.type = type
        self.location = location
        self.w = w
        self.h = h
        self.bytes = bytes

    def to_dict(self, recursive=True):
        return {
            'type': self.type,
            'location': (None if self.location is None else self.location.to_dict()) if recursive else self.location,
            'w': self.w,
            'h': self.h,
            'bytes': self.bytes,
        }

    def __bytes__(self):
        return b''.join((
            b'\xfa4\xa7\xe9',
            TLObject.serialize_bytes(self.type),
            bytes(self.location),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
            TLObject.serialize_bytes(self.bytes),
        ))

    @staticmethod
    def from_reader(reader):
        _type = reader.tgread_string()
        _location = reader.tgread_object()
        _w = reader.read_int()
        _h = reader.read_int()
        _bytes = reader.tgread_bytes()
        return PhotoCachedSize(type=_type, location=_location, w=_w, h=_h, bytes=_bytes)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x2331b22d
    SUBCLASS_OF_ID = 0xd576ab1c

    def __init__(self, id):
        """
        :param int id:

        Constructor for Photo: Instance of either PhotoEmpty, Photo.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'-\xb21#',
            struct.pack('<q', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        return PhotoEmpty(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhotoSize(TLObject):
    CONSTRUCTOR_ID = 0x77bfb61b
    SUBCLASS_OF_ID = 0x17cc29d9

    def __init__(self, type, location, w, h, size):
        """
        :param str type:
        :param TLObject location:
        :param int w:
        :param int h:
        :param int size:

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        super().__init__()

        self.type = type
        self.location = location
        self.w = w
        self.h = h
        self.size = size

    def to_dict(self, recursive=True):
        return {
            'type': self.type,
            'location': (None if self.location is None else self.location.to_dict()) if recursive else self.location,
            'w': self.w,
            'h': self.h,
            'size': self.size,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1b\xb6\xbfw',
            TLObject.serialize_bytes(self.type),
            bytes(self.location),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
            struct.pack('<i', self.size),
        ))

    @staticmethod
    def from_reader(reader):
        _type = reader.tgread_string()
        _location = reader.tgread_object()
        _w = reader.read_int()
        _h = reader.read_int()
        _size = reader.read_int()
        return PhotoSize(type=_type, location=_location, w=_w, h=_h, size=_size)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PhotoSizeEmpty(TLObject):
    CONSTRUCTOR_ID = 0xe17e23c
    SUBCLASS_OF_ID = 0x17cc29d9

    def __init__(self, type):
        """
        :param str type:

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        super().__init__()

        self.type = type

    def to_dict(self, recursive=True):
        return {
            'type': self.type,
        }

    def __bytes__(self):
        return b''.join((
            b'<\xe2\x17\x0e',
            TLObject.serialize_bytes(self.type),
        ))

    @staticmethod
    def from_reader(reader):
        _type = reader.tgread_string()
        return PhotoSizeEmpty(type=_type)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Pong(TLObject):
    CONSTRUCTOR_ID = 0x347773c5
    SUBCLASS_OF_ID = 0x816aee71

    def __init__(self, msg_id, ping_id):
        """
        :param int msg_id:
        :param int ping_id:

        Constructor for Pong: Instance of Pong.
        """
        super().__init__()

        self.msg_id = msg_id
        self.ping_id = ping_id

    def to_dict(self, recursive=True):
        return {
            'msg_id': self.msg_id,
            'ping_id': self.ping_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5sw4',
            struct.pack('<q', self.msg_id),
            struct.pack('<q', self.ping_id),
        ))

    @staticmethod
    def from_reader(reader):
        _msg_id = reader.read_long()
        _ping_id = reader.read_long()
        return Pong(msg_id=_msg_id, ping_id=_ping_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PopularContact(TLObject):
    CONSTRUCTOR_ID = 0x5ce14175
    SUBCLASS_OF_ID = 0x409255a

    def __init__(self, client_id, importers):
        """
        :param int client_id:
        :param int importers:

        Constructor for PopularContact: Instance of PopularContact.
        """
        super().__init__()

        self.client_id = client_id
        self.importers = importers

    def to_dict(self, recursive=True):
        return {
            'client_id': self.client_id,
            'importers': self.importers,
        }

    def __bytes__(self):
        return b''.join((
            b'uA\xe1\\',
            struct.pack('<q', self.client_id),
            struct.pack('<i', self.importers),
        ))

    @staticmethod
    def from_reader(reader):
        _client_id = reader.read_long()
        _importers = reader.read_int()
        return PopularContact(client_id=_client_id, importers=_importers)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PostAddress(TLObject):
    CONSTRUCTOR_ID = 0x1e8caaeb
    SUBCLASS_OF_ID = 0x8d7eda2c

    def __init__(self, street_line1, street_line2, city, state, country_iso2, post_code):
        """
        :param str street_line1:
        :param str street_line2:
        :param str city:
        :param str state:
        :param str country_iso2:
        :param str post_code:

        Constructor for PostAddress: Instance of PostAddress.
        """
        super().__init__()

        self.street_line1 = street_line1
        self.street_line2 = street_line2
        self.city = city
        self.state = state
        self.country_iso2 = country_iso2
        self.post_code = post_code

    def to_dict(self, recursive=True):
        return {
            'street_line1': self.street_line1,
            'street_line2': self.street_line2,
            'city': self.city,
            'state': self.state,
            'country_iso2': self.country_iso2,
            'post_code': self.post_code,
        }

    def __bytes__(self):
        return b''.join((
            b'\xeb\xaa\x8c\x1e',
            TLObject.serialize_bytes(self.street_line1),
            TLObject.serialize_bytes(self.street_line2),
            TLObject.serialize_bytes(self.city),
            TLObject.serialize_bytes(self.state),
            TLObject.serialize_bytes(self.country_iso2),
            TLObject.serialize_bytes(self.post_code),
        ))

    @staticmethod
    def from_reader(reader):
        _street_line1 = reader.tgread_string()
        _street_line2 = reader.tgread_string()
        _city = reader.tgread_string()
        _state = reader.tgread_string()
        _country_iso2 = reader.tgread_string()
        _post_code = reader.tgread_string()
        return PostAddress(street_line1=_street_line1, street_line2=_street_line2, city=_city, state=_state, country_iso2=_country_iso2, post_code=_post_code)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PrivacyKeyChatInvite(TLObject):
    CONSTRUCTOR_ID = 0x500e6dfa
    SUBCLASS_OF_ID = 0x824651c3

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xfam\x0eP',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyKeyChatInvite()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PrivacyKeyPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0x3d662b7b
    SUBCLASS_OF_ID = 0x824651c3

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'{+f=',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyKeyPhoneCall()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PrivacyKeyStatusTimestamp(TLObject):
    CONSTRUCTOR_ID = 0xbc2eab30
    SUBCLASS_OF_ID = 0x824651c3

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'0\xab.\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyKeyStatusTimestamp()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PrivacyValueAllowAll(TLObject):
    CONSTRUCTOR_ID = 0x65427b82
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x82{Be',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyValueAllowAll()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PrivacyValueAllowContacts(TLObject):
    CONSTRUCTOR_ID = 0xfffe1bac
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xac\x1b\xfe\xff',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyValueAllowContacts()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PrivacyValueAllowUsers(TLObject):
    CONSTRUCTOR_ID = 0x4d5bbe0c
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self, users):
        """
        :param list[int] users:

        Constructor for PrivacyRule: Instance of either PrivacyValueAllowContacts, PrivacyValueAllowAll, PrivacyValueAllowUsers, PrivacyValueDisallowContacts, PrivacyValueDisallowAll, PrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users

    def to_dict(self, recursive=True):
        return {
            'users': [] if self.users is None else self.users[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c\xbe[M',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return PrivacyValueAllowUsers(users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PrivacyValueDisallowAll(TLObject):
    CONSTRUCTOR_ID = 0x8b73e763
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'c\xe7s\x8b',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyValueDisallowAll()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PrivacyValueDisallowContacts(TLObject):
    CONSTRUCTOR_ID = 0xf888fa1a
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x1a\xfa\x88\xf8',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyValueDisallowContacts()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PrivacyValueDisallowUsers(TLObject):
    CONSTRUCTOR_ID = 0xc7f49b7
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self, users):
        """
        :param list[int] users:

        Constructor for PrivacyRule: Instance of either PrivacyValueAllowContacts, PrivacyValueAllowAll, PrivacyValueAllowUsers, PrivacyValueDisallowContacts, PrivacyValueDisallowAll, PrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users

    def to_dict(self, recursive=True):
        return {
            'users': [] if self.users is None else self.users[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\xb7I\x7f\x0c',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return PrivacyValueDisallowUsers(users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReceivedNotifyMessage(TLObject):
    CONSTRUCTOR_ID = 0xa384b779
    SUBCLASS_OF_ID = 0xa962381e

    def __init__(self, id, flags):
        """
        :param int id:
        :param int flags:

        Constructor for ReceivedNotifyMessage: Instance of ReceivedNotifyMessage.
        """
        super().__init__()

        self.id = id
        self.flags = flags

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'flags': self.flags,
        }

    def __bytes__(self):
        return b''.join((
            b'y\xb7\x84\xa3',
            struct.pack('<i', self.id),
            struct.pack('<i', self.flags),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _flags = reader.read_int()
        return ReceivedNotifyMessage(id=_id, flags=_flags)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReplyInlineMarkup(TLObject):
    CONSTRUCTOR_ID = 0x48a30254
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, rows):
        """
        :param list[TLObject] rows:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.rows = rows

    def to_dict(self, recursive=True):
        return {
            'rows': ([] if self.rows is None else [None if x is None else x.to_dict() for x in self.rows]) if recursive else self.rows,
        }

    def __bytes__(self):
        return b''.join((
            b'T\x02\xa3H',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rows)),b''.join(bytes(x) for x in self.rows),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _rows = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rows.append(_x)

        return ReplyInlineMarkup(rows=_rows)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReplyKeyboardForceReply(TLObject):
    CONSTRUCTOR_ID = 0xf4108aa0
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, single_use=None, selective=None):
        """
        :param bool | None single_use:
        :param bool | None selective:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.single_use = single_use
        self.selective = selective

    def to_dict(self, recursive=True):
        return {
            'single_use': self.single_use,
            'selective': self.selective,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\x8a\x10\xf4',
            struct.pack('<I', (2 if self.single_use else 0) | (4 if self.selective else 0)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _single_use = bool(flags & 2)
        _selective = bool(flags & 4)
        return ReplyKeyboardForceReply(single_use=_single_use, selective=_selective)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReplyKeyboardHide(TLObject):
    CONSTRUCTOR_ID = 0xa03e5b85
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, selective=None):
        """
        :param bool | None selective:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.selective = selective

    def to_dict(self, recursive=True):
        return {
            'selective': self.selective,
        }

    def __bytes__(self):
        return b''.join((
            b'\x85[>\xa0',
            struct.pack('<I', (4 if self.selective else 0)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _selective = bool(flags & 4)
        return ReplyKeyboardHide(selective=_selective)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ReplyKeyboardMarkup(TLObject):
    CONSTRUCTOR_ID = 0x3502758c
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, rows, resize=None, single_use=None, selective=None):
        """
        :param bool | None resize:
        :param bool | None single_use:
        :param bool | None selective:
        :param list[TLObject] rows:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.resize = resize
        self.single_use = single_use
        self.selective = selective
        self.rows = rows

    def to_dict(self, recursive=True):
        return {
            'resize': self.resize,
            'single_use': self.single_use,
            'selective': self.selective,
            'rows': ([] if self.rows is None else [None if x is None else x.to_dict() for x in self.rows]) if recursive else self.rows,
        }

    def __bytes__(self):
        return b''.join((
            b'\x8cu\x025',
            struct.pack('<I', (1 if self.resize else 0) | (2 if self.single_use else 0) | (4 if self.selective else 0)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rows)),b''.join(bytes(x) for x in self.rows),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _resize = bool(flags & 1)
        _single_use = bool(flags & 2)
        _selective = bool(flags & 4)
        reader.read_int()
        _rows = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rows.append(_x)

        return ReplyKeyboardMarkup(rows=_rows, resize=_resize, single_use=_single_use, selective=_selective)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ResPQ(TLObject):
    CONSTRUCTOR_ID = 0x5162463
    SUBCLASS_OF_ID = 0x786986b8

    def __init__(self, nonce, server_nonce, pq, server_public_key_fingerprints):
        """
        :param int nonce:
        :param int server_nonce:
        :param bytes pq:
        :param list[int] server_public_key_fingerprints:

        Constructor for ResPQ: Instance of ResPQ.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.pq = pq
        self.server_public_key_fingerprints = server_public_key_fingerprints

    def to_dict(self, recursive=True):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'pq': self.pq,
            'server_public_key_fingerprints': [] if self.server_public_key_fingerprints is None else self.server_public_key_fingerprints[:],
        }

    def __bytes__(self):
        return b''.join((
            b'c$\x16\x05',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            TLObject.serialize_bytes(self.pq),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.server_public_key_fingerprints)),b''.join(struct.pack('<q', x) for x in self.server_public_key_fingerprints),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _pq = reader.tgread_bytes()
        reader.read_int()
        _server_public_key_fingerprints = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _server_public_key_fingerprints.append(_x)

        return ResPQ(nonce=_nonce, server_nonce=_server_nonce, pq=_pq, server_public_key_fingerprints=_server_public_key_fingerprints)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class RpcAnswerDropped(TLObject):
    CONSTRUCTOR_ID = 0xa43ad8b7
    SUBCLASS_OF_ID = 0x4bca7570

    def __init__(self, msg_id, seq_no, bytes):
        """
        :param int msg_id:
        :param int seq_no:
        :param int bytes:

        Constructor for RpcDropAnswer: Instance of either RpcAnswerUnknown, RpcAnswerDroppedRunning, RpcAnswerDropped.
        """
        super().__init__()

        self.msg_id = msg_id
        self.seq_no = seq_no
        self.bytes = bytes

    def to_dict(self, recursive=True):
        return {
            'msg_id': self.msg_id,
            'seq_no': self.seq_no,
            'bytes': self.bytes,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb7\xd8:\xa4',
            struct.pack('<q', self.msg_id),
            struct.pack('<i', self.seq_no),
            struct.pack('<i', self.bytes),
        ))

    @staticmethod
    def from_reader(reader):
        _msg_id = reader.read_long()
        _seq_no = reader.read_int()
        _bytes = reader.read_int()
        return RpcAnswerDropped(msg_id=_msg_id, seq_no=_seq_no, bytes=_bytes)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class RpcAnswerDroppedRunning(TLObject):
    CONSTRUCTOR_ID = 0xcd78e586
    SUBCLASS_OF_ID = 0x4bca7570

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x86\xe5x\xcd',
        ))

    @staticmethod
    def from_reader(reader):
        return RpcAnswerDroppedRunning()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class RpcAnswerUnknown(TLObject):
    CONSTRUCTOR_ID = 0x5e2ad36e
    SUBCLASS_OF_ID = 0x4bca7570

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'n\xd3*^',
        ))

    @staticmethod
    def from_reader(reader):
        return RpcAnswerUnknown()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class RpcError(TLObject):
    CONSTRUCTOR_ID = 0x2144ca19
    SUBCLASS_OF_ID = 0x4a17e265

    def __init__(self, error_code, error_message):
        """
        :param int error_code:
        :param str error_message:

        Constructor for RpcError: Instance of RpcError.
        """
        super().__init__()

        self.error_code = error_code
        self.error_message = error_message

    def to_dict(self, recursive=True):
        return {
            'error_code': self.error_code,
            'error_message': self.error_message,
        }

    def __bytes__(self):
        return b''.join((
            b'\x19\xcaD!',
            struct.pack('<i', self.error_code),
            TLObject.serialize_bytes(self.error_message),
        ))

    @staticmethod
    def from_reader(reader):
        _error_code = reader.read_int()
        _error_message = reader.tgread_string()
        return RpcError(error_code=_error_code, error_message=_error_message)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageCancelAction(TLObject):
    CONSTRUCTOR_ID = 0xfd5ec8f5
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xf5\xc8^\xfd',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageCancelAction()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageChooseContactAction(TLObject):
    CONSTRUCTOR_ID = 0x628cbc6f
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'o\xbc\x8cb',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageChooseContactAction()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageGamePlayAction(TLObject):
    CONSTRUCTOR_ID = 0xdd6a8f48
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'H\x8fj\xdd',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageGamePlayAction()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageGeoLocationAction(TLObject):
    CONSTRUCTOR_ID = 0x176f8ba1
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xa1\x8bo\x17',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageGeoLocationAction()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageRecordAudioAction(TLObject):
    CONSTRUCTOR_ID = 0xd52f73f7
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xf7s/\xd5',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageRecordAudioAction()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageRecordRoundAction(TLObject):
    CONSTRUCTOR_ID = 0x88f27fbc
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xbc\x7f\xf2\x88',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageRecordRoundAction()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageRecordVideoAction(TLObject):
    CONSTRUCTOR_ID = 0xa187d66f
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'o\xd6\x87\xa1',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageRecordVideoAction()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageTypingAction(TLObject):
    CONSTRUCTOR_ID = 0x16bf744e
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'Nt\xbf\x16',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageTypingAction()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageUploadAudioAction(TLObject):
    CONSTRUCTOR_ID = 0xf351d7ab
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress

    def to_dict(self, recursive=True):
        return {
            'progress': self.progress,
        }

    def __bytes__(self):
        return b''.join((
            b'\xab\xd7Q\xf3',
            struct.pack('<i', self.progress),
        ))

    @staticmethod
    def from_reader(reader):
        _progress = reader.read_int()
        return SendMessageUploadAudioAction(progress=_progress)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageUploadDocumentAction(TLObject):
    CONSTRUCTOR_ID = 0xaa0cd9e4
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress

    def to_dict(self, recursive=True):
        return {
            'progress': self.progress,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4\xd9\x0c\xaa',
            struct.pack('<i', self.progress),
        ))

    @staticmethod
    def from_reader(reader):
        _progress = reader.read_int()
        return SendMessageUploadDocumentAction(progress=_progress)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageUploadPhotoAction(TLObject):
    CONSTRUCTOR_ID = 0xd1d34a26
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress

    def to_dict(self, recursive=True):
        return {
            'progress': self.progress,
        }

    def __bytes__(self):
        return b''.join((
            b'&J\xd3\xd1',
            struct.pack('<i', self.progress),
        ))

    @staticmethod
    def from_reader(reader):
        _progress = reader.read_int()
        return SendMessageUploadPhotoAction(progress=_progress)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageUploadRoundAction(TLObject):
    CONSTRUCTOR_ID = 0x243e1c66
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress

    def to_dict(self, recursive=True):
        return {
            'progress': self.progress,
        }

    def __bytes__(self):
        return b''.join((
            b'f\x1c>$',
            struct.pack('<i', self.progress),
        ))

    @staticmethod
    def from_reader(reader):
        _progress = reader.read_int()
        return SendMessageUploadRoundAction(progress=_progress)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SendMessageUploadVideoAction(TLObject):
    CONSTRUCTOR_ID = 0xe9763aec
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress

    def to_dict(self, recursive=True):
        return {
            'progress': self.progress,
        }

    def __bytes__(self):
        return b''.join((
            b'\xec:v\xe9',
            struct.pack('<i', self.progress),
        ))

    @staticmethod
    def from_reader(reader):
        _progress = reader.read_int()
        return SendMessageUploadVideoAction(progress=_progress)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ServerDHInnerData(TLObject):
    CONSTRUCTOR_ID = 0xb5890dba
    SUBCLASS_OF_ID = 0xc69a67bc

    def __init__(self, nonce, server_nonce, g, dh_prime, g_a, server_time):
        """
        :param int nonce:
        :param int server_nonce:
        :param int g:
        :param bytes dh_prime:
        :param bytes g_a:
        :param int server_time:

        Constructor for Server_DH_inner_data: Instance of ServerDHInnerData.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.g = g
        self.dh_prime = dh_prime
        self.g_a = g_a
        self.server_time = server_time

    def to_dict(self, recursive=True):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'g': self.g,
            'dh_prime': self.dh_prime,
            'g_a': self.g_a,
            'server_time': self.server_time,
        }

    def __bytes__(self):
        return b''.join((
            b'\xba\r\x89\xb5',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            struct.pack('<i', self.g),
            TLObject.serialize_bytes(self.dh_prime),
            TLObject.serialize_bytes(self.g_a),
            struct.pack('<i', self.server_time),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _g = reader.read_int()
        _dh_prime = reader.tgread_bytes()
        _g_a = reader.tgread_bytes()
        _server_time = reader.read_int()
        return ServerDHInnerData(nonce=_nonce, server_nonce=_server_nonce, g=_g, dh_prime=_dh_prime, g_a=_g_a, server_time=_server_time)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ServerDHParamsFail(TLObject):
    CONSTRUCTOR_ID = 0x79cb045d
    SUBCLASS_OF_ID = 0xa6188d9e

    def __init__(self, nonce, server_nonce, new_nonce_hash):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash:

        Constructor for Server_DH_Params: Instance of either ServerDHParamsFail, ServerDHParamsOk.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.new_nonce_hash = new_nonce_hash

    def to_dict(self, recursive=True):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash': self.new_nonce_hash,
        }

    def __bytes__(self):
        return b''.join((
            b']\x04\xcby',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash.to_bytes(16, 'little', signed=True),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash = reader.read_large_int(bits=128)
        return ServerDHParamsFail(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash=_new_nonce_hash)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ServerDHParamsOk(TLObject):
    CONSTRUCTOR_ID = 0xd0e8075c
    SUBCLASS_OF_ID = 0xa6188d9e

    def __init__(self, nonce, server_nonce, encrypted_answer):
        """
        :param int nonce:
        :param int server_nonce:
        :param bytes encrypted_answer:

        Constructor for Server_DH_Params: Instance of either ServerDHParamsFail, ServerDHParamsOk.
        """
        super().__init__()

        self.nonce = nonce
        self.server_nonce = server_nonce
        self.encrypted_answer = encrypted_answer

    def to_dict(self, recursive=True):
        return {
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'encrypted_answer': self.encrypted_answer,
        }

    def __bytes__(self):
        return b''.join((
            b'\\\x07\xe8\xd0',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            TLObject.serialize_bytes(self.encrypted_answer),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _encrypted_answer = reader.tgread_bytes()
        return ServerDHParamsOk(nonce=_nonce, server_nonce=_server_nonce, encrypted_answer=_encrypted_answer)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ShippingOption(TLObject):
    CONSTRUCTOR_ID = 0xb6213cdf
    SUBCLASS_OF_ID = 0xf4e94c78

    def __init__(self, id, title, prices):
        """
        :param str id:
        :param str title:
        :param list[TLObject] prices:

        Constructor for ShippingOption: Instance of ShippingOption.
        """
        super().__init__()

        self.id = id
        self.title = title
        self.prices = prices

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'title': self.title,
            'prices': ([] if self.prices is None else [None if x is None else x.to_dict() for x in self.prices]) if recursive else self.prices,
        }

    def __bytes__(self):
        return b''.join((
            b'\xdf<!\xb6',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.title),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.prices)),b''.join(bytes(x) for x in self.prices),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _title = reader.tgread_string()
        reader.read_int()
        _prices = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _prices.append(_x)

        return ShippingOption(id=_id, title=_title, prices=_prices)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickerPack(TLObject):
    CONSTRUCTOR_ID = 0x12b299d4
    SUBCLASS_OF_ID = 0x9fefa4d4

    def __init__(self, emoticon, documents):
        """
        :param str emoticon:
        :param list[int] documents:

        Constructor for StickerPack: Instance of StickerPack.
        """
        super().__init__()

        self.emoticon = emoticon
        self.documents = documents

    def to_dict(self, recursive=True):
        return {
            'emoticon': self.emoticon,
            'documents': [] if self.documents is None else self.documents[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\xd4\x99\xb2\x12',
            TLObject.serialize_bytes(self.emoticon),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(struct.pack('<q', x) for x in self.documents),
        ))

    @staticmethod
    def from_reader(reader):
        _emoticon = reader.tgread_string()
        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _documents.append(_x)

        return StickerPack(emoticon=_emoticon, documents=_documents)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickerSet(TLObject):
    CONSTRUCTOR_ID = 0xcd303b41
    SUBCLASS_OF_ID = 0xbad3ff91

    def __init__(self, id, access_hash, title, short_name, count, hash, installed=None, archived=None, official=None, masks=None):
        """
        :param bool | None installed:
        :param bool | None archived:
        :param bool | None official:
        :param bool | None masks:
        :param int id:
        :param int access_hash:
        :param str title:
        :param str short_name:
        :param int count:
        :param int hash:

        Constructor for StickerSet: Instance of StickerSet.
        """
        super().__init__()

        self.installed = installed
        self.archived = archived
        self.official = official
        self.masks = masks
        self.id = id
        self.access_hash = access_hash
        self.title = title
        self.short_name = short_name
        self.count = count
        self.hash = hash

    def to_dict(self, recursive=True):
        return {
            'installed': self.installed,
            'archived': self.archived,
            'official': self.official,
            'masks': self.masks,
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'short_name': self.short_name,
            'count': self.count,
            'hash': self.hash,
        }

    def __bytes__(self):
        return b''.join((
            b'A;0\xcd',
            struct.pack('<I', (1 if self.installed else 0) | (2 if self.archived else 0) | (4 if self.official else 0) | (8 if self.masks else 0)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.short_name),
            struct.pack('<i', self.count),
            struct.pack('<i', self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _installed = bool(flags & 1)
        _archived = bool(flags & 2)
        _official = bool(flags & 4)
        _masks = bool(flags & 8)
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _title = reader.tgread_string()
        _short_name = reader.tgread_string()
        _count = reader.read_int()
        _hash = reader.read_int()
        return StickerSet(id=_id, access_hash=_access_hash, title=_title, short_name=_short_name, count=_count, hash=_hash, installed=_installed, archived=_archived, official=_official, masks=_masks)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickerSetCovered(TLObject):
    CONSTRUCTOR_ID = 0x6410a5d2
    SUBCLASS_OF_ID = 0x7f86e4e5

    def __init__(self, set, cover):
        """
        :param TLObject set:
        :param TLObject cover:

        Constructor for StickerSetCovered: Instance of either StickerSetCovered, StickerSetMultiCovered.
        """
        super().__init__()

        self.set = set
        self.cover = cover

    def to_dict(self, recursive=True):
        return {
            'set': (None if self.set is None else self.set.to_dict()) if recursive else self.set,
            'cover': (None if self.cover is None else self.cover.to_dict()) if recursive else self.cover,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd2\xa5\x10d',
            bytes(self.set),
            bytes(self.cover),
        ))

    @staticmethod
    def from_reader(reader):
        _set = reader.tgread_object()
        _cover = reader.tgread_object()
        return StickerSetCovered(set=_set, cover=_cover)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickerSetMultiCovered(TLObject):
    CONSTRUCTOR_ID = 0x3407e51b
    SUBCLASS_OF_ID = 0x7f86e4e5

    def __init__(self, set, covers):
        """
        :param TLObject set:
        :param list[TLObject] covers:

        Constructor for StickerSetCovered: Instance of either StickerSetCovered, StickerSetMultiCovered.
        """
        super().__init__()

        self.set = set
        self.covers = covers

    def to_dict(self, recursive=True):
        return {
            'set': (None if self.set is None else self.set.to_dict()) if recursive else self.set,
            'covers': ([] if self.covers is None else [None if x is None else x.to_dict() for x in self.covers]) if recursive else self.covers,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1b\xe5\x074',
            bytes(self.set),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.covers)),b''.join(bytes(x) for x in self.covers),
        ))

    @staticmethod
    def from_reader(reader):
        _set = reader.tgread_object()
        reader.read_int()
        _covers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _covers.append(_x)

        return StickerSetMultiCovered(set=_set, covers=_covers)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TextBold(TLObject):
    CONSTRUCTOR_ID = 0x6724abc4
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4\xab$g',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return TextBold(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TextConcat(TLObject):
    CONSTRUCTOR_ID = 0x7e6260d7
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, texts):
        """
        :param list[TLObject] texts:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.texts = texts

    def to_dict(self, recursive=True):
        return {
            'texts': ([] if self.texts is None else [None if x is None else x.to_dict() for x in self.texts]) if recursive else self.texts,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd7`b~',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.texts)),b''.join(bytes(x) for x in self.texts),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _texts = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _texts.append(_x)

        return TextConcat(texts=_texts)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TextEmail(TLObject):
    CONSTRUCTOR_ID = 0xde5a0dd6
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text, email):
        """
        :param TLObject text:
        :param str email:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text
        self.email = email

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
            'email': self.email,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd6\rZ\xde',
            bytes(self.text),
            TLObject.serialize_bytes(self.email),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        _email = reader.tgread_string()
        return TextEmail(text=_text, email=_email)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TextEmpty(TLObject):
    CONSTRUCTOR_ID = 0xdc3d824f
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'O\x82=\xdc',
        ))

    @staticmethod
    def from_reader(reader):
        return TextEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TextFixed(TLObject):
    CONSTRUCTOR_ID = 0x6c3f19b9
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb9\x19?l',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return TextFixed(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TextItalic(TLObject):
    CONSTRUCTOR_ID = 0xd912a59c
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9c\xa5\x12\xd9',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return TextItalic(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TextPlain(TLObject):
    CONSTRUCTOR_ID = 0x744694e0
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param str text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe0\x94Ft',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return TextPlain(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TextStrike(TLObject):
    CONSTRUCTOR_ID = 0x9bf8bb95
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\xbb\xf8\x9b',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return TextStrike(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TextUnderline(TLObject):
    CONSTRUCTOR_ID = 0xc12622c4
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param TLObject text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4"&\xc1',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return TextUnderline(text=_text)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TextUrl(TLObject):
    CONSTRUCTOR_ID = 0x3c2884c1
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text, url, webpage_id):
        """
        :param TLObject text:
        :param str url:
        :param int webpage_id:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text
        self.url = url
        self.webpage_id = webpage_id

    def to_dict(self, recursive=True):
        return {
            'text': (None if self.text is None else self.text.to_dict()) if recursive else self.text,
            'url': self.url,
            'webpage_id': self.webpage_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc1\x84(<',
            bytes(self.text),
            TLObject.serialize_bytes(self.url),
            struct.pack('<q', self.webpage_id),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        _url = reader.tgread_string()
        _webpage_id = reader.read_long()
        return TextUrl(text=_text, url=_url, webpage_id=_webpage_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TopPeer(TLObject):
    CONSTRUCTOR_ID = 0xedcdc05b
    SUBCLASS_OF_ID = 0x6916c601

    def __init__(self, peer, rating):
        """
        :param TLObject peer:
        :param TLObject rating:

        Constructor for TopPeer: Instance of TopPeer.
        """
        super().__init__()

        self.peer = peer
        self.rating = rating

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'rating': self.rating,
        }

    def __bytes__(self):
        return b''.join((
            b'[\xc0\xcd\xed',
            bytes(self.peer),
            struct.pack('<d', self.rating),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _rating = reader.read_double()
        return TopPeer(peer=_peer, rating=_rating)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TopPeerCategoryBotsInline(TLObject):
    CONSTRUCTOR_ID = 0x148677e2
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xe2w\x86\x14',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryBotsInline()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TopPeerCategoryBotsPM(TLObject):
    CONSTRUCTOR_ID = 0xab661b5b
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'[\x1bf\xab',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryBotsPM()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TopPeerCategoryChannels(TLObject):
    CONSTRUCTOR_ID = 0x161d9628
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'(\x96\x1d\x16',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryChannels()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TopPeerCategoryCorrespondents(TLObject):
    CONSTRUCTOR_ID = 0x637b7ed
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xed\xb77\x06',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryCorrespondents()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TopPeerCategoryGroups(TLObject):
    CONSTRUCTOR_ID = 0xbd17a14a
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'J\xa1\x17\xbd',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryGroups()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TopPeerCategoryPeers(TLObject):
    CONSTRUCTOR_ID = 0xfb834291
    SUBCLASS_OF_ID = 0x4aec930

    def __init__(self, category, count, peers):
        """
        :param TLObject category:
        :param int count:
        :param list[TLObject] peers:

        Constructor for TopPeerCategoryPeers: Instance of TopPeerCategoryPeers.
        """
        super().__init__()

        self.category = category
        self.count = count
        self.peers = peers

    def to_dict(self, recursive=True):
        return {
            'category': (None if self.category is None else self.category.to_dict()) if recursive else self.category,
            'count': self.count,
            'peers': ([] if self.peers is None else [None if x is None else x.to_dict() for x in self.peers]) if recursive else self.peers,
        }

    def __bytes__(self):
        return b''.join((
            b'\x91B\x83\xfb',
            bytes(self.category),
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.peers)),b''.join(bytes(x) for x in self.peers),
        ))

    @staticmethod
    def from_reader(reader):
        _category = reader.tgread_object()
        _count = reader.read_int()
        reader.read_int()
        _peers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _peers.append(_x)

        return TopPeerCategoryPeers(category=_category, count=_count, peers=_peers)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class TopPeerCategoryPhoneCalls(TLObject):
    CONSTRUCTOR_ID = 0x1e76a78c
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x8c\xa7v\x1e',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryPhoneCalls()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateBotCallbackQuery(TLObject):
    CONSTRUCTOR_ID = 0xe73547e1
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, peer, msg_id, chat_instance, data=None, game_short_name=None):
        """
        :param int query_id:
        :param int user_id:
        :param TLObject peer:
        :param int msg_id:
        :param int chat_instance:
        :param bytes | None data:
        :param str | None game_short_name:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.user_id = user_id
        self.peer = peer
        self.msg_id = msg_id
        self.chat_instance = chat_instance
        self.data = data
        self.game_short_name = game_short_name

    def to_dict(self, recursive=True):
        return {
            'query_id': self.query_id,
            'user_id': self.user_id,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'msg_id': self.msg_id,
            'chat_instance': self.chat_instance,
            'data': self.data,
            'game_short_name': self.game_short_name,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1G5\xe7',
            struct.pack('<I', (1 if self.data else 0) | (2 if self.game_short_name else 0)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            bytes(self.peer),
            struct.pack('<i', self.msg_id),
            struct.pack('<q', self.chat_instance),
            b'' if not self.data else (TLObject.serialize_bytes(self.data)),
            b'' if not self.game_short_name else (TLObject.serialize_bytes(self.game_short_name)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _peer = reader.tgread_object()
        _msg_id = reader.read_int()
        _chat_instance = reader.read_long()
        if flags & 1:
            _data = reader.tgread_bytes()
        else:
            _data = None
        if flags & 2:
            _game_short_name = reader.tgread_string()
        else:
            _game_short_name = None
        return UpdateBotCallbackQuery(query_id=_query_id, user_id=_user_id, peer=_peer, msg_id=_msg_id, chat_instance=_chat_instance, data=_data, game_short_name=_game_short_name)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateBotInlineQuery(TLObject):
    CONSTRUCTOR_ID = 0x54826690
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, query, offset, geo=None):
        """
        :param int query_id:
        :param int user_id:
        :param str query:
        :param TLObject | None geo:
        :param str offset:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.user_id = user_id
        self.query = query
        self.geo = geo
        self.offset = offset

    def to_dict(self, recursive=True):
        return {
            'query_id': self.query_id,
            'user_id': self.user_id,
            'query': self.query,
            'geo': (None if self.geo is None else self.geo.to_dict()) if recursive else self.geo,
            'offset': self.offset,
        }

    def __bytes__(self):
        return b''.join((
            b'\x90f\x82T',
            struct.pack('<I', (1 if self.geo else 0)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.query),
            b'' if not self.geo else (bytes(self.geo)),
            TLObject.serialize_bytes(self.offset),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _query = reader.tgread_string()
        if flags & 1:
            _geo = reader.tgread_object()
        else:
            _geo = None
        _offset = reader.tgread_string()
        return UpdateBotInlineQuery(query_id=_query_id, user_id=_user_id, query=_query, offset=_offset, geo=_geo)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateBotInlineSend(TLObject):
    CONSTRUCTOR_ID = 0xe48f964
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, query, id, geo=None, msg_id=None):
        """
        :param int user_id:
        :param str query:
        :param TLObject | None geo:
        :param str id:
        :param TLObject | None msg_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.query = query
        self.geo = geo
        self.id = id
        self.msg_id = msg_id

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'query': self.query,
            'geo': (None if self.geo is None else self.geo.to_dict()) if recursive else self.geo,
            'id': self.id,
            'msg_id': (None if self.msg_id is None else self.msg_id.to_dict()) if recursive else self.msg_id,
        }

    def __bytes__(self):
        return b''.join((
            b'd\xf9H\x0e',
            struct.pack('<I', (1 if self.geo else 0) | (2 if self.msg_id else 0)),
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.query),
            b'' if not self.geo else (bytes(self.geo)),
            TLObject.serialize_bytes(self.id),
            b'' if not self.msg_id else (bytes(self.msg_id)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _user_id = reader.read_int()
        _query = reader.tgread_string()
        if flags & 1:
            _geo = reader.tgread_object()
        else:
            _geo = None
        _id = reader.tgread_string()
        if flags & 2:
            _msg_id = reader.tgread_object()
        else:
            _msg_id = None
        return UpdateBotInlineSend(user_id=_user_id, query=_query, id=_id, geo=_geo, msg_id=_msg_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateBotPrecheckoutQuery(TLObject):
    CONSTRUCTOR_ID = 0x5d2f3aa9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, payload, currency, total_amount, info=None, shipping_option_id=None):
        """
        :param int query_id:
        :param int user_id:
        :param bytes payload:
        :param TLObject | None info:
        :param str | None shipping_option_id:
        :param str currency:
        :param int total_amount:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.user_id = user_id
        self.payload = payload
        self.info = info
        self.shipping_option_id = shipping_option_id
        self.currency = currency
        self.total_amount = total_amount

    def to_dict(self, recursive=True):
        return {
            'query_id': self.query_id,
            'user_id': self.user_id,
            'payload': self.payload,
            'info': (None if self.info is None else self.info.to_dict()) if recursive else self.info,
            'shipping_option_id': self.shipping_option_id,
            'currency': self.currency,
            'total_amount': self.total_amount,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa9:/]',
            struct.pack('<I', (1 if self.info else 0) | (2 if self.shipping_option_id else 0)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.payload),
            b'' if not self.info else (bytes(self.info)),
            b'' if not self.shipping_option_id else (TLObject.serialize_bytes(self.shipping_option_id)),
            TLObject.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _payload = reader.tgread_bytes()
        if flags & 1:
            _info = reader.tgread_object()
        else:
            _info = None
        if flags & 2:
            _shipping_option_id = reader.tgread_string()
        else:
            _shipping_option_id = None
        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        return UpdateBotPrecheckoutQuery(query_id=_query_id, user_id=_user_id, payload=_payload, currency=_currency, total_amount=_total_amount, info=_info, shipping_option_id=_shipping_option_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateBotShippingQuery(TLObject):
    CONSTRUCTOR_ID = 0xe0cdc940
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, payload, shipping_address):
        """
        :param int query_id:
        :param int user_id:
        :param bytes payload:
        :param TLObject shipping_address:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.user_id = user_id
        self.payload = payload
        self.shipping_address = shipping_address

    def to_dict(self, recursive=True):
        return {
            'query_id': self.query_id,
            'user_id': self.user_id,
            'payload': self.payload,
            'shipping_address': (None if self.shipping_address is None else self.shipping_address.to_dict()) if recursive else self.shipping_address,
        }

    def __bytes__(self):
        return b''.join((
            b'@\xc9\xcd\xe0',
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.payload),
            bytes(self.shipping_address),
        ))

    @staticmethod
    def from_reader(reader):
        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _payload = reader.tgread_bytes()
        _shipping_address = reader.tgread_object()
        return UpdateBotShippingQuery(query_id=_query_id, user_id=_user_id, payload=_payload, shipping_address=_shipping_address)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateBotWebhookJSON(TLObject):
    CONSTRUCTOR_ID = 0x8317c0c3
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, data):
        """
        :param TLObject data:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.data = data

    def to_dict(self, recursive=True):
        return {
            'data': (None if self.data is None else self.data.to_dict()) if recursive else self.data,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\xc0\x17\x83',
            bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        _data = reader.tgread_object()
        return UpdateBotWebhookJSON(data=_data)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateBotWebhookJSONQuery(TLObject):
    CONSTRUCTOR_ID = 0x9b9240a6
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, data, timeout):
        """
        :param int query_id:
        :param TLObject data:
        :param int timeout:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.data = data
        self.timeout = timeout

    def to_dict(self, recursive=True):
        return {
            'query_id': self.query_id,
            'data': (None if self.data is None else self.data.to_dict()) if recursive else self.data,
            'timeout': self.timeout,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa6@\x92\x9b',
            struct.pack('<q', self.query_id),
            bytes(self.data),
            struct.pack('<i', self.timeout),
        ))

    @staticmethod
    def from_reader(reader):
        _query_id = reader.read_long()
        _data = reader.tgread_object()
        _timeout = reader.read_int()
        return UpdateBotWebhookJSONQuery(query_id=_query_id, data=_data, timeout=_timeout)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChannel(TLObject):
    CONSTRUCTOR_ID = 0xb6d45656
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id):
        """
        :param int channel_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
        }

    def __bytes__(self):
        return b''.join((
            b'VV\xd4\xb6',
            struct.pack('<i', self.channel_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        return UpdateChannel(channel_id=_channel_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChannelMessageViews(TLObject):
    CONSTRUCTOR_ID = 0x98a12b4b
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, id, views):
        """
        :param int channel_id:
        :param int id:
        :param int views:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.id = id
        self.views = views

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
            'id': self.id,
            'views': self.views,
        }

    def __bytes__(self):
        return b''.join((
            b'K+\xa1\x98',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.id),
            struct.pack('<i', self.views),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _id = reader.read_int()
        _views = reader.read_int()
        return UpdateChannelMessageViews(channel_id=_channel_id, id=_id, views=_views)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChannelPinnedMessage(TLObject):
    CONSTRUCTOR_ID = 0x98592475
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, id):
        """
        :param int channel_id:
        :param int id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.id = id

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'u$Y\x98',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _id = reader.read_int()
        return UpdateChannelPinnedMessage(channel_id=_channel_id, id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChannelReadMessagesContents(TLObject):
    CONSTRUCTOR_ID = 0x89893b45
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, messages):
        """
        :param int channel_id:
        :param list[int] messages:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.messages = messages

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
            'messages': [] if self.messages is None else self.messages[:],
        }

    def __bytes__(self):
        return b''.join((
            b'E;\x89\x89',
            struct.pack('<i', self.channel_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        return UpdateChannelReadMessagesContents(channel_id=_channel_id, messages=_messages)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChannelTooLong(TLObject):
    CONSTRUCTOR_ID = 0xeb0467fb
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, pts=None):
        """
        :param int channel_id:
        :param int | None pts:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.pts = pts

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
            'pts': self.pts,
        }

    def __bytes__(self):
        return b''.join((
            b'\xfbg\x04\xeb',
            struct.pack('<I', (1 if self.pts else 0)),
            struct.pack('<i', self.channel_id),
            b'' if not self.pts else (struct.pack('<i', self.pts)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _channel_id = reader.read_int()
        if flags & 1:
            _pts = reader.read_int()
        else:
            _pts = None
        return UpdateChannelTooLong(channel_id=_channel_id, pts=_pts)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChannelWebPage(TLObject):
    CONSTRUCTOR_ID = 0x40771900
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, webpage, pts, pts_count):
        """
        :param int channel_id:
        :param TLObject webpage:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.webpage = webpage
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
            'webpage': (None if self.webpage is None else self.webpage.to_dict()) if recursive else self.webpage,
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\x00\x19w@',
            struct.pack('<i', self.channel_id),
            bytes(self.webpage),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _webpage = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateChannelWebPage(channel_id=_channel_id, webpage=_webpage, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChatAdmins(TLObject):
    CONSTRUCTOR_ID = 0x6e947941
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, enabled, version):
        """
        :param int chat_id:
        :param TLObject enabled:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.enabled = enabled
        self.version = version

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'enabled': self.enabled,
            'version': self.version,
        }

    def __bytes__(self):
        return b''.join((
            b'Ay\x94n',
            struct.pack('<i', self.chat_id),
            b'\xb5ur\x99' if self.enabled else b'7\x97y\xbc',
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _enabled = reader.tgread_bool()
        _version = reader.read_int()
        return UpdateChatAdmins(chat_id=_chat_id, enabled=_enabled, version=_version)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChatParticipantAdd(TLObject):
    CONSTRUCTOR_ID = 0xea4b0e5c
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, inviter_id, date, version):
        """
        :param int chat_id:
        :param int user_id:
        :param int inviter_id:
        :param datetime.datetime | None date:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date
        self.version = version

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date,
            'version': self.version,
        }

    def __bytes__(self):
        return b''.join((
            b'\\\x0eK\xea',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        _version = reader.read_int()
        return UpdateChatParticipantAdd(chat_id=_chat_id, user_id=_user_id, inviter_id=_inviter_id, date=_date, version=_version)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChatParticipantAdmin(TLObject):
    CONSTRUCTOR_ID = 0xb6901959
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, is_admin, version):
        """
        :param int chat_id:
        :param int user_id:
        :param TLObject is_admin:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.user_id = user_id
        self.is_admin = is_admin
        self.version = version

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'is_admin': self.is_admin,
            'version': self.version,
        }

    def __bytes__(self):
        return b''.join((
            b'Y\x19\x90\xb6',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            b'\xb5ur\x99' if self.is_admin else b'7\x97y\xbc',
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _is_admin = reader.tgread_bool()
        _version = reader.read_int()
        return UpdateChatParticipantAdmin(chat_id=_chat_id, user_id=_user_id, is_admin=_is_admin, version=_version)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChatParticipantDelete(TLObject):
    CONSTRUCTOR_ID = 0x6e5f8c22
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, version):
        """
        :param int chat_id:
        :param int user_id:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.user_id = user_id
        self.version = version

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'version': self.version,
        }

    def __bytes__(self):
        return b''.join((
            b'"\x8c_n',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _version = reader.read_int()
        return UpdateChatParticipantDelete(chat_id=_chat_id, user_id=_user_id, version=_version)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChatParticipants(TLObject):
    CONSTRUCTOR_ID = 0x7761198
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, participants):
        """
        :param TLObject participants:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.participants = participants

    def to_dict(self, recursive=True):
        return {
            'participants': (None if self.participants is None else self.participants.to_dict()) if recursive else self.participants,
        }

    def __bytes__(self):
        return b''.join((
            b'\x98\x11v\x07',
            bytes(self.participants),
        ))

    @staticmethod
    def from_reader(reader):
        _participants = reader.tgread_object()
        return UpdateChatParticipants(participants=_participants)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateChatUserTyping(TLObject):
    CONSTRUCTOR_ID = 0x9a65ea1f
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, action):
        """
        :param int chat_id:
        :param int user_id:
        :param TLObject action:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.user_id = user_id
        self.action = action

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'action': (None if self.action is None else self.action.to_dict()) if recursive else self.action,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\xeae\x9a',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            bytes(self.action),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _action = reader.tgread_object()
        return UpdateChatUserTyping(chat_id=_chat_id, user_id=_user_id, action=_action)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateConfig(TLObject):
    CONSTRUCTOR_ID = 0xa229dd06
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x06\xdd)\xa2',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateConfig()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateContactLink(TLObject):
    CONSTRUCTOR_ID = 0x9d2e67c5
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, my_link, foreign_link):
        """
        :param int user_id:
        :param TLObject my_link:
        :param TLObject foreign_link:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.my_link = my_link
        self.foreign_link = foreign_link

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'my_link': (None if self.my_link is None else self.my_link.to_dict()) if recursive else self.my_link,
            'foreign_link': (None if self.foreign_link is None else self.foreign_link.to_dict()) if recursive else self.foreign_link,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5g.\x9d',
            struct.pack('<i', self.user_id),
            bytes(self.my_link),
            bytes(self.foreign_link),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _my_link = reader.tgread_object()
        _foreign_link = reader.tgread_object()
        return UpdateContactLink(user_id=_user_id, my_link=_my_link, foreign_link=_foreign_link)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateContactRegistered(TLObject):
    CONSTRUCTOR_ID = 0x2575bbb9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, date):
        """
        :param int user_id:
        :param datetime.datetime | None date:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb9\xbbu%',
            struct.pack('<i', self.user_id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        return UpdateContactRegistered(user_id=_user_id, date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateContactsReset(TLObject):
    CONSTRUCTOR_ID = 0x7084a7be
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xbe\xa7\x84p',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateContactsReset()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateDcOptions(TLObject):
    CONSTRUCTOR_ID = 0x8e5e9873
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, dc_options):
        """
        :param list[TLObject] dc_options:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.dc_options = dc_options

    def to_dict(self, recursive=True):
        return {
            'dc_options': ([] if self.dc_options is None else [None if x is None else x.to_dict() for x in self.dc_options]) if recursive else self.dc_options,
        }

    def __bytes__(self):
        return b''.join((
            b's\x98^\x8e',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dc_options)),b''.join(bytes(x) for x in self.dc_options),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _dc_options = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dc_options.append(_x)

        return UpdateDcOptions(dc_options=_dc_options)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateDeleteChannelMessages(TLObject):
    CONSTRUCTOR_ID = 0xc37521c9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, messages, pts, pts_count):
        """
        :param int channel_id:
        :param list[int] messages:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9!u\xc3',
            struct.pack('<i', self.channel_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateDeleteChannelMessages(channel_id=_channel_id, messages=_messages, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateDeleteMessages(TLObject):
    CONSTRUCTOR_ID = 0xa20db0e5
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, messages, pts, pts_count):
        """
        :param list[int] messages:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe5\xb0\r\xa2',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateDeleteMessages(messages=_messages, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateDialogPinned(TLObject):
    CONSTRUCTOR_ID = 0xd711a2cc
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, pinned=None):
        """
        :param bool | None pinned:
        :param TLObject peer:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.pinned = pinned
        self.peer = peer

    def to_dict(self, recursive=True):
        return {
            'pinned': self.pinned,
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
        }

    def __bytes__(self):
        return b''.join((
            b'\xcc\xa2\x11\xd7',
            struct.pack('<I', (1 if self.pinned else 0)),
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _pinned = bool(flags & 1)
        _peer = reader.tgread_object()
        return UpdateDialogPinned(peer=_peer, pinned=_pinned)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateDraftMessage(TLObject):
    CONSTRUCTOR_ID = 0xee2bb969
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, draft):
        """
        :param TLObject peer:
        :param TLObject draft:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.peer = peer
        self.draft = draft

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'draft': (None if self.draft is None else self.draft.to_dict()) if recursive else self.draft,
        }

    def __bytes__(self):
        return b''.join((
            b'i\xb9+\xee',
            bytes(self.peer),
            bytes(self.draft),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _draft = reader.tgread_object()
        return UpdateDraftMessage(peer=_peer, draft=_draft)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateEditChannelMessage(TLObject):
    CONSTRUCTOR_ID = 0x1b3f4df7
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param TLObject message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.message = message
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'message': (None if self.message is None else self.message.to_dict()) if recursive else self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf7M?\x1b',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateEditChannelMessage(message=_message, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateEditMessage(TLObject):
    CONSTRUCTOR_ID = 0xe40370a3
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param TLObject message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.message = message
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'message': (None if self.message is None else self.message.to_dict()) if recursive else self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa3p\x03\xe4',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateEditMessage(message=_message, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateEncryptedChatTyping(TLObject):
    CONSTRUCTOR_ID = 0x1710f156
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id):
        """
        :param int chat_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
        }

    def __bytes__(self):
        return b''.join((
            b'V\xf1\x10\x17',
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        return UpdateEncryptedChatTyping(chat_id=_chat_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateEncryptedMessagesRead(TLObject):
    CONSTRUCTOR_ID = 0x38fe25b7
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, max_date, date):
        """
        :param int chat_id:
        :param datetime.datetime | None max_date:
        :param datetime.datetime | None date:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat_id = chat_id
        self.max_date = max_date
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'chat_id': self.chat_id,
            'max_date': self.max_date,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'\xb7%\xfe8',
            struct.pack('<i', self.chat_id),
            b'\0\0\0\0' if self.max_date is None else struct.pack('<I', int(self.max_date.timestamp())),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _max_date = reader.tgread_date()
        _date = reader.tgread_date()
        return UpdateEncryptedMessagesRead(chat_id=_chat_id, max_date=_max_date, date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateEncryption(TLObject):
    CONSTRUCTOR_ID = 0xb4a2e88d
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat, date):
        """
        :param TLObject chat:
        :param datetime.datetime | None date:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.chat = chat
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'chat': (None if self.chat is None else self.chat.to_dict()) if recursive else self.chat,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'\x8d\xe8\xa2\xb4',
            bytes(self.chat),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _chat = reader.tgread_object()
        _date = reader.tgread_date()
        return UpdateEncryption(chat=_chat, date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateFavedStickers(TLObject):
    CONSTRUCTOR_ID = 0xe511996d
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'm\x99\x11\xe5',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateFavedStickers()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateInlineBotCallbackQuery(TLObject):
    CONSTRUCTOR_ID = 0xf9d27a5a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, msg_id, chat_instance, data=None, game_short_name=None):
        """
        :param int query_id:
        :param int user_id:
        :param TLObject msg_id:
        :param int chat_instance:
        :param bytes | None data:
        :param str | None game_short_name:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.query_id = query_id
        self.user_id = user_id
        self.msg_id = msg_id
        self.chat_instance = chat_instance
        self.data = data
        self.game_short_name = game_short_name

    def to_dict(self, recursive=True):
        return {
            'query_id': self.query_id,
            'user_id': self.user_id,
            'msg_id': (None if self.msg_id is None else self.msg_id.to_dict()) if recursive else self.msg_id,
            'chat_instance': self.chat_instance,
            'data': self.data,
            'game_short_name': self.game_short_name,
        }

    def __bytes__(self):
        return b''.join((
            b'Zz\xd2\xf9',
            struct.pack('<I', (1 if self.data else 0) | (2 if self.game_short_name else 0)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            bytes(self.msg_id),
            struct.pack('<q', self.chat_instance),
            b'' if not self.data else (TLObject.serialize_bytes(self.data)),
            b'' if not self.game_short_name else (TLObject.serialize_bytes(self.game_short_name)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _msg_id = reader.tgread_object()
        _chat_instance = reader.read_long()
        if flags & 1:
            _data = reader.tgread_bytes()
        else:
            _data = None
        if flags & 2:
            _game_short_name = reader.tgread_string()
        else:
            _game_short_name = None
        return UpdateInlineBotCallbackQuery(query_id=_query_id, user_id=_user_id, msg_id=_msg_id, chat_instance=_chat_instance, data=_data, game_short_name=_game_short_name)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateLangPack(TLObject):
    CONSTRUCTOR_ID = 0x56022f4d
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, difference):
        """
        :param TLObject difference:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.difference = difference

    def to_dict(self, recursive=True):
        return {
            'difference': (None if self.difference is None else self.difference.to_dict()) if recursive else self.difference,
        }

    def __bytes__(self):
        return b''.join((
            b'M/\x02V',
            bytes(self.difference),
        ))

    @staticmethod
    def from_reader(reader):
        _difference = reader.tgread_object()
        return UpdateLangPack(difference=_difference)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateLangPackTooLong(TLObject):
    CONSTRUCTOR_ID = 0x10c2404b
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'K@\xc2\x10',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateLangPackTooLong()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateMessageID(TLObject):
    CONSTRUCTOR_ID = 0x4e90bfd6
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, id, random_id=None):
        """
        :param int id:
        :param int random_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.id = id
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'random_id': self.random_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd6\xbf\x90N',
            struct.pack('<i', self.id),
            struct.pack('<q', self.random_id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _random_id = reader.read_long()
        return UpdateMessageID(id=_id, random_id=_random_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateNewChannelMessage(TLObject):
    CONSTRUCTOR_ID = 0x62ba04d9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param TLObject message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.message = message
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'message': (None if self.message is None else self.message.to_dict()) if recursive else self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd9\x04\xbab',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateNewChannelMessage(message=_message, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateNewEncryptedMessage(TLObject):
    CONSTRUCTOR_ID = 0x12bcbd9a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, qts):
        """
        :param TLObject message:
        :param int qts:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.message = message
        self.qts = qts

    def to_dict(self, recursive=True):
        return {
            'message': (None if self.message is None else self.message.to_dict()) if recursive else self.message,
            'qts': self.qts,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9a\xbd\xbc\x12',
            bytes(self.message),
            struct.pack('<i', self.qts),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        _qts = reader.read_int()
        return UpdateNewEncryptedMessage(message=_message, qts=_qts)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateNewMessage(TLObject):
    CONSTRUCTOR_ID = 0x1f2b0afd
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param TLObject message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.message = message
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'message': (None if self.message is None else self.message.to_dict()) if recursive else self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\n+\x1f',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateNewMessage(message=_message, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateNewStickerSet(TLObject):
    CONSTRUCTOR_ID = 0x688a30aa
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, stickerset):
        """
        :param TLObject stickerset:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.stickerset = stickerset

    def to_dict(self, recursive=True):
        return {
            'stickerset': (None if self.stickerset is None else self.stickerset.to_dict()) if recursive else self.stickerset,
        }

    def __bytes__(self):
        return b''.join((
            b'\xaa0\x8ah',
            bytes(self.stickerset),
        ))

    @staticmethod
    def from_reader(reader):
        _stickerset = reader.tgread_object()
        return UpdateNewStickerSet(stickerset=_stickerset)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateNotifySettings(TLObject):
    CONSTRUCTOR_ID = 0xbec268ef
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, notify_settings):
        """
        :param TLObject peer:
        :param TLObject notify_settings:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.peer = peer
        self.notify_settings = notify_settings

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'notify_settings': (None if self.notify_settings is None else self.notify_settings.to_dict()) if recursive else self.notify_settings,
        }

    def __bytes__(self):
        return b''.join((
            b'\xefh\xc2\xbe',
            bytes(self.peer),
            bytes(self.notify_settings),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _notify_settings = reader.tgread_object()
        return UpdateNotifySettings(peer=_peer, notify_settings=_notify_settings)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdatePhoneCall(TLObject):
    CONSTRUCTOR_ID = 0xab0f6b1e
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, phone_call):
        """
        :param TLObject phone_call:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.phone_call = phone_call

    def to_dict(self, recursive=True):
        return {
            'phone_call': (None if self.phone_call is None else self.phone_call.to_dict()) if recursive else self.phone_call,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1ek\x0f\xab',
            bytes(self.phone_call),
        ))

    @staticmethod
    def from_reader(reader):
        _phone_call = reader.tgread_object()
        return UpdatePhoneCall(phone_call=_phone_call)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdatePinnedDialogs(TLObject):
    CONSTRUCTOR_ID = 0xd8caf68d
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, order=None):
        """
        :param list[TLObject] | None order:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.order = order

    def to_dict(self, recursive=True):
        return {
            'order': ([] if self.order is None else [None if x is None else x.to_dict() for x in self.order]) if recursive else self.order,
        }

    def __bytes__(self):
        return b''.join((
            b'\x8d\xf6\xca\xd8',
            struct.pack('<I', (1 if self.order else 0)),
            b'' if not self.order else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.order)),b''.join(bytes(x) for x in self.order))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 1:
            reader.read_int()
            _order = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _order.append(_x)

        else:
            _order = None
        return UpdatePinnedDialogs(order=_order)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdatePrivacy(TLObject):
    CONSTRUCTOR_ID = 0xee3b272a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, key, rules):
        """
        :param TLObject key:
        :param list[TLObject] rules:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.key = key
        self.rules = rules

    def to_dict(self, recursive=True):
        return {
            'key': (None if self.key is None else self.key.to_dict()) if recursive else self.key,
            'rules': ([] if self.rules is None else [None if x is None else x.to_dict() for x in self.rules]) if recursive else self.rules,
        }

    def __bytes__(self):
        return b''.join((
            b"*';\xee",
            bytes(self.key),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rules)),b''.join(bytes(x) for x in self.rules),
        ))

    @staticmethod
    def from_reader(reader):
        _key = reader.tgread_object()
        reader.read_int()
        _rules = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rules.append(_x)

        return UpdatePrivacy(key=_key, rules=_rules)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdatePtsChanged(TLObject):
    CONSTRUCTOR_ID = 0x3354678f
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x8fgT3',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdatePtsChanged()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateReadChannelInbox(TLObject):
    CONSTRUCTOR_ID = 0x4214f37f
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, max_id):
        """
        :param int channel_id:
        :param int max_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.max_id = max_id

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
            'max_id': self.max_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xf3\x14B',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.max_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _max_id = reader.read_int()
        return UpdateReadChannelInbox(channel_id=_channel_id, max_id=_max_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateReadChannelOutbox(TLObject):
    CONSTRUCTOR_ID = 0x25d6c9c7
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, max_id):
        """
        :param int channel_id:
        :param int max_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.channel_id = channel_id
        self.max_id = max_id

    def to_dict(self, recursive=True):
        return {
            'channel_id': self.channel_id,
            'max_id': self.max_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7\xc9\xd6%',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.max_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _max_id = reader.read_int()
        return UpdateReadChannelOutbox(channel_id=_channel_id, max_id=_max_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateReadFeaturedStickers(TLObject):
    CONSTRUCTOR_ID = 0x571d2742
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b"B'\x1dW",
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateReadFeaturedStickers()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateReadHistoryInbox(TLObject):
    CONSTRUCTOR_ID = 0x9961fd5c
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, max_id, pts, pts_count):
        """
        :param TLObject peer:
        :param int max_id:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.peer = peer
        self.max_id = max_id
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'max_id': self.max_id,
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\\\xfda\x99',
            bytes(self.peer),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _max_id = reader.read_int()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateReadHistoryInbox(peer=_peer, max_id=_max_id, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateReadHistoryOutbox(TLObject):
    CONSTRUCTOR_ID = 0x2f2f21bf
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, max_id, pts, pts_count):
        """
        :param TLObject peer:
        :param int max_id:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.peer = peer
        self.max_id = max_id
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'peer': (None if self.peer is None else self.peer.to_dict()) if recursive else self.peer,
            'max_id': self.max_id,
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\xbf!//',
            bytes(self.peer),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _max_id = reader.read_int()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateReadHistoryOutbox(peer=_peer, max_id=_max_id, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateReadMessagesContents(TLObject):
    CONSTRUCTOR_ID = 0x68c13933
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, messages, pts, pts_count):
        """
        :param list[int] messages:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'39\xc1h',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateReadMessagesContents(messages=_messages, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateRecentStickers(TLObject):
    CONSTRUCTOR_ID = 0x9a422c20
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b' ,B\x9a',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateRecentStickers()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateSavedGifs(TLObject):
    CONSTRUCTOR_ID = 0x9375341e
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x1e4u\x93',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateSavedGifs()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateServiceNotification(TLObject):
    CONSTRUCTOR_ID = 0xebe46819
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, type, message, media, entities, popup=None, inbox_date=None):
        """
        :param bool | None popup:
        :param datetime.datetime | None inbox_date:
        :param str type:
        :param str message:
        :param TLObject media:
        :param list[TLObject] entities:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.popup = popup
        self.inbox_date = inbox_date
        self.type = type
        self.message = message
        self.media = media
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'popup': self.popup,
            'inbox_date': self.inbox_date,
            'type': self.type,
            'message': self.message,
            'media': (None if self.media is None else self.media.to_dict()) if recursive else self.media,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def __bytes__(self):
        return b''.join((
            b'\x19h\xe4\xeb',
            struct.pack('<I', (1 if self.popup else 0) | (2 if self.inbox_date else 0)),
            b'' if not self.inbox_date else (b'\0\0\0\0' if self.inbox_date is None else struct.pack('<I', int(self.inbox_date.timestamp()))),
            TLObject.serialize_bytes(self.type),
            TLObject.serialize_bytes(self.message),
            bytes(self.media),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _popup = bool(flags & 1)
        if flags & 2:
            _inbox_date = reader.tgread_date()
        else:
            _inbox_date = None
        _type = reader.tgread_string()
        _message = reader.tgread_string()
        _media = reader.tgread_object()
        reader.read_int()
        _entities = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _entities.append(_x)

        return UpdateServiceNotification(type=_type, message=_message, media=_media, entities=_entities, popup=_popup, inbox_date=_inbox_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateShort(TLObject):
    CONSTRUCTOR_ID = 0x78d4dec1
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, update, date):
        """
        :param TLObject update:
        :param datetime.datetime | None date:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.update = update
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'update': (None if self.update is None else self.update.to_dict()) if recursive else self.update,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc1\xde\xd4x',
            bytes(self.update),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _update = reader.tgread_object()
        _date = reader.tgread_date()
        return UpdateShort(update=_update, date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateShortChatMessage(TLObject):
    CONSTRUCTOR_ID = 0x16812688
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, id, from_id, chat_id, message, pts, pts_count, date, out=None, mentioned=None, media_unread=None, silent=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, entities=None):
        """
        :param bool | None out:
        :param bool | None mentioned:
        :param bool | None media_unread:
        :param bool | None silent:
        :param int id:
        :param int from_id:
        :param int chat_id:
        :param str message:
        :param int pts:
        :param int pts_count:
        :param datetime.datetime | None date:
        :param TLObject | None fwd_from:
        :param int | None via_bot_id:
        :param int | None reply_to_msg_id:
        :param list[TLObject] | None entities:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.id = id
        self.from_id = from_id
        self.chat_id = chat_id
        self.message = message
        self.pts = pts
        self.pts_count = pts_count
        self.date = date
        self.fwd_from = fwd_from
        self.via_bot_id = via_bot_id
        self.reply_to_msg_id = reply_to_msg_id
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'id': self.id,
            'from_id': self.from_id,
            'chat_id': self.chat_id,
            'message': self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'fwd_from': (None if self.fwd_from is None else self.fwd_from.to_dict()) if recursive else self.fwd_from,
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def __bytes__(self):
        return b''.join((
            b'\x88&\x81\x16',
            struct.pack('<I', (2 if self.out else 0) | (16 if self.mentioned else 0) | (32 if self.media_unread else 0) | (8192 if self.silent else 0) | (4 if self.fwd_from else 0) | (2048 if self.via_bot_id else 0) | (8 if self.reply_to_msg_id else 0) | (128 if self.entities else 0)),
            struct.pack('<i', self.id),
            struct.pack('<i', self.from_id),
            struct.pack('<i', self.chat_id),
            TLObject.serialize_bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            b'' if not self.fwd_from else (bytes(self.fwd_from)),
            b'' if not self.via_bot_id else (struct.pack('<i', self.via_bot_id)),
            b'' if not self.reply_to_msg_id else (struct.pack('<i', self.reply_to_msg_id)),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _mentioned = bool(flags & 16)
        _media_unread = bool(flags & 32)
        _silent = bool(flags & 8192)
        _id = reader.read_int()
        _from_id = reader.read_int()
        _chat_id = reader.read_int()
        _message = reader.tgread_string()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _date = reader.tgread_date()
        if flags & 4:
            _fwd_from = reader.tgread_object()
        else:
            _fwd_from = None
        if flags & 2048:
            _via_bot_id = reader.read_int()
        else:
            _via_bot_id = None
        if flags & 8:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return UpdateShortChatMessage(id=_id, from_id=_from_id, chat_id=_chat_id, message=_message, pts=_pts, pts_count=_pts_count, date=_date, out=_out, mentioned=_mentioned, media_unread=_media_unread, silent=_silent, fwd_from=_fwd_from, via_bot_id=_via_bot_id, reply_to_msg_id=_reply_to_msg_id, entities=_entities)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateShortMessage(TLObject):
    CONSTRUCTOR_ID = 0x914fbf11
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, id, user_id, message, pts, pts_count, date, out=None, mentioned=None, media_unread=None, silent=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, entities=None):
        """
        :param bool | None out:
        :param bool | None mentioned:
        :param bool | None media_unread:
        :param bool | None silent:
        :param int id:
        :param int user_id:
        :param str message:
        :param int pts:
        :param int pts_count:
        :param datetime.datetime | None date:
        :param TLObject | None fwd_from:
        :param int | None via_bot_id:
        :param int | None reply_to_msg_id:
        :param list[TLObject] | None entities:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.id = id
        self.user_id = user_id
        self.message = message
        self.pts = pts
        self.pts_count = pts_count
        self.date = date
        self.fwd_from = fwd_from
        self.via_bot_id = via_bot_id
        self.reply_to_msg_id = reply_to_msg_id
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'id': self.id,
            'user_id': self.user_id,
            'message': self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'fwd_from': (None if self.fwd_from is None else self.fwd_from.to_dict()) if recursive else self.fwd_from,
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\xbfO\x91',
            struct.pack('<I', (2 if self.out else 0) | (16 if self.mentioned else 0) | (32 if self.media_unread else 0) | (8192 if self.silent else 0) | (4 if self.fwd_from else 0) | (2048 if self.via_bot_id else 0) | (8 if self.reply_to_msg_id else 0) | (128 if self.entities else 0)),
            struct.pack('<i', self.id),
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            b'' if not self.fwd_from else (bytes(self.fwd_from)),
            b'' if not self.via_bot_id else (struct.pack('<i', self.via_bot_id)),
            b'' if not self.reply_to_msg_id else (struct.pack('<i', self.reply_to_msg_id)),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _mentioned = bool(flags & 16)
        _media_unread = bool(flags & 32)
        _silent = bool(flags & 8192)
        _id = reader.read_int()
        _user_id = reader.read_int()
        _message = reader.tgread_string()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _date = reader.tgread_date()
        if flags & 4:
            _fwd_from = reader.tgread_object()
        else:
            _fwd_from = None
        if flags & 2048:
            _via_bot_id = reader.read_int()
        else:
            _via_bot_id = None
        if flags & 8:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return UpdateShortMessage(id=_id, user_id=_user_id, message=_message, pts=_pts, pts_count=_pts_count, date=_date, out=_out, mentioned=_mentioned, media_unread=_media_unread, silent=_silent, fwd_from=_fwd_from, via_bot_id=_via_bot_id, reply_to_msg_id=_reply_to_msg_id, entities=_entities)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateShortSentMessage(TLObject):
    CONSTRUCTOR_ID = 0x11f1331c
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, id, pts, pts_count, date, out=None, media=None, entities=None):
        """
        :param bool | None out:
        :param int id:
        :param int pts:
        :param int pts_count:
        :param datetime.datetime | None date:
        :param TLObject | None media:
        :param list[TLObject] | None entities:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.out = out
        self.id = id
        self.pts = pts
        self.pts_count = pts_count
        self.date = date
        self.media = media
        self.entities = entities

    def to_dict(self, recursive=True):
        return {
            'out': self.out,
            'id': self.id,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'media': (None if self.media is None else self.media.to_dict()) if recursive else self.media,
            'entities': ([] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]) if recursive else self.entities,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c3\xf1\x11',
            struct.pack('<I', (2 if self.out else 0) | (512 if self.media else 0) | (128 if self.entities else 0)),
            struct.pack('<i', self.id),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            b'' if not self.media else (bytes(self.media)),
            b'' if not self.entities else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _id = reader.read_int()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _date = reader.tgread_date()
        if flags & 512:
            _media = reader.tgread_object()
        else:
            _media = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return UpdateShortSentMessage(id=_id, pts=_pts, pts_count=_pts_count, date=_date, out=_out, media=_media, entities=_entities)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateStickerSets(TLObject):
    CONSTRUCTOR_ID = 0x43ae3dec
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xec=\xaeC',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateStickerSets()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateStickerSetsOrder(TLObject):
    CONSTRUCTOR_ID = 0xbb2d201
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, order, masks=None):
        """
        :param bool | None masks:
        :param list[int] order:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.masks = masks
        self.order = order

    def to_dict(self, recursive=True):
        return {
            'masks': self.masks,
            'order': [] if self.order is None else self.order[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\x01\xd2\xb2\x0b',
            struct.pack('<I', (1 if self.masks else 0)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.order)),b''.join(struct.pack('<q', x) for x in self.order),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _masks = bool(flags & 1)
        reader.read_int()
        _order = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _order.append(_x)

        return UpdateStickerSetsOrder(order=_order, masks=_masks)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateUserBlocked(TLObject):
    CONSTRUCTOR_ID = 0x80ece81a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, blocked):
        """
        :param int user_id:
        :param TLObject blocked:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.blocked = blocked

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'blocked': self.blocked,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1a\xe8\xec\x80',
            struct.pack('<i', self.user_id),
            b'\xb5ur\x99' if self.blocked else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _blocked = reader.tgread_bool()
        return UpdateUserBlocked(user_id=_user_id, blocked=_blocked)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateUserName(TLObject):
    CONSTRUCTOR_ID = 0xa7332b73
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, first_name, last_name, username):
        """
        :param int user_id:
        :param str first_name:
        :param str last_name:
        :param str username:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.first_name = first_name
        self.last_name = last_name
        self.username = username

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'username': self.username,
        }

    def __bytes__(self):
        return b''.join((
            b's+3\xa7',
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
            TLObject.serialize_bytes(self.username),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        _username = reader.tgread_string()
        return UpdateUserName(user_id=_user_id, first_name=_first_name, last_name=_last_name, username=_username)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateUserPhone(TLObject):
    CONSTRUCTOR_ID = 0x12b9417b
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, phone):
        """
        :param int user_id:
        :param str phone:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.phone = phone

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'phone': self.phone,
        }

    def __bytes__(self):
        return b''.join((
            b'{A\xb9\x12',
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.phone),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _phone = reader.tgread_string()
        return UpdateUserPhone(user_id=_user_id, phone=_phone)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateUserPhoto(TLObject):
    CONSTRUCTOR_ID = 0x95313b0c
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, date, photo, previous):
        """
        :param int user_id:
        :param datetime.datetime | None date:
        :param TLObject photo:
        :param TLObject previous:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.date = date
        self.photo = photo
        self.previous = previous

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'date': self.date,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'previous': self.previous,
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c;1\x95',
            struct.pack('<i', self.user_id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            bytes(self.photo),
            b'\xb5ur\x99' if self.previous else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        _photo = reader.tgread_object()
        _previous = reader.tgread_bool()
        return UpdateUserPhoto(user_id=_user_id, date=_date, photo=_photo, previous=_previous)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateUserStatus(TLObject):
    CONSTRUCTOR_ID = 0x1bfbd823
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, status):
        """
        :param int user_id:
        :param TLObject status:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.status = status

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'status': (None if self.status is None else self.status.to_dict()) if recursive else self.status,
        }

    def __bytes__(self):
        return b''.join((
            b'#\xd8\xfb\x1b',
            struct.pack('<i', self.user_id),
            bytes(self.status),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _status = reader.tgread_object()
        return UpdateUserStatus(user_id=_user_id, status=_status)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateUserTyping(TLObject):
    CONSTRUCTOR_ID = 0x5c486927
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, action):
        """
        :param int user_id:
        :param TLObject action:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.user_id = user_id
        self.action = action

    def to_dict(self, recursive=True):
        return {
            'user_id': self.user_id,
            'action': (None if self.action is None else self.action.to_dict()) if recursive else self.action,
        }

    def __bytes__(self):
        return b''.join((
            b"'iH\\",
            struct.pack('<i', self.user_id),
            bytes(self.action),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _action = reader.tgread_object()
        return UpdateUserTyping(user_id=_user_id, action=_action)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdateWebPage(TLObject):
    CONSTRUCTOR_ID = 0x7f891213
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, webpage, pts, pts_count):
        """
        :param TLObject webpage:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset.
        """
        super().__init__()

        self.webpage = webpage
        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'webpage': (None if self.webpage is None else self.webpage.to_dict()) if recursive else self.webpage,
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\x13\x12\x89\x7f',
            bytes(self.webpage),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _webpage = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateWebPage(webpage=_webpage, pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Updates(TLObject):
    CONSTRUCTOR_ID = 0x74ae4240
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, updates, users, chats, date, seq):
        """
        :param list[TLObject] updates:
        :param list[TLObject] users:
        :param list[TLObject] chats:
        :param datetime.datetime | None date:
        :param int seq:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.updates = updates
        self.users = users
        self.chats = chats
        self.date = date
        self.seq = seq

    def to_dict(self, recursive=True):
        return {
            'updates': ([] if self.updates is None else [None if x is None else x.to_dict() for x in self.updates]) if recursive else self.updates,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'date': self.date,
            'seq': self.seq,
        }

    def __bytes__(self):
        return b''.join((
            b'@B\xaet',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.updates)),b''.join(bytes(x) for x in self.updates),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.seq),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _updates = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _updates.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        _date = reader.tgread_date()
        _seq = reader.read_int()
        return Updates(updates=_updates, users=_users, chats=_chats, date=_date, seq=_seq)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdatesCombined(TLObject):
    CONSTRUCTOR_ID = 0x725b04c3
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, updates, users, chats, date, seq_start, seq):
        """
        :param list[TLObject] updates:
        :param list[TLObject] users:
        :param list[TLObject] chats:
        :param datetime.datetime | None date:
        :param int seq_start:
        :param int seq:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.updates = updates
        self.users = users
        self.chats = chats
        self.date = date
        self.seq_start = seq_start
        self.seq = seq

    def to_dict(self, recursive=True):
        return {
            'updates': ([] if self.updates is None else [None if x is None else x.to_dict() for x in self.updates]) if recursive else self.updates,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'date': self.date,
            'seq_start': self.seq_start,
            'seq': self.seq,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\x04[r',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.updates)),b''.join(bytes(x) for x in self.updates),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            struct.pack('<i', self.seq_start),
            struct.pack('<i', self.seq),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _updates = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _updates.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        _date = reader.tgread_date()
        _seq_start = reader.read_int()
        _seq = reader.read_int()
        return UpdatesCombined(updates=_updates, users=_users, chats=_chats, date=_date, seq_start=_seq_start, seq=_seq)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UpdatesTooLong(TLObject):
    CONSTRUCTOR_ID = 0xe317af7e
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'~\xaf\x17\xe3',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdatesTooLong()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class User(TLObject):
    CONSTRUCTOR_ID = 0x2e13f4c3
    SUBCLASS_OF_ID = 0x2da17977

    def __init__(self, id, is_self=None, contact=None, mutual_contact=None, deleted=None, bot=None, bot_chat_history=None, bot_nochats=None, verified=None, restricted=None, min=None, bot_inline_geo=None, access_hash=None, first_name=None, last_name=None, username=None, phone=None, photo=None, status=None, bot_info_version=None, restriction_reason=None, bot_inline_placeholder=None, lang_code=None):
        """
        :param bool | None is_self:
        :param bool | None contact:
        :param bool | None mutual_contact:
        :param bool | None deleted:
        :param bool | None bot:
        :param bool | None bot_chat_history:
        :param bool | None bot_nochats:
        :param bool | None verified:
        :param bool | None restricted:
        :param bool | None min:
        :param bool | None bot_inline_geo:
        :param int id:
        :param int | None access_hash:
        :param str | None first_name:
        :param str | None last_name:
        :param str | None username:
        :param str | None phone:
        :param TLObject | None photo:
        :param TLObject | None status:
        :param int | None bot_info_version:
        :param str | None restriction_reason:
        :param str | None bot_inline_placeholder:
        :param str | None lang_code:

        Constructor for User: Instance of either UserEmpty, User.
        """
        super().__init__()

        self.is_self = is_self
        self.contact = contact
        self.mutual_contact = mutual_contact
        self.deleted = deleted
        self.bot = bot
        self.bot_chat_history = bot_chat_history
        self.bot_nochats = bot_nochats
        self.verified = verified
        self.restricted = restricted
        self.min = min
        self.bot_inline_geo = bot_inline_geo
        self.id = id
        self.access_hash = access_hash
        self.first_name = first_name
        self.last_name = last_name
        self.username = username
        self.phone = phone
        self.photo = photo
        self.status = status
        self.bot_info_version = bot_info_version
        self.restriction_reason = restriction_reason
        self.bot_inline_placeholder = bot_inline_placeholder
        self.lang_code = lang_code

    def to_dict(self, recursive=True):
        return {
            'is_self': self.is_self,
            'contact': self.contact,
            'mutual_contact': self.mutual_contact,
            'deleted': self.deleted,
            'bot': self.bot,
            'bot_chat_history': self.bot_chat_history,
            'bot_nochats': self.bot_nochats,
            'verified': self.verified,
            'restricted': self.restricted,
            'min': self.min,
            'bot_inline_geo': self.bot_inline_geo,
            'id': self.id,
            'access_hash': self.access_hash,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'username': self.username,
            'phone': self.phone,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'status': (None if self.status is None else self.status.to_dict()) if recursive else self.status,
            'bot_info_version': self.bot_info_version,
            'restriction_reason': self.restriction_reason,
            'bot_inline_placeholder': self.bot_inline_placeholder,
            'lang_code': self.lang_code,
        }

    def __bytes__(self):
        assert (self.bot is None and self.bot_info_version is None) or (self.bot is not None and self.bot_info_version is not None), 'bot, bot_info_version parameters must all be None or neither be None'
        assert (self.restricted is None and self.restriction_reason is None) or (self.restricted is not None and self.restriction_reason is not None), 'restricted, restriction_reason parameters must all be None or neither be None'
        return b''.join((
            b'\xc3\xf4\x13.',
            struct.pack('<I', (1024 if self.is_self else 0) | (2048 if self.contact else 0) | (4096 if self.mutual_contact else 0) | (8192 if self.deleted else 0) | (16384 if self.bot else 0) | (32768 if self.bot_chat_history else 0) | (65536 if self.bot_nochats else 0) | (131072 if self.verified else 0) | (262144 if self.restricted else 0) | (1048576 if self.min else 0) | (2097152 if self.bot_inline_geo else 0) | (1 if self.access_hash else 0) | (2 if self.first_name else 0) | (4 if self.last_name else 0) | (8 if self.username else 0) | (16 if self.phone else 0) | (32 if self.photo else 0) | (64 if self.status else 0) | (16384 if self.bot_info_version else 0) | (262144 if self.restriction_reason else 0) | (524288 if self.bot_inline_placeholder else 0) | (4194304 if self.lang_code else 0)),
            struct.pack('<i', self.id),
            b'' if not self.access_hash else (struct.pack('<q', self.access_hash)),
            b'' if not self.first_name else (TLObject.serialize_bytes(self.first_name)),
            b'' if not self.last_name else (TLObject.serialize_bytes(self.last_name)),
            b'' if not self.username else (TLObject.serialize_bytes(self.username)),
            b'' if not self.phone else (TLObject.serialize_bytes(self.phone)),
            b'' if not self.photo else (bytes(self.photo)),
            b'' if not self.status else (bytes(self.status)),
            b'' if not self.bot_info_version else (struct.pack('<i', self.bot_info_version)),
            b'' if not self.restriction_reason else (TLObject.serialize_bytes(self.restriction_reason)),
            b'' if not self.bot_inline_placeholder else (TLObject.serialize_bytes(self.bot_inline_placeholder)),
            b'' if not self.lang_code else (TLObject.serialize_bytes(self.lang_code)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _is_self = bool(flags & 1024)
        _contact = bool(flags & 2048)
        _mutual_contact = bool(flags & 4096)
        _deleted = bool(flags & 8192)
        _bot = bool(flags & 16384)
        _bot_chat_history = bool(flags & 32768)
        _bot_nochats = bool(flags & 65536)
        _verified = bool(flags & 131072)
        _restricted = bool(flags & 262144)
        _min = bool(flags & 1048576)
        _bot_inline_geo = bool(flags & 2097152)
        _id = reader.read_int()
        if flags & 1:
            _access_hash = reader.read_long()
        else:
            _access_hash = None
        if flags & 2:
            _first_name = reader.tgread_string()
        else:
            _first_name = None
        if flags & 4:
            _last_name = reader.tgread_string()
        else:
            _last_name = None
        if flags & 8:
            _username = reader.tgread_string()
        else:
            _username = None
        if flags & 16:
            _phone = reader.tgread_string()
        else:
            _phone = None
        if flags & 32:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 64:
            _status = reader.tgread_object()
        else:
            _status = None
        if flags & 16384:
            _bot_info_version = reader.read_int()
        else:
            _bot_info_version = None
        if flags & 262144:
            _restriction_reason = reader.tgread_string()
        else:
            _restriction_reason = None
        if flags & 524288:
            _bot_inline_placeholder = reader.tgread_string()
        else:
            _bot_inline_placeholder = None
        if flags & 4194304:
            _lang_code = reader.tgread_string()
        else:
            _lang_code = None
        return User(id=_id, is_self=_is_self, contact=_contact, mutual_contact=_mutual_contact, deleted=_deleted, bot=_bot, bot_chat_history=_bot_chat_history, bot_nochats=_bot_nochats, verified=_verified, restricted=_restricted, min=_min, bot_inline_geo=_bot_inline_geo, access_hash=_access_hash, first_name=_first_name, last_name=_last_name, username=_username, phone=_phone, photo=_photo, status=_status, bot_info_version=_bot_info_version, restriction_reason=_restriction_reason, bot_inline_placeholder=_bot_inline_placeholder, lang_code=_lang_code)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UserEmpty(TLObject):
    CONSTRUCTOR_ID = 0x200250ba
    SUBCLASS_OF_ID = 0x2da17977

    def __init__(self, id):
        """
        :param int id:

        Constructor for User: Instance of either UserEmpty, User.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xbaP\x02 ',
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        return UserEmpty(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UserFull(TLObject):
    CONSTRUCTOR_ID = 0xf220f3f
    SUBCLASS_OF_ID = 0x1f4661b9

    def __init__(self, user, link, notify_settings, common_chats_count, blocked=None, phone_calls_available=None, phone_calls_private=None, about=None, profile_photo=None, bot_info=None):
        """
        :param bool | None blocked:
        :param bool | None phone_calls_available:
        :param bool | None phone_calls_private:
        :param TLObject user:
        :param str | None about:
        :param TLObject link:
        :param TLObject | None profile_photo:
        :param TLObject notify_settings:
        :param TLObject | None bot_info:
        :param int common_chats_count:

        Constructor for UserFull: Instance of UserFull.
        """
        super().__init__()

        self.blocked = blocked
        self.phone_calls_available = phone_calls_available
        self.phone_calls_private = phone_calls_private
        self.user = user
        self.about = about
        self.link = link
        self.profile_photo = profile_photo
        self.notify_settings = notify_settings
        self.bot_info = bot_info
        self.common_chats_count = common_chats_count

    def to_dict(self, recursive=True):
        return {
            'blocked': self.blocked,
            'phone_calls_available': self.phone_calls_available,
            'phone_calls_private': self.phone_calls_private,
            'user': (None if self.user is None else self.user.to_dict()) if recursive else self.user,
            'about': self.about,
            'link': (None if self.link is None else self.link.to_dict()) if recursive else self.link,
            'profile_photo': (None if self.profile_photo is None else self.profile_photo.to_dict()) if recursive else self.profile_photo,
            'notify_settings': (None if self.notify_settings is None else self.notify_settings.to_dict()) if recursive else self.notify_settings,
            'bot_info': (None if self.bot_info is None else self.bot_info.to_dict()) if recursive else self.bot_info,
            'common_chats_count': self.common_chats_count,
        }

    def __bytes__(self):
        return b''.join((
            b'?\x0f"\x0f',
            struct.pack('<I', (1 if self.blocked else 0) | (16 if self.phone_calls_available else 0) | (32 if self.phone_calls_private else 0) | (2 if self.about else 0) | (4 if self.profile_photo else 0) | (8 if self.bot_info else 0)),
            bytes(self.user),
            b'' if not self.about else (TLObject.serialize_bytes(self.about)),
            bytes(self.link),
            b'' if not self.profile_photo else (bytes(self.profile_photo)),
            bytes(self.notify_settings),
            b'' if not self.bot_info else (bytes(self.bot_info)),
            struct.pack('<i', self.common_chats_count),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _blocked = bool(flags & 1)
        _phone_calls_available = bool(flags & 16)
        _phone_calls_private = bool(flags & 32)
        _user = reader.tgread_object()
        if flags & 2:
            _about = reader.tgread_string()
        else:
            _about = None
        _link = reader.tgread_object()
        if flags & 4:
            _profile_photo = reader.tgread_object()
        else:
            _profile_photo = None
        _notify_settings = reader.tgread_object()
        if flags & 8:
            _bot_info = reader.tgread_object()
        else:
            _bot_info = None
        _common_chats_count = reader.read_int()
        return UserFull(user=_user, link=_link, notify_settings=_notify_settings, common_chats_count=_common_chats_count, blocked=_blocked, phone_calls_available=_phone_calls_available, phone_calls_private=_phone_calls_private, about=_about, profile_photo=_profile_photo, bot_info=_bot_info)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UserProfilePhoto(TLObject):
    CONSTRUCTOR_ID = 0xd559d8c8
    SUBCLASS_OF_ID = 0xc6338f7d

    def __init__(self, photo_id, photo_small, photo_big):
        """
        :param int photo_id:
        :param TLObject photo_small:
        :param TLObject photo_big:

        Constructor for UserProfilePhoto: Instance of either UserProfilePhotoEmpty, UserProfilePhoto.
        """
        super().__init__()

        self.photo_id = photo_id
        self.photo_small = photo_small
        self.photo_big = photo_big

    def to_dict(self, recursive=True):
        return {
            'photo_id': self.photo_id,
            'photo_small': (None if self.photo_small is None else self.photo_small.to_dict()) if recursive else self.photo_small,
            'photo_big': (None if self.photo_big is None else self.photo_big.to_dict()) if recursive else self.photo_big,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8\xd8Y\xd5',
            struct.pack('<q', self.photo_id),
            bytes(self.photo_small),
            bytes(self.photo_big),
        ))

    @staticmethod
    def from_reader(reader):
        _photo_id = reader.read_long()
        _photo_small = reader.tgread_object()
        _photo_big = reader.tgread_object()
        return UserProfilePhoto(photo_id=_photo_id, photo_small=_photo_small, photo_big=_photo_big)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UserProfilePhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x4f11bae1
    SUBCLASS_OF_ID = 0xc6338f7d

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xe1\xba\x11O',
        ))

    @staticmethod
    def from_reader(reader):
        return UserProfilePhotoEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UserStatusEmpty(TLObject):
    CONSTRUCTOR_ID = 0x9d05049
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'IP\xd0\t',
        ))

    @staticmethod
    def from_reader(reader):
        return UserStatusEmpty()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UserStatusLastMonth(TLObject):
    CONSTRUCTOR_ID = 0x77ebc742
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'B\xc7\xebw',
        ))

    @staticmethod
    def from_reader(reader):
        return UserStatusLastMonth()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UserStatusLastWeek(TLObject):
    CONSTRUCTOR_ID = 0x7bf09fc
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xfc\t\xbf\x07',
        ))

    @staticmethod
    def from_reader(reader):
        return UserStatusLastWeek()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UserStatusOffline(TLObject):
    CONSTRUCTOR_ID = 0x8c703f
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self, was_online):
        """
        :param datetime.datetime | None was_online:

        Constructor for UserStatus: Instance of either UserStatusEmpty, UserStatusOnline, UserStatusOffline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth.
        """
        super().__init__()

        self.was_online = was_online

    def to_dict(self, recursive=True):
        return {
            'was_online': self.was_online,
        }

    def __bytes__(self):
        return b''.join((
            b'?p\x8c\x00',
            b'\0\0\0\0' if self.was_online is None else struct.pack('<I', int(self.was_online.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _was_online = reader.tgread_date()
        return UserStatusOffline(was_online=_was_online)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UserStatusOnline(TLObject):
    CONSTRUCTOR_ID = 0xedb93949
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self, expires):
        """
        :param datetime.datetime | None expires:

        Constructor for UserStatus: Instance of either UserStatusEmpty, UserStatusOnline, UserStatusOffline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth.
        """
        super().__init__()

        self.expires = expires

    def to_dict(self, recursive=True):
        return {
            'expires': self.expires,
        }

    def __bytes__(self):
        return b''.join((
            b'I9\xb9\xed',
            b'\0\0\0\0' if self.expires is None else struct.pack('<I', int(self.expires.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _expires = reader.tgread_date()
        return UserStatusOnline(expires=_expires)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class UserStatusRecently(TLObject):
    CONSTRUCTOR_ID = 0xe26f42f1
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xf1Bo\xe2',
        ))

    @staticmethod
    def from_reader(reader):
        return UserStatusRecently()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class WallPaper(TLObject):
    CONSTRUCTOR_ID = 0xccb03657
    SUBCLASS_OF_ID = 0x96a2c98b

    def __init__(self, id, title, sizes, color):
        """
        :param int id:
        :param str title:
        :param list[TLObject] sizes:
        :param int color:

        Constructor for WallPaper: Instance of either WallPaper, WallPaperSolid.
        """
        super().__init__()

        self.id = id
        self.title = title
        self.sizes = sizes
        self.color = color

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'title': self.title,
            'sizes': ([] if self.sizes is None else [None if x is None else x.to_dict() for x in self.sizes]) if recursive else self.sizes,
            'color': self.color,
        }

    def __bytes__(self):
        return b''.join((
            b'W6\xb0\xcc',
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.title),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sizes)),b''.join(bytes(x) for x in self.sizes),
            struct.pack('<i', self.color),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _title = reader.tgread_string()
        reader.read_int()
        _sizes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sizes.append(_x)

        _color = reader.read_int()
        return WallPaper(id=_id, title=_title, sizes=_sizes, color=_color)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class WallPaperSolid(TLObject):
    CONSTRUCTOR_ID = 0x63117f24
    SUBCLASS_OF_ID = 0x96a2c98b

    def __init__(self, id, title, bg_color, color):
        """
        :param int id:
        :param str title:
        :param int bg_color:
        :param int color:

        Constructor for WallPaper: Instance of either WallPaper, WallPaperSolid.
        """
        super().__init__()

        self.id = id
        self.title = title
        self.bg_color = bg_color
        self.color = color

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'title': self.title,
            'bg_color': self.bg_color,
            'color': self.color,
        }

    def __bytes__(self):
        return b''.join((
            b'$\x7f\x11c',
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.title),
            struct.pack('<i', self.bg_color),
            struct.pack('<i', self.color),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _title = reader.tgread_string()
        _bg_color = reader.read_int()
        _color = reader.read_int()
        return WallPaperSolid(id=_id, title=_title, bg_color=_bg_color, color=_color)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class WebDocument(TLObject):
    CONSTRUCTOR_ID = 0xc61acbd8
    SUBCLASS_OF_ID = 0x3b642814

    def __init__(self, url, access_hash, size, mime_type, attributes, dc_id):
        """
        :param str url:
        :param int access_hash:
        :param int size:
        :param str mime_type:
        :param list[TLObject] attributes:
        :param int dc_id:

        Constructor for WebDocument: Instance of WebDocument.
        """
        super().__init__()

        self.url = url
        self.access_hash = access_hash
        self.size = size
        self.mime_type = mime_type
        self.attributes = attributes
        self.dc_id = dc_id

    def to_dict(self, recursive=True):
        return {
            'url': self.url,
            'access_hash': self.access_hash,
            'size': self.size,
            'mime_type': self.mime_type,
            'attributes': ([] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes]) if recursive else self.attributes,
            'dc_id': self.dc_id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd8\xcb\x1a\xc6',
            TLObject.serialize_bytes(self.url),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.size),
            TLObject.serialize_bytes(self.mime_type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
            struct.pack('<i', self.dc_id),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _access_hash = reader.read_long()
        _size = reader.read_int()
        _mime_type = reader.tgread_string()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        _dc_id = reader.read_int()
        return WebDocument(url=_url, access_hash=_access_hash, size=_size, mime_type=_mime_type, attributes=_attributes, dc_id=_dc_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class WebPage(TLObject):
    CONSTRUCTOR_ID = 0x5f07b4bc
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, id, url, display_url, hash, type=None, site_name=None, title=None, description=None, photo=None, embed_url=None, embed_type=None, embed_width=None, embed_height=None, duration=None, author=None, document=None, cached_page=None):
        """
        :param int id:
        :param str url:
        :param str display_url:
        :param int hash:
        :param str | None type:
        :param str | None site_name:
        :param str | None title:
        :param str | None description:
        :param TLObject | None photo:
        :param str | None embed_url:
        :param str | None embed_type:
        :param int | None embed_width:
        :param int | None embed_height:
        :param int | None duration:
        :param str | None author:
        :param TLObject | None document:
        :param TLObject | None cached_page:

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()

        self.id = id
        self.url = url
        self.display_url = display_url
        self.hash = hash
        self.type = type
        self.site_name = site_name
        self.title = title
        self.description = description
        self.photo = photo
        self.embed_url = embed_url
        self.embed_type = embed_type
        self.embed_width = embed_width
        self.embed_height = embed_height
        self.duration = duration
        self.author = author
        self.document = document
        self.cached_page = cached_page

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'url': self.url,
            'display_url': self.display_url,
            'hash': self.hash,
            'type': self.type,
            'site_name': self.site_name,
            'title': self.title,
            'description': self.description,
            'photo': (None if self.photo is None else self.photo.to_dict()) if recursive else self.photo,
            'embed_url': self.embed_url,
            'embed_type': self.embed_type,
            'embed_width': self.embed_width,
            'embed_height': self.embed_height,
            'duration': self.duration,
            'author': self.author,
            'document': (None if self.document is None else self.document.to_dict()) if recursive else self.document,
            'cached_page': (None if self.cached_page is None else self.cached_page.to_dict()) if recursive else self.cached_page,
        }

    def __bytes__(self):
        assert (self.embed_url is None and self.embed_type is None) or (self.embed_url is not None and self.embed_type is not None), 'embed_url, embed_type parameters must all be None or neither be None'
        assert (self.embed_width is None and self.embed_height is None) or (self.embed_width is not None and self.embed_height is not None), 'embed_width, embed_height parameters must all be None or neither be None'
        return b''.join((
            b'\xbc\xb4\x07_',
            struct.pack('<I', (1 if self.type else 0) | (2 if self.site_name else 0) | (4 if self.title else 0) | (8 if self.description else 0) | (16 if self.photo else 0) | (32 if self.embed_url else 0) | (32 if self.embed_type else 0) | (64 if self.embed_width else 0) | (64 if self.embed_height else 0) | (128 if self.duration else 0) | (256 if self.author else 0) | (512 if self.document else 0) | (1024 if self.cached_page else 0)),
            struct.pack('<q', self.id),
            TLObject.serialize_bytes(self.url),
            TLObject.serialize_bytes(self.display_url),
            struct.pack('<i', self.hash),
            b'' if not self.type else (TLObject.serialize_bytes(self.type)),
            b'' if not self.site_name else (TLObject.serialize_bytes(self.site_name)),
            b'' if not self.title else (TLObject.serialize_bytes(self.title)),
            b'' if not self.description else (TLObject.serialize_bytes(self.description)),
            b'' if not self.photo else (bytes(self.photo)),
            b'' if not self.embed_url else (TLObject.serialize_bytes(self.embed_url)),
            b'' if not self.embed_type else (TLObject.serialize_bytes(self.embed_type)),
            b'' if not self.embed_width else (struct.pack('<i', self.embed_width)),
            b'' if not self.embed_height else (struct.pack('<i', self.embed_height)),
            b'' if not self.duration else (struct.pack('<i', self.duration)),
            b'' if not self.author else (TLObject.serialize_bytes(self.author)),
            b'' if not self.document else (bytes(self.document)),
            b'' if not self.cached_page else (bytes(self.cached_page)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.read_long()
        _url = reader.tgread_string()
        _display_url = reader.tgread_string()
        _hash = reader.read_int()
        if flags & 1:
            _type = reader.tgread_string()
        else:
            _type = None
        if flags & 2:
            _site_name = reader.tgread_string()
        else:
            _site_name = None
        if flags & 4:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 8:
            _description = reader.tgread_string()
        else:
            _description = None
        if flags & 16:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 32:
            _embed_url = reader.tgread_string()
        else:
            _embed_url = None
        if flags & 32:
            _embed_type = reader.tgread_string()
        else:
            _embed_type = None
        if flags & 64:
            _embed_width = reader.read_int()
        else:
            _embed_width = None
        if flags & 64:
            _embed_height = reader.read_int()
        else:
            _embed_height = None
        if flags & 128:
            _duration = reader.read_int()
        else:
            _duration = None
        if flags & 256:
            _author = reader.tgread_string()
        else:
            _author = None
        if flags & 512:
            _document = reader.tgread_object()
        else:
            _document = None
        if flags & 1024:
            _cached_page = reader.tgread_object()
        else:
            _cached_page = None
        return WebPage(id=_id, url=_url, display_url=_display_url, hash=_hash, type=_type, site_name=_site_name, title=_title, description=_description, photo=_photo, embed_url=_embed_url, embed_type=_embed_type, embed_width=_embed_width, embed_height=_embed_height, duration=_duration, author=_author, document=_document, cached_page=_cached_page)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class WebPageEmpty(TLObject):
    CONSTRUCTOR_ID = 0xeb1477e8
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, id):
        """
        :param int id:

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()

        self.id = id

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe8w\x14\xeb',
            struct.pack('<q', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        return WebPageEmpty(id=_id)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class WebPageNotModified(TLObject):
    CONSTRUCTOR_ID = 0x85849473
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b's\x94\x84\x85',
        ))

    @staticmethod
    def from_reader(reader):
        return WebPageNotModified()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class WebPagePending(TLObject):
    CONSTRUCTOR_ID = 0xc586da1c
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, id, date):
        """
        :param int id:
        :param datetime.datetime | None date:

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()

        self.id = id
        self.date = date

    def to_dict(self, recursive=True):
        return {
            'id': self.id,
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c\xda\x86\xc5',
            struct.pack('<q', self.id),
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _date = reader.tgread_date()
        return WebPagePending(id=_id, date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
