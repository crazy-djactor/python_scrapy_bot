"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from ...tl import types
import os
import struct


class AffectedHistory(TLObject):
    CONSTRUCTOR_ID = 0xb45c69d1
    SUBCLASS_OF_ID = 0x2c49c116

    def __init__(self, pts, pts_count, offset):
        """
        :param int pts:
        :param int pts_count:
        :param int offset:

        Constructor for messages.AffectedHistory: Instance of AffectedHistory.
        """
        super().__init__()

        self.pts = pts
        self.pts_count = pts_count
        self.offset = offset

    def to_dict(self, recursive=True):
        return {
            'pts': self.pts,
            'pts_count': self.pts_count,
            'offset': self.offset,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd1i\\\xb4',
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            struct.pack('<i', self.offset),
        ))

    @staticmethod
    def from_reader(reader):
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _offset = reader.read_int()
        return AffectedHistory(pts=_pts, pts_count=_pts_count, offset=_offset)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class AffectedMessages(TLObject):
    CONSTRUCTOR_ID = 0x84d19185
    SUBCLASS_OF_ID = 0xced3c06e

    def __init__(self, pts, pts_count):
        """
        :param int pts:
        :param int pts_count:

        Constructor for messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()

        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self, recursive=True):
        return {
            'pts': self.pts,
            'pts_count': self.pts_count,
        }

    def __bytes__(self):
        return b''.join((
            b'\x85\x91\xd1\x84',
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return AffectedMessages(pts=_pts, pts_count=_pts_count)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class AllStickers(TLObject):
    CONSTRUCTOR_ID = 0xedfd405f
    SUBCLASS_OF_ID = 0x45834829

    def __init__(self, hash, sets):
        """
        :param int hash:
        :param list[TLObject] sets:

        Constructor for messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        super().__init__()

        self.hash = hash
        self.sets = sets

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'sets': ([] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]) if recursive else self.sets,
        }

    def __bytes__(self):
        return b''.join((
            b'_@\xfd\xed',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        return AllStickers(hash=_hash, sets=_sets)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class AllStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0xe86602c3
    SUBCLASS_OF_ID = 0x45834829

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xc3\x02f\xe8',
        ))

    @staticmethod
    def from_reader(reader):
        return AllStickersNotModified()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ArchivedStickers(TLObject):
    CONSTRUCTOR_ID = 0x4fcba9c8
    SUBCLASS_OF_ID = 0x7296d771

    def __init__(self, count, sets):
        """
        :param int count:
        :param list[TLObject] sets:

        Constructor for messages.ArchivedStickers: Instance of ArchivedStickers.
        """
        super().__init__()

        self.count = count
        self.sets = sets

    def to_dict(self, recursive=True):
        return {
            'count': self.count,
            'sets': ([] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]) if recursive else self.sets,
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8\xa9\xcbO',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
        ))

    @staticmethod
    def from_reader(reader):
        _count = reader.read_int()
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        return ArchivedStickers(count=_count, sets=_sets)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotCallbackAnswer(TLObject):
    CONSTRUCTOR_ID = 0x36585ea4
    SUBCLASS_OF_ID = 0x6c4dd18c

    def __init__(self, cache_time, alert=None, has_url=None, message=None, url=None):
        """
        :param bool | None alert:
        :param bool | None has_url:
        :param str | None message:
        :param str | None url:
        :param int cache_time:

        Constructor for messages.BotCallbackAnswer: Instance of BotCallbackAnswer.
        """
        super().__init__()

        self.alert = alert
        self.has_url = has_url
        self.message = message
        self.url = url
        self.cache_time = cache_time

    def to_dict(self, recursive=True):
        return {
            'alert': self.alert,
            'has_url': self.has_url,
            'message': self.message,
            'url': self.url,
            'cache_time': self.cache_time,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa4^X6',
            struct.pack('<I', (2 if self.alert else 0) | (8 if self.has_url else 0) | (1 if self.message else 0) | (4 if self.url else 0)),
            b'' if not self.message else (TLObject.serialize_bytes(self.message)),
            b'' if not self.url else (TLObject.serialize_bytes(self.url)),
            struct.pack('<i', self.cache_time),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _alert = bool(flags & 2)
        _has_url = bool(flags & 8)
        if flags & 1:
            _message = reader.tgread_string()
        else:
            _message = None
        if flags & 4:
            _url = reader.tgread_string()
        else:
            _url = None
        _cache_time = reader.read_int()
        return BotCallbackAnswer(cache_time=_cache_time, alert=_alert, has_url=_has_url, message=_message, url=_url)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class BotResults(TLObject):
    CONSTRUCTOR_ID = 0xccd3563d
    SUBCLASS_OF_ID = 0x3ed4d9c9

    def __init__(self, query_id, results, cache_time, gallery=None, next_offset=None, switch_pm=None):
        """
        :param bool | None gallery:
        :param int query_id:
        :param str | None next_offset:
        :param TLObject | None switch_pm:
        :param list[TLObject] results:
        :param int cache_time:

        Constructor for messages.BotResults: Instance of BotResults.
        """
        super().__init__()

        self.gallery = gallery
        self.query_id = query_id
        self.next_offset = next_offset
        self.switch_pm = switch_pm
        self.results = results
        self.cache_time = cache_time

    def to_dict(self, recursive=True):
        return {
            'gallery': self.gallery,
            'query_id': self.query_id,
            'next_offset': self.next_offset,
            'switch_pm': (None if self.switch_pm is None else self.switch_pm.to_dict()) if recursive else self.switch_pm,
            'results': ([] if self.results is None else [None if x is None else x.to_dict() for x in self.results]) if recursive else self.results,
            'cache_time': self.cache_time,
        }

    def __bytes__(self):
        return b''.join((
            b'=V\xd3\xcc',
            struct.pack('<I', (1 if self.gallery else 0) | (2 if self.next_offset else 0) | (4 if self.switch_pm else 0)),
            struct.pack('<q', self.query_id),
            b'' if not self.next_offset else (TLObject.serialize_bytes(self.next_offset)),
            b'' if not self.switch_pm else (bytes(self.switch_pm)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.results)),b''.join(bytes(x) for x in self.results),
            struct.pack('<i', self.cache_time),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _gallery = bool(flags & 1)
        _query_id = reader.read_long()
        if flags & 2:
            _next_offset = reader.tgread_string()
        else:
            _next_offset = None
        if flags & 4:
            _switch_pm = reader.tgread_object()
        else:
            _switch_pm = None
        reader.read_int()
        _results = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _results.append(_x)

        _cache_time = reader.read_int()
        return BotResults(query_id=_query_id, results=_results, cache_time=_cache_time, gallery=_gallery, next_offset=_next_offset, switch_pm=_switch_pm)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChannelMessages(TLObject):
    CONSTRUCTOR_ID = 0x99262e37
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, pts, count, messages, chats, users):
        """
        :param int pts:
        :param int count:
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()

        self.pts = pts
        self.count = count
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'pts': self.pts,
            'count': self.count,
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def __bytes__(self):
        return b''.join((
            b'7.&\x99',
            struct.pack('<I', ),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _pts = reader.read_int()
        _count = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return ChannelMessages(pts=_pts, count=_count, messages=_messages, chats=_chats, users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatFull(TLObject):
    CONSTRUCTOR_ID = 0xe5d7d19c
    SUBCLASS_OF_ID = 0x225a5109

    def __init__(self, full_chat, chats, users):
        """
        :param TLObject full_chat:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.ChatFull: Instance of ChatFull.
        """
        super().__init__()

        self.full_chat = full_chat
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'full_chat': (None if self.full_chat is None else self.full_chat.to_dict()) if recursive else self.full_chat,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def __bytes__(self):
        return b''.join((
            b'\x9c\xd1\xd7\xe5',
            bytes(self.full_chat),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        _full_chat = reader.tgread_object()
        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return ChatFull(full_chat=_full_chat, chats=_chats, users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Chats(TLObject):
    CONSTRUCTOR_ID = 0x64ff9fd5
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, chats):
        """
        :param list[TLObject] chats:

        Constructor for messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()

        self.chats = chats

    def to_dict(self, recursive=True):
        return {
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
        }

    def __bytes__(self):
        return b''.join((
            b'\xd5\x9f\xffd',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        return Chats(chats=_chats)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class ChatsSlice(TLObject):
    CONSTRUCTOR_ID = 0x9cd81144
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, count, chats):
        """
        :param int count:
        :param list[TLObject] chats:

        Constructor for messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()

        self.count = count
        self.chats = chats

    def to_dict(self, recursive=True):
        return {
            'count': self.count,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
        }

    def __bytes__(self):
        return b''.join((
            b'D\x11\xd8\x9c',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
        ))

    @staticmethod
    def from_reader(reader):
        _count = reader.read_int()
        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        return ChatsSlice(count=_count, chats=_chats)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DhConfig(TLObject):
    CONSTRUCTOR_ID = 0x2c221edd
    SUBCLASS_OF_ID = 0xe488ed8b

    def __init__(self, g, p, version, random):
        """
        :param int g:
        :param bytes p:
        :param int version:
        :param bytes random:

        Constructor for messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()

        self.g = g
        self.p = p
        self.version = version
        self.random = random

    def to_dict(self, recursive=True):
        return {
            'g': self.g,
            'p': self.p,
            'version': self.version,
            'random': self.random,
        }

    def __bytes__(self):
        return b''.join((
            b'\xdd\x1e",',
            struct.pack('<i', self.g),
            TLObject.serialize_bytes(self.p),
            struct.pack('<i', self.version),
            TLObject.serialize_bytes(self.random),
        ))

    @staticmethod
    def from_reader(reader):
        _g = reader.read_int()
        _p = reader.tgread_bytes()
        _version = reader.read_int()
        _random = reader.tgread_bytes()
        return DhConfig(g=_g, p=_p, version=_version, random=_random)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DhConfigNotModified(TLObject):
    CONSTRUCTOR_ID = 0xc0e24635
    SUBCLASS_OF_ID = 0xe488ed8b

    def __init__(self, random):
        """
        :param bytes random:

        Constructor for messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()

        self.random = random

    def to_dict(self, recursive=True):
        return {
            'random': self.random,
        }

    def __bytes__(self):
        return b''.join((
            b'5F\xe2\xc0',
            TLObject.serialize_bytes(self.random),
        ))

    @staticmethod
    def from_reader(reader):
        _random = reader.tgread_bytes()
        return DhConfigNotModified(random=_random)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Dialogs(TLObject):
    CONSTRUCTOR_ID = 0x15ba6c40
    SUBCLASS_OF_ID = 0xe1b52ee

    def __init__(self, dialogs, messages, chats, users):
        """
        :param list[TLObject] dialogs:
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()

        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'dialogs': ([] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs]) if recursive else self.dialogs,
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def __bytes__(self):
        return b''.join((
            b'@l\xba\x15',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dialogs)),b''.join(bytes(x) for x in self.dialogs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _dialogs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dialogs.append(_x)

        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return Dialogs(dialogs=_dialogs, messages=_messages, chats=_chats, users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class DialogsSlice(TLObject):
    CONSTRUCTOR_ID = 0x71e094f3
    SUBCLASS_OF_ID = 0xe1b52ee

    def __init__(self, count, dialogs, messages, chats, users):
        """
        :param int count:
        :param list[TLObject] dialogs:
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()

        self.count = count
        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'count': self.count,
            'dialogs': ([] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs]) if recursive else self.dialogs,
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def __bytes__(self):
        return b''.join((
            b'\xf3\x94\xe0q',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dialogs)),b''.join(bytes(x) for x in self.dialogs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        _count = reader.read_int()
        reader.read_int()
        _dialogs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dialogs.append(_x)

        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return DialogsSlice(count=_count, dialogs=_dialogs, messages=_messages, chats=_chats, users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FavedStickers(TLObject):
    CONSTRUCTOR_ID = 0xf37f2f16
    SUBCLASS_OF_ID = 0x8e736fb9

    def __init__(self, hash, packs, stickers):
        """
        :param int hash:
        :param list[TLObject] packs:
        :param list[TLObject] stickers:

        Constructor for messages.FavedStickers: Instance of either FavedStickersNotModified, FavedStickers.
        """
        super().__init__()

        self.hash = hash
        self.packs = packs
        self.stickers = stickers

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'packs': ([] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs]) if recursive else self.packs,
            'stickers': ([] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]) if recursive else self.stickers,
        }

    def __bytes__(self):
        return b''.join((
            b'\x16/\x7f\xf3',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.packs)),b''.join(bytes(x) for x in self.packs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        reader.read_int()
        _packs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _packs.append(_x)

        reader.read_int()
        _stickers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _stickers.append(_x)

        return FavedStickers(hash=_hash, packs=_packs, stickers=_stickers)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FavedStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0x9e8fa6d3
    SUBCLASS_OF_ID = 0x8e736fb9

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xd3\xa6\x8f\x9e',
        ))

    @staticmethod
    def from_reader(reader):
        return FavedStickersNotModified()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FeaturedStickers(TLObject):
    CONSTRUCTOR_ID = 0xf89d88e5
    SUBCLASS_OF_ID = 0x2614b722

    def __init__(self, hash, sets, unread):
        """
        :param int hash:
        :param list[TLObject] sets:
        :param list[int] unread:

        Constructor for messages.FeaturedStickers: Instance of either FeaturedStickersNotModified, FeaturedStickers.
        """
        super().__init__()

        self.hash = hash
        self.sets = sets
        self.unread = unread

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'sets': ([] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]) if recursive else self.sets,
            'unread': [] if self.unread is None else self.unread[:],
        }

    def __bytes__(self):
        return b''.join((
            b'\xe5\x88\x9d\xf8',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.unread)),b''.join(struct.pack('<q', x) for x in self.unread),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        reader.read_int()
        _unread = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _unread.append(_x)

        return FeaturedStickers(hash=_hash, sets=_sets, unread=_unread)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FeaturedStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0x4ede3cf
    SUBCLASS_OF_ID = 0x2614b722

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xcf\xe3\xed\x04',
        ))

    @staticmethod
    def from_reader(reader):
        return FeaturedStickersNotModified()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class FoundGifs(TLObject):
    CONSTRUCTOR_ID = 0x450a1c0a
    SUBCLASS_OF_ID = 0xe799ea7

    def __init__(self, next_offset, results):
        """
        :param int next_offset:
        :param list[TLObject] results:

        Constructor for messages.FoundGifs: Instance of FoundGifs.
        """
        super().__init__()

        self.next_offset = next_offset
        self.results = results

    def to_dict(self, recursive=True):
        return {
            'next_offset': self.next_offset,
            'results': ([] if self.results is None else [None if x is None else x.to_dict() for x in self.results]) if recursive else self.results,
        }

    def __bytes__(self):
        return b''.join((
            b'\n\x1c\nE',
            struct.pack('<i', self.next_offset),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.results)),b''.join(bytes(x) for x in self.results),
        ))

    @staticmethod
    def from_reader(reader):
        _next_offset = reader.read_int()
        reader.read_int()
        _results = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _results.append(_x)

        return FoundGifs(next_offset=_next_offset, results=_results)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class HighScores(TLObject):
    CONSTRUCTOR_ID = 0x9a3bfd99
    SUBCLASS_OF_ID = 0x6ccd95fd

    def __init__(self, scores, users):
        """
        :param list[TLObject] scores:
        :param list[TLObject] users:

        Constructor for messages.HighScores: Instance of HighScores.
        """
        super().__init__()

        self.scores = scores
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'scores': ([] if self.scores is None else [None if x is None else x.to_dict() for x in self.scores]) if recursive else self.scores,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def __bytes__(self):
        return b''.join((
            b'\x99\xfd;\x9a',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.scores)),b''.join(bytes(x) for x in self.scores),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _scores = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _scores.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return HighScores(scores=_scores, users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessageEditData(TLObject):
    CONSTRUCTOR_ID = 0x26b5dde6
    SUBCLASS_OF_ID = 0xfb47949d

    def __init__(self, caption=None):
        """
        :param bool | None caption:

        Constructor for messages.MessageEditData: Instance of MessageEditData.
        """
        super().__init__()

        self.caption = caption

    def to_dict(self, recursive=True):
        return {
            'caption': self.caption,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe6\xdd\xb5&',
            struct.pack('<I', (1 if self.caption else 0)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _caption = bool(flags & 1)
        return MessageEditData(caption=_caption)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Messages(TLObject):
    CONSTRUCTOR_ID = 0x8c718e87
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, messages, chats, users):
        """
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()

        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def __bytes__(self):
        return b''.join((
            b'\x87\x8eq\x8c',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return Messages(messages=_messages, chats=_chats, users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class MessagesSlice(TLObject):
    CONSTRUCTOR_ID = 0xb446ae3
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, count, messages, chats, users):
        """
        :param int count:
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages.
        """
        super().__init__()

        self.count = count
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self, recursive=True):
        return {
            'count': self.count,
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
        }

    def __bytes__(self):
        return b''.join((
            b'\xe3jD\x0b',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        _count = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return MessagesSlice(count=_count, messages=_messages, chats=_chats, users=_users)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class PeerDialogs(TLObject):
    CONSTRUCTOR_ID = 0x3371c354
    SUBCLASS_OF_ID = 0x3ac70132

    def __init__(self, dialogs, messages, chats, users, state):
        """
        :param list[TLObject] dialogs:
        :param list[TLObject] messages:
        :param list[TLObject] chats:
        :param list[TLObject] users:
        :param TLObject state:

        Constructor for messages.PeerDialogs: Instance of PeerDialogs.
        """
        super().__init__()

        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users
        self.state = state

    def to_dict(self, recursive=True):
        return {
            'dialogs': ([] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs]) if recursive else self.dialogs,
            'messages': ([] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages]) if recursive else self.messages,
            'chats': ([] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]) if recursive else self.chats,
            'users': ([] if self.users is None else [None if x is None else x.to_dict() for x in self.users]) if recursive else self.users,
            'state': (None if self.state is None else self.state.to_dict()) if recursive else self.state,
        }

    def __bytes__(self):
        return b''.join((
            b'T\xc3q3',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dialogs)),b''.join(bytes(x) for x in self.dialogs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            bytes(self.state),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _dialogs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dialogs.append(_x)

        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        _state = reader.tgread_object()
        return PeerDialogs(dialogs=_dialogs, messages=_messages, chats=_chats, users=_users, state=_state)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class RecentStickers(TLObject):
    CONSTRUCTOR_ID = 0x5ce20970
    SUBCLASS_OF_ID = 0xf76f8683

    def __init__(self, hash, stickers):
        """
        :param int hash:
        :param list[TLObject] stickers:

        Constructor for messages.RecentStickers: Instance of either RecentStickersNotModified, RecentStickers.
        """
        super().__init__()

        self.hash = hash
        self.stickers = stickers

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'stickers': ([] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]) if recursive else self.stickers,
        }

    def __bytes__(self):
        return b''.join((
            b'p\t\xe2\\',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        reader.read_int()
        _stickers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _stickers.append(_x)

        return RecentStickers(hash=_hash, stickers=_stickers)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class RecentStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0xb17f890
    SUBCLASS_OF_ID = 0xf76f8683

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\x90\xf8\x17\x0b',
        ))

    @staticmethod
    def from_reader(reader):
        return RecentStickersNotModified()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SavedGifs(TLObject):
    CONSTRUCTOR_ID = 0x2e0709a5
    SUBCLASS_OF_ID = 0xa68b61f5

    def __init__(self, hash, gifs):
        """
        :param int hash:
        :param list[TLObject] gifs:

        Constructor for messages.SavedGifs: Instance of either SavedGifsNotModified, SavedGifs.
        """
        super().__init__()

        self.hash = hash
        self.gifs = gifs

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'gifs': ([] if self.gifs is None else [None if x is None else x.to_dict() for x in self.gifs]) if recursive else self.gifs,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa5\t\x07.',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.gifs)),b''.join(bytes(x) for x in self.gifs),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        reader.read_int()
        _gifs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _gifs.append(_x)

        return SavedGifs(hash=_hash, gifs=_gifs)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SavedGifsNotModified(TLObject):
    CONSTRUCTOR_ID = 0xe8025ca2
    SUBCLASS_OF_ID = 0xa68b61f5

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'\xa2\\\x02\xe8',
        ))

    @staticmethod
    def from_reader(reader):
        return SavedGifsNotModified()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SentEncryptedFile(TLObject):
    CONSTRUCTOR_ID = 0x9493ff32
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, date, file):
        """
        :param datetime.datetime | None date:
        :param TLObject file:

        Constructor for messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()

        self.date = date
        self.file = file

    def to_dict(self, recursive=True):
        return {
            'date': self.date,
            'file': (None if self.file is None else self.file.to_dict()) if recursive else self.file,
        }

    def __bytes__(self):
        return b''.join((
            b'2\xff\x93\x94',
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
            bytes(self.file),
        ))

    @staticmethod
    def from_reader(reader):
        _date = reader.tgread_date()
        _file = reader.tgread_object()
        return SentEncryptedFile(date=_date, file=_file)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class SentEncryptedMessage(TLObject):
    CONSTRUCTOR_ID = 0x560f8935
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, date):
        """
        :param datetime.datetime | None date:

        Constructor for messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()

        self.date = date

    def to_dict(self, recursive=True):
        return {
            'date': self.date,
        }

    def __bytes__(self):
        return b''.join((
            b'5\x89\x0fV',
            b'\0\0\0\0' if self.date is None else struct.pack('<I', int(self.date.timestamp())),
        ))

    @staticmethod
    def from_reader(reader):
        _date = reader.tgread_date()
        return SentEncryptedMessage(date=_date)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickerSet(TLObject):
    CONSTRUCTOR_ID = 0xb60a24a6
    SUBCLASS_OF_ID = 0x9b704a5a

    def __init__(self, set, packs, documents):
        """
        :param TLObject set:
        :param list[TLObject] packs:
        :param list[TLObject] documents:

        Constructor for messages.StickerSet: Instance of StickerSet.
        """
        super().__init__()

        self.set = set
        self.packs = packs
        self.documents = documents

    def to_dict(self, recursive=True):
        return {
            'set': (None if self.set is None else self.set.to_dict()) if recursive else self.set,
            'packs': ([] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs]) if recursive else self.packs,
            'documents': ([] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents]) if recursive else self.documents,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa6$\n\xb6',
            bytes(self.set),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.packs)),b''.join(bytes(x) for x in self.packs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(bytes(x) for x in self.documents),
        ))

    @staticmethod
    def from_reader(reader):
        _set = reader.tgread_object()
        reader.read_int()
        _packs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _packs.append(_x)

        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _documents.append(_x)

        return StickerSet(set=_set, packs=_packs, documents=_documents)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickerSetInstallResultArchive(TLObject):
    CONSTRUCTOR_ID = 0x35e410a8
    SUBCLASS_OF_ID = 0x67cb3fe8

    def __init__(self, sets):
        """
        :param list[TLObject] sets:

        Constructor for messages.StickerSetInstallResult: Instance of either StickerSetInstallResultSuccess, StickerSetInstallResultArchive.
        """
        super().__init__()

        self.sets = sets

    def to_dict(self, recursive=True):
        return {
            'sets': ([] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]) if recursive else self.sets,
        }

    def __bytes__(self):
        return b''.join((
            b'\xa8\x10\xe45',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        return StickerSetInstallResultArchive(sets=_sets)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickerSetInstallResultSuccess(TLObject):
    CONSTRUCTOR_ID = 0x38641628
    SUBCLASS_OF_ID = 0x67cb3fe8

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'(\x16d8',
        ))

    @staticmethod
    def from_reader(reader):
        return StickerSetInstallResultSuccess()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class Stickers(TLObject):
    CONSTRUCTOR_ID = 0x8a8ecd32
    SUBCLASS_OF_ID = 0xd73bb9de

    def __init__(self, hash, stickers):
        """
        :param str hash:
        :param list[TLObject] stickers:

        Constructor for messages.Stickers: Instance of either StickersNotModified, Stickers.
        """
        super().__init__()

        self.hash = hash
        self.stickers = stickers

    def to_dict(self, recursive=True):
        return {
            'hash': self.hash,
            'stickers': ([] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]) if recursive else self.stickers,
        }

    def __bytes__(self):
        return b''.join((
            b'2\xcd\x8e\x8a',
            TLObject.serialize_bytes(self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.tgread_string()
        reader.read_int()
        _stickers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _stickers.append(_x)

        return Stickers(hash=_hash, stickers=_stickers)

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)


class StickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0xf1749a22
    SUBCLASS_OF_ID = 0xd73bb9de

    def __init__(self):
        super().__init__()

    def to_dict(self, recursive=True):
        return {}

    def __bytes__(self):
        return b''.join((
            b'"\x9at\xf1',
        ))

    @staticmethod
    def from_reader(reader):
        return StickersNotModified()

    def __str__(self):
        return TLObject.pretty_format(self)

    def stringify(self):
        return TLObject.pretty_format(self, indent=0)
